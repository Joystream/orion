diff --git a/node_modules/@joystream/metadata-protobuf/compiled/compiled/index.d.ts b/node_modules/@joystream/metadata-protobuf/compiled/compiled/index.d.ts
new file mode 100644
index 0000000..dccaf98
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/compiled/compiled/index.d.ts
@@ -0,0 +1,6675 @@
+import * as $protobuf from "protobufjs";
+/** Properties of an AppActionMetadata. */
+export interface IAppActionMetadata {
+
+    /** AppActionMetadata videoId */
+    videoId?: (string|null);
+}
+
+/** Represents an AppActionMetadata. */
+export class AppActionMetadata implements IAppActionMetadata {
+
+    /**
+     * Constructs a new AppActionMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IAppActionMetadata);
+
+    /** AppActionMetadata videoId. */
+    public videoId: string;
+
+    /**
+     * Creates a new AppActionMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns AppActionMetadata instance
+     */
+    public static create(properties?: IAppActionMetadata): AppActionMetadata;
+
+    /**
+     * Encodes the specified AppActionMetadata message. Does not implicitly {@link AppActionMetadata.verify|verify} messages.
+     * @param message AppActionMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IAppActionMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified AppActionMetadata message, length delimited. Does not implicitly {@link AppActionMetadata.verify|verify} messages.
+     * @param message AppActionMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IAppActionMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an AppActionMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns AppActionMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppActionMetadata;
+
+    /**
+     * Decodes an AppActionMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns AppActionMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppActionMetadata;
+
+    /**
+     * Verifies an AppActionMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an AppActionMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns AppActionMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): AppActionMetadata;
+
+    /**
+     * Creates a plain object from an AppActionMetadata message. Also converts values to other types if specified.
+     * @param message AppActionMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: AppActionMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this AppActionMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an AppAction. */
+export interface IAppAction {
+
+    /** AppAction appId */
+    appId: string;
+
+    /** AppAction metadata */
+    metadata?: (Uint8Array|null);
+
+    /** AppAction rawAction */
+    rawAction?: (Uint8Array|null);
+
+    /** AppAction signature */
+    signature?: (Uint8Array|null);
+}
+
+/** Represents an AppAction. */
+export class AppAction implements IAppAction {
+
+    /**
+     * Constructs a new AppAction.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IAppAction);
+
+    /** AppAction appId. */
+    public appId: string;
+
+    /** AppAction metadata. */
+    public metadata: Uint8Array;
+
+    /** AppAction rawAction. */
+    public rawAction: Uint8Array;
+
+    /** AppAction signature. */
+    public signature: Uint8Array;
+
+    /**
+     * Creates a new AppAction instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns AppAction instance
+     */
+    public static create(properties?: IAppAction): AppAction;
+
+    /**
+     * Encodes the specified AppAction message. Does not implicitly {@link AppAction.verify|verify} messages.
+     * @param message AppAction message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IAppAction, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified AppAction message, length delimited. Does not implicitly {@link AppAction.verify|verify} messages.
+     * @param message AppAction message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IAppAction, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an AppAction message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns AppAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppAction;
+
+    /**
+     * Decodes an AppAction message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns AppAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppAction;
+
+    /**
+     * Verifies an AppAction message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an AppAction message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns AppAction
+     */
+    public static fromObject(object: { [k: string]: any }): AppAction;
+
+    /**
+     * Creates a plain object from an AppAction message. Also converts values to other types if specified.
+     * @param message AppAction
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: AppAction, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this AppAction to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace AppAction {
+
+    /** ActionType enum. */
+    enum ActionType {
+        CREATE_VIDEO = 0,
+        CREATE_CHANNEL = 1
+    }
+
+    /** CreatorType enum. */
+    enum CreatorType {
+        CHANNEL = 0,
+        MEMBER = 1,
+        CURATOR_GROUP = 2
+    }
+}
+
+/** Properties of a BountyMetadata. */
+export interface IBountyMetadata {
+
+    /** BountyMetadata title */
+    title?: (string|null);
+
+    /** BountyMetadata description */
+    description?: (string|null);
+
+    /** BountyMetadata discussionThread */
+    discussionThread?: (Long|null);
+
+    /** BountyMetadata bannerImageUri */
+    bannerImageUri?: (string|null);
+}
+
+/** Represents a BountyMetadata. */
+export class BountyMetadata implements IBountyMetadata {
+
+    /**
+     * Constructs a new BountyMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IBountyMetadata);
+
+    /** BountyMetadata title. */
+    public title: string;
+
+    /** BountyMetadata description. */
+    public description: string;
+
+    /** BountyMetadata discussionThread. */
+    public discussionThread: Long;
+
+    /** BountyMetadata bannerImageUri. */
+    public bannerImageUri: string;
+
+    /**
+     * Creates a new BountyMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns BountyMetadata instance
+     */
+    public static create(properties?: IBountyMetadata): BountyMetadata;
+
+    /**
+     * Encodes the specified BountyMetadata message. Does not implicitly {@link BountyMetadata.verify|verify} messages.
+     * @param message BountyMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IBountyMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified BountyMetadata message, length delimited. Does not implicitly {@link BountyMetadata.verify|verify} messages.
+     * @param message BountyMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IBountyMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a BountyMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns BountyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): BountyMetadata;
+
+    /**
+     * Decodes a BountyMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns BountyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): BountyMetadata;
+
+    /**
+     * Verifies a BountyMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a BountyMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns BountyMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): BountyMetadata;
+
+    /**
+     * Creates a plain object from a BountyMetadata message. Also converts values to other types if specified.
+     * @param message BountyMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: BountyMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this BountyMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a BountyWorkData. */
+export interface IBountyWorkData {
+
+    /** BountyWorkData title */
+    title?: (string|null);
+
+    /** BountyWorkData description */
+    description?: (string|null);
+}
+
+/** Represents a BountyWorkData. */
+export class BountyWorkData implements IBountyWorkData {
+
+    /**
+     * Constructs a new BountyWorkData.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IBountyWorkData);
+
+    /** BountyWorkData title. */
+    public title: string;
+
+    /** BountyWorkData description. */
+    public description: string;
+
+    /**
+     * Creates a new BountyWorkData instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns BountyWorkData instance
+     */
+    public static create(properties?: IBountyWorkData): BountyWorkData;
+
+    /**
+     * Encodes the specified BountyWorkData message. Does not implicitly {@link BountyWorkData.verify|verify} messages.
+     * @param message BountyWorkData message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IBountyWorkData, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified BountyWorkData message, length delimited. Does not implicitly {@link BountyWorkData.verify|verify} messages.
+     * @param message BountyWorkData message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IBountyWorkData, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a BountyWorkData message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns BountyWorkData
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): BountyWorkData;
+
+    /**
+     * Decodes a BountyWorkData message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns BountyWorkData
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): BountyWorkData;
+
+    /**
+     * Verifies a BountyWorkData message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a BountyWorkData message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns BountyWorkData
+     */
+    public static fromObject(object: { [k: string]: any }): BountyWorkData;
+
+    /**
+     * Creates a plain object from a BountyWorkData message. Also converts values to other types if specified.
+     * @param message BountyWorkData
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: BountyWorkData, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this BountyWorkData to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ChannelMetadata. */
+export interface IChannelMetadata {
+
+    /** ChannelMetadata title */
+    title?: (string|null);
+
+    /** ChannelMetadata description */
+    description?: (string|null);
+
+    /** ChannelMetadata isPublic */
+    isPublic?: (boolean|null);
+
+    /** ChannelMetadata language */
+    language?: (string|null);
+
+    /** ChannelMetadata coverPhoto */
+    coverPhoto?: (number|null);
+
+    /** ChannelMetadata avatarPhoto */
+    avatarPhoto?: (number|null);
+}
+
+/** Represents a ChannelMetadata. */
+export class ChannelMetadata implements IChannelMetadata {
+
+    /**
+     * Constructs a new ChannelMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IChannelMetadata);
+
+    /** ChannelMetadata title. */
+    public title: string;
+
+    /** ChannelMetadata description. */
+    public description: string;
+
+    /** ChannelMetadata isPublic. */
+    public isPublic: boolean;
+
+    /** ChannelMetadata language. */
+    public language: string;
+
+    /** ChannelMetadata coverPhoto. */
+    public coverPhoto: number;
+
+    /** ChannelMetadata avatarPhoto. */
+    public avatarPhoto: number;
+
+    /**
+     * Creates a new ChannelMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ChannelMetadata instance
+     */
+    public static create(properties?: IChannelMetadata): ChannelMetadata;
+
+    /**
+     * Encodes the specified ChannelMetadata message. Does not implicitly {@link ChannelMetadata.verify|verify} messages.
+     * @param message ChannelMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IChannelMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ChannelMetadata message, length delimited. Does not implicitly {@link ChannelMetadata.verify|verify} messages.
+     * @param message ChannelMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IChannelMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ChannelMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ChannelMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelMetadata;
+
+    /**
+     * Decodes a ChannelMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ChannelMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelMetadata;
+
+    /**
+     * Verifies a ChannelMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ChannelMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ChannelMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): ChannelMetadata;
+
+    /**
+     * Creates a plain object from a ChannelMetadata message. Also converts values to other types if specified.
+     * @param message ChannelMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ChannelMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ChannelMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ChannelPayoutsMetadata. */
+export interface IChannelPayoutsMetadata {
+
+    /** ChannelPayoutsMetadata header */
+    header: ChannelPayoutsMetadata.IHeader;
+
+    /** ChannelPayoutsMetadata body */
+    body: ChannelPayoutsMetadata.IBody;
+}
+
+/** Represents a ChannelPayoutsMetadata. */
+export class ChannelPayoutsMetadata implements IChannelPayoutsMetadata {
+
+    /**
+     * Constructs a new ChannelPayoutsMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IChannelPayoutsMetadata);
+
+    /** ChannelPayoutsMetadata header. */
+    public header: ChannelPayoutsMetadata.IHeader;
+
+    /** ChannelPayoutsMetadata body. */
+    public body: ChannelPayoutsMetadata.IBody;
+
+    /**
+     * Creates a new ChannelPayoutsMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ChannelPayoutsMetadata instance
+     */
+    public static create(properties?: IChannelPayoutsMetadata): ChannelPayoutsMetadata;
+
+    /**
+     * Encodes the specified ChannelPayoutsMetadata message. Does not implicitly {@link ChannelPayoutsMetadata.verify|verify} messages.
+     * @param message ChannelPayoutsMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IChannelPayoutsMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ChannelPayoutsMetadata message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.verify|verify} messages.
+     * @param message ChannelPayoutsMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IChannelPayoutsMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ChannelPayoutsMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ChannelPayoutsMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelPayoutsMetadata;
+
+    /**
+     * Decodes a ChannelPayoutsMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ChannelPayoutsMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelPayoutsMetadata;
+
+    /**
+     * Verifies a ChannelPayoutsMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ChannelPayoutsMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ChannelPayoutsMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): ChannelPayoutsMetadata;
+
+    /**
+     * Creates a plain object from a ChannelPayoutsMetadata message. Also converts values to other types if specified.
+     * @param message ChannelPayoutsMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ChannelPayoutsMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ChannelPayoutsMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace ChannelPayoutsMetadata {
+
+    /** Properties of a Header. */
+    interface IHeader {
+
+        /** Header payloadLengthInBytes */
+        payloadLengthInBytes: Long;
+
+        /** Header headerLengthInBytes */
+        headerLengthInBytes: Long;
+
+        /** Header numberOfChannels */
+        numberOfChannels: number;
+
+        /** Header channelPayoutByteOffsets */
+        channelPayoutByteOffsets?: (ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset[]|null);
+    }
+
+    /**
+     * Fields in the payload header are encoded in fixed length 32/64 bits instead of [varint encoding](https://developers.google.com/protocol-buffers/docs/encoding#varints) (uint64/32).
+     * This allows first calculating, and then setting the byte offset of each `ChannelPayoutProof` accurately, e.g.
+     * `byte_offset` = `size(Header)` + `position_where_record_for_channel_exists_in_Body`
+     * If varint encoding is used for header fields, then calculating the byte offset of `ChannelPayoutProof`
+     * w.r.t the start of the payload would be improbable since the header size won't be known.
+     */
+    class Header implements IHeader {
+
+        /**
+         * Constructs a new Header.
+         * @param [properties] Properties to set
+         */
+        constructor(properties?: ChannelPayoutsMetadata.IHeader);
+
+        /** Header payloadLengthInBytes. */
+        public payloadLengthInBytes: Long;
+
+        /** Header headerLengthInBytes. */
+        public headerLengthInBytes: Long;
+
+        /** Header numberOfChannels. */
+        public numberOfChannels: number;
+
+        /** Header channelPayoutByteOffsets. */
+        public channelPayoutByteOffsets: ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset[];
+
+        /**
+         * Creates a new Header instance using the specified properties.
+         * @param [properties] Properties to set
+         * @returns Header instance
+         */
+        public static create(properties?: ChannelPayoutsMetadata.IHeader): ChannelPayoutsMetadata.Header;
+
+        /**
+         * Encodes the specified Header message. Does not implicitly {@link ChannelPayoutsMetadata.Header.verify|verify} messages.
+         * @param message Header message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encode(message: ChannelPayoutsMetadata.IHeader, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Encodes the specified Header message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Header.verify|verify} messages.
+         * @param message Header message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encodeDelimited(message: ChannelPayoutsMetadata.IHeader, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Decodes a Header message from the specified reader or buffer.
+         * @param reader Reader or buffer to decode from
+         * @param [length] Message length if known beforehand
+         * @returns Header
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelPayoutsMetadata.Header;
+
+        /**
+         * Decodes a Header message from the specified reader or buffer, length delimited.
+         * @param reader Reader or buffer to decode from
+         * @returns Header
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelPayoutsMetadata.Header;
+
+        /**
+         * Verifies a Header message.
+         * @param message Plain object to verify
+         * @returns `null` if valid, otherwise the reason why it is not
+         */
+        public static verify(message: { [k: string]: any }): (string|null);
+
+        /**
+         * Creates a Header message from a plain object. Also converts values to their respective internal types.
+         * @param object Plain object
+         * @returns Header
+         */
+        public static fromObject(object: { [k: string]: any }): ChannelPayoutsMetadata.Header;
+
+        /**
+         * Creates a plain object from a Header message. Also converts values to other types if specified.
+         * @param message Header
+         * @param [options] Conversion options
+         * @returns Plain object
+         */
+        public static toObject(message: ChannelPayoutsMetadata.Header, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+        /**
+         * Converts this Header to JSON.
+         * @returns JSON object
+         */
+        public toJSON(): { [k: string]: any };
+    }
+
+    namespace Header {
+
+        /** Properties of a ChannelPayoutByteOffset. */
+        interface IChannelPayoutByteOffset {
+
+            /** ChannelPayoutByteOffset channelId */
+            channelId: number;
+
+            /** ChannelPayoutByteOffset byteOffset */
+            byteOffset: Long;
+        }
+
+        /** Represents a ChannelPayoutByteOffset. */
+        class ChannelPayoutByteOffset implements IChannelPayoutByteOffset {
+
+            /**
+             * Constructs a new ChannelPayoutByteOffset.
+             * @param [properties] Properties to set
+             */
+            constructor(properties?: ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset);
+
+            /** ChannelPayoutByteOffset channelId. */
+            public channelId: number;
+
+            /** ChannelPayoutByteOffset byteOffset. */
+            public byteOffset: Long;
+
+            /**
+             * Creates a new ChannelPayoutByteOffset instance using the specified properties.
+             * @param [properties] Properties to set
+             * @returns ChannelPayoutByteOffset instance
+             */
+            public static create(properties?: ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset): ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset;
+
+            /**
+             * Encodes the specified ChannelPayoutByteOffset message. Does not implicitly {@link ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.verify|verify} messages.
+             * @param message ChannelPayoutByteOffset message or plain object to encode
+             * @param [writer] Writer to encode to
+             * @returns Writer
+             */
+            public static encode(message: ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset, writer?: $protobuf.Writer): $protobuf.Writer;
+
+            /**
+             * Encodes the specified ChannelPayoutByteOffset message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.verify|verify} messages.
+             * @param message ChannelPayoutByteOffset message or plain object to encode
+             * @param [writer] Writer to encode to
+             * @returns Writer
+             */
+            public static encodeDelimited(message: ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset, writer?: $protobuf.Writer): $protobuf.Writer;
+
+            /**
+             * Decodes a ChannelPayoutByteOffset message from the specified reader or buffer.
+             * @param reader Reader or buffer to decode from
+             * @param [length] Message length if known beforehand
+             * @returns ChannelPayoutByteOffset
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset;
+
+            /**
+             * Decodes a ChannelPayoutByteOffset message from the specified reader or buffer, length delimited.
+             * @param reader Reader or buffer to decode from
+             * @returns ChannelPayoutByteOffset
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset;
+
+            /**
+             * Verifies a ChannelPayoutByteOffset message.
+             * @param message Plain object to verify
+             * @returns `null` if valid, otherwise the reason why it is not
+             */
+            public static verify(message: { [k: string]: any }): (string|null);
+
+            /**
+             * Creates a ChannelPayoutByteOffset message from a plain object. Also converts values to their respective internal types.
+             * @param object Plain object
+             * @returns ChannelPayoutByteOffset
+             */
+            public static fromObject(object: { [k: string]: any }): ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset;
+
+            /**
+             * Creates a plain object from a ChannelPayoutByteOffset message. Also converts values to other types if specified.
+             * @param message ChannelPayoutByteOffset
+             * @param [options] Conversion options
+             * @returns Plain object
+             */
+            public static toObject(message: ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+            /**
+             * Converts this ChannelPayoutByteOffset to JSON.
+             * @returns JSON object
+             */
+            public toJSON(): { [k: string]: any };
+        }
+    }
+
+    /** Properties of a Body. */
+    interface IBody {
+
+        /** Body channelPayouts */
+        channelPayouts?: (ChannelPayoutsMetadata.Body.IChannelPayoutProof[]|null);
+    }
+
+    /** Represents a Body. */
+    class Body implements IBody {
+
+        /**
+         * Constructs a new Body.
+         * @param [properties] Properties to set
+         */
+        constructor(properties?: ChannelPayoutsMetadata.IBody);
+
+        /** Body channelPayouts. */
+        public channelPayouts: ChannelPayoutsMetadata.Body.IChannelPayoutProof[];
+
+        /**
+         * Creates a new Body instance using the specified properties.
+         * @param [properties] Properties to set
+         * @returns Body instance
+         */
+        public static create(properties?: ChannelPayoutsMetadata.IBody): ChannelPayoutsMetadata.Body;
+
+        /**
+         * Encodes the specified Body message. Does not implicitly {@link ChannelPayoutsMetadata.Body.verify|verify} messages.
+         * @param message Body message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encode(message: ChannelPayoutsMetadata.IBody, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Encodes the specified Body message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Body.verify|verify} messages.
+         * @param message Body message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encodeDelimited(message: ChannelPayoutsMetadata.IBody, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Decodes a Body message from the specified reader or buffer.
+         * @param reader Reader or buffer to decode from
+         * @param [length] Message length if known beforehand
+         * @returns Body
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelPayoutsMetadata.Body;
+
+        /**
+         * Decodes a Body message from the specified reader or buffer, length delimited.
+         * @param reader Reader or buffer to decode from
+         * @returns Body
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelPayoutsMetadata.Body;
+
+        /**
+         * Verifies a Body message.
+         * @param message Plain object to verify
+         * @returns `null` if valid, otherwise the reason why it is not
+         */
+        public static verify(message: { [k: string]: any }): (string|null);
+
+        /**
+         * Creates a Body message from a plain object. Also converts values to their respective internal types.
+         * @param object Plain object
+         * @returns Body
+         */
+        public static fromObject(object: { [k: string]: any }): ChannelPayoutsMetadata.Body;
+
+        /**
+         * Creates a plain object from a Body message. Also converts values to other types if specified.
+         * @param message Body
+         * @param [options] Conversion options
+         * @returns Plain object
+         */
+        public static toObject(message: ChannelPayoutsMetadata.Body, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+        /**
+         * Converts this Body to JSON.
+         * @returns JSON object
+         */
+        public toJSON(): { [k: string]: any };
+    }
+
+    namespace Body {
+
+        /** Properties of a ChannelPayoutProof. */
+        interface IChannelPayoutProof {
+
+            /** ChannelPayoutProof channelId */
+            channelId: number;
+
+            /** ChannelPayoutProof cumulativeRewardEarned */
+            cumulativeRewardEarned: string;
+
+            /** ChannelPayoutProof merkleBranch */
+            merkleBranch?: (ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement[]|null);
+
+            /** ChannelPayoutProof reason */
+            reason: string;
+        }
+
+        /** Represents a ChannelPayoutProof. */
+        class ChannelPayoutProof implements IChannelPayoutProof {
+
+            /**
+             * Constructs a new ChannelPayoutProof.
+             * @param [properties] Properties to set
+             */
+            constructor(properties?: ChannelPayoutsMetadata.Body.IChannelPayoutProof);
+
+            /** ChannelPayoutProof channelId. */
+            public channelId: number;
+
+            /** ChannelPayoutProof cumulativeRewardEarned. */
+            public cumulativeRewardEarned: string;
+
+            /** ChannelPayoutProof merkleBranch. */
+            public merkleBranch: ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement[];
+
+            /** ChannelPayoutProof reason. */
+            public reason: string;
+
+            /**
+             * Creates a new ChannelPayoutProof instance using the specified properties.
+             * @param [properties] Properties to set
+             * @returns ChannelPayoutProof instance
+             */
+            public static create(properties?: ChannelPayoutsMetadata.Body.IChannelPayoutProof): ChannelPayoutsMetadata.Body.ChannelPayoutProof;
+
+            /**
+             * Encodes the specified ChannelPayoutProof message. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.verify|verify} messages.
+             * @param message ChannelPayoutProof message or plain object to encode
+             * @param [writer] Writer to encode to
+             * @returns Writer
+             */
+            public static encode(message: ChannelPayoutsMetadata.Body.IChannelPayoutProof, writer?: $protobuf.Writer): $protobuf.Writer;
+
+            /**
+             * Encodes the specified ChannelPayoutProof message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.verify|verify} messages.
+             * @param message ChannelPayoutProof message or plain object to encode
+             * @param [writer] Writer to encode to
+             * @returns Writer
+             */
+            public static encodeDelimited(message: ChannelPayoutsMetadata.Body.IChannelPayoutProof, writer?: $protobuf.Writer): $protobuf.Writer;
+
+            /**
+             * Decodes a ChannelPayoutProof message from the specified reader or buffer.
+             * @param reader Reader or buffer to decode from
+             * @param [length] Message length if known beforehand
+             * @returns ChannelPayoutProof
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelPayoutsMetadata.Body.ChannelPayoutProof;
+
+            /**
+             * Decodes a ChannelPayoutProof message from the specified reader or buffer, length delimited.
+             * @param reader Reader or buffer to decode from
+             * @returns ChannelPayoutProof
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelPayoutsMetadata.Body.ChannelPayoutProof;
+
+            /**
+             * Verifies a ChannelPayoutProof message.
+             * @param message Plain object to verify
+             * @returns `null` if valid, otherwise the reason why it is not
+             */
+            public static verify(message: { [k: string]: any }): (string|null);
+
+            /**
+             * Creates a ChannelPayoutProof message from a plain object. Also converts values to their respective internal types.
+             * @param object Plain object
+             * @returns ChannelPayoutProof
+             */
+            public static fromObject(object: { [k: string]: any }): ChannelPayoutsMetadata.Body.ChannelPayoutProof;
+
+            /**
+             * Creates a plain object from a ChannelPayoutProof message. Also converts values to other types if specified.
+             * @param message ChannelPayoutProof
+             * @param [options] Conversion options
+             * @returns Plain object
+             */
+            public static toObject(message: ChannelPayoutsMetadata.Body.ChannelPayoutProof, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+            /**
+             * Converts this ChannelPayoutProof to JSON.
+             * @returns JSON object
+             */
+            public toJSON(): { [k: string]: any };
+        }
+
+        namespace ChannelPayoutProof {
+
+            /** Side enum. */
+            enum Side {
+                Left = 0,
+                Right = 1
+            }
+
+            /** Properties of a ProofElement. */
+            interface IProofElement {
+
+                /** ProofElement hash */
+                hash: string;
+
+                /** ProofElement side */
+                side: ChannelPayoutsMetadata.Body.ChannelPayoutProof.Side;
+            }
+
+            /** Represents a ProofElement. */
+            class ProofElement implements IProofElement {
+
+                /**
+                 * Constructs a new ProofElement.
+                 * @param [properties] Properties to set
+                 */
+                constructor(properties?: ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement);
+
+                /** ProofElement hash. */
+                public hash: string;
+
+                /** ProofElement side. */
+                public side: ChannelPayoutsMetadata.Body.ChannelPayoutProof.Side;
+
+                /**
+                 * Creates a new ProofElement instance using the specified properties.
+                 * @param [properties] Properties to set
+                 * @returns ProofElement instance
+                 */
+                public static create(properties?: ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement): ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement;
+
+                /**
+                 * Encodes the specified ProofElement message. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.verify|verify} messages.
+                 * @param message ProofElement message or plain object to encode
+                 * @param [writer] Writer to encode to
+                 * @returns Writer
+                 */
+                public static encode(message: ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement, writer?: $protobuf.Writer): $protobuf.Writer;
+
+                /**
+                 * Encodes the specified ProofElement message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.verify|verify} messages.
+                 * @param message ProofElement message or plain object to encode
+                 * @param [writer] Writer to encode to
+                 * @returns Writer
+                 */
+                public static encodeDelimited(message: ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement, writer?: $protobuf.Writer): $protobuf.Writer;
+
+                /**
+                 * Decodes a ProofElement message from the specified reader or buffer.
+                 * @param reader Reader or buffer to decode from
+                 * @param [length] Message length if known beforehand
+                 * @returns ProofElement
+                 * @throws {Error} If the payload is not a reader or valid buffer
+                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
+                 */
+                public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement;
+
+                /**
+                 * Decodes a ProofElement message from the specified reader or buffer, length delimited.
+                 * @param reader Reader or buffer to decode from
+                 * @returns ProofElement
+                 * @throws {Error} If the payload is not a reader or valid buffer
+                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
+                 */
+                public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement;
+
+                /**
+                 * Verifies a ProofElement message.
+                 * @param message Plain object to verify
+                 * @returns `null` if valid, otherwise the reason why it is not
+                 */
+                public static verify(message: { [k: string]: any }): (string|null);
+
+                /**
+                 * Creates a ProofElement message from a plain object. Also converts values to their respective internal types.
+                 * @param object Plain object
+                 * @returns ProofElement
+                 */
+                public static fromObject(object: { [k: string]: any }): ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement;
+
+                /**
+                 * Creates a plain object from a ProofElement message. Also converts values to other types if specified.
+                 * @param message ProofElement
+                 * @param [options] Conversion options
+                 * @returns Plain object
+                 */
+                public static toObject(message: ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+                /**
+                 * Converts this ProofElement to JSON.
+                 * @returns JSON object
+                 */
+                public toJSON(): { [k: string]: any };
+            }
+        }
+    }
+}
+
+/** Properties of a CouncilCandidacyNoteMetadata. */
+export interface ICouncilCandidacyNoteMetadata {
+
+    /** CouncilCandidacyNoteMetadata header */
+    header?: (string|null);
+
+    /** CouncilCandidacyNoteMetadata bulletPoints */
+    bulletPoints?: (string[]|null);
+
+    /** CouncilCandidacyNoteMetadata bannerImageUri */
+    bannerImageUri?: (string|null);
+
+    /** CouncilCandidacyNoteMetadata description */
+    description?: (string|null);
+}
+
+/** Represents a CouncilCandidacyNoteMetadata. */
+export class CouncilCandidacyNoteMetadata implements ICouncilCandidacyNoteMetadata {
+
+    /**
+     * Constructs a new CouncilCandidacyNoteMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ICouncilCandidacyNoteMetadata);
+
+    /** CouncilCandidacyNoteMetadata header. */
+    public header: string;
+
+    /** CouncilCandidacyNoteMetadata bulletPoints. */
+    public bulletPoints: string[];
+
+    /** CouncilCandidacyNoteMetadata bannerImageUri. */
+    public bannerImageUri: string;
+
+    /** CouncilCandidacyNoteMetadata description. */
+    public description: string;
+
+    /**
+     * Creates a new CouncilCandidacyNoteMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns CouncilCandidacyNoteMetadata instance
+     */
+    public static create(properties?: ICouncilCandidacyNoteMetadata): CouncilCandidacyNoteMetadata;
+
+    /**
+     * Encodes the specified CouncilCandidacyNoteMetadata message. Does not implicitly {@link CouncilCandidacyNoteMetadata.verify|verify} messages.
+     * @param message CouncilCandidacyNoteMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ICouncilCandidacyNoteMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified CouncilCandidacyNoteMetadata message, length delimited. Does not implicitly {@link CouncilCandidacyNoteMetadata.verify|verify} messages.
+     * @param message CouncilCandidacyNoteMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ICouncilCandidacyNoteMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a CouncilCandidacyNoteMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns CouncilCandidacyNoteMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): CouncilCandidacyNoteMetadata;
+
+    /**
+     * Decodes a CouncilCandidacyNoteMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns CouncilCandidacyNoteMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): CouncilCandidacyNoteMetadata;
+
+    /**
+     * Verifies a CouncilCandidacyNoteMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a CouncilCandidacyNoteMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns CouncilCandidacyNoteMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): CouncilCandidacyNoteMetadata;
+
+    /**
+     * Creates a plain object from a CouncilCandidacyNoteMetadata message. Also converts values to other types if specified.
+     * @param message CouncilCandidacyNoteMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: CouncilCandidacyNoteMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this CouncilCandidacyNoteMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ForumPostMetadata. */
+export interface IForumPostMetadata {
+
+    /** ForumPostMetadata text */
+    text?: (string|null);
+
+    /** ForumPostMetadata repliesTo */
+    repliesTo?: (number|null);
+}
+
+/** Represents a ForumPostMetadata. */
+export class ForumPostMetadata implements IForumPostMetadata {
+
+    /**
+     * Constructs a new ForumPostMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IForumPostMetadata);
+
+    /** ForumPostMetadata text. */
+    public text: string;
+
+    /** ForumPostMetadata repliesTo. */
+    public repliesTo: number;
+
+    /**
+     * Creates a new ForumPostMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ForumPostMetadata instance
+     */
+    public static create(properties?: IForumPostMetadata): ForumPostMetadata;
+
+    /**
+     * Encodes the specified ForumPostMetadata message. Does not implicitly {@link ForumPostMetadata.verify|verify} messages.
+     * @param message ForumPostMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IForumPostMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ForumPostMetadata message, length delimited. Does not implicitly {@link ForumPostMetadata.verify|verify} messages.
+     * @param message ForumPostMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IForumPostMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ForumPostMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ForumPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ForumPostMetadata;
+
+    /**
+     * Decodes a ForumPostMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ForumPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ForumPostMetadata;
+
+    /**
+     * Verifies a ForumPostMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ForumPostMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ForumPostMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): ForumPostMetadata;
+
+    /**
+     * Creates a plain object from a ForumPostMetadata message. Also converts values to other types if specified.
+     * @param message ForumPostMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ForumPostMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ForumPostMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ForumThreadMetadata. */
+export interface IForumThreadMetadata {
+
+    /** ForumThreadMetadata title */
+    title?: (string|null);
+
+    /** ForumThreadMetadata tags */
+    tags?: (string[]|null);
+}
+
+/** Represents a ForumThreadMetadata. */
+export class ForumThreadMetadata implements IForumThreadMetadata {
+
+    /**
+     * Constructs a new ForumThreadMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IForumThreadMetadata);
+
+    /** ForumThreadMetadata title. */
+    public title: string;
+
+    /** ForumThreadMetadata tags. */
+    public tags: string[];
+
+    /**
+     * Creates a new ForumThreadMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ForumThreadMetadata instance
+     */
+    public static create(properties?: IForumThreadMetadata): ForumThreadMetadata;
+
+    /**
+     * Encodes the specified ForumThreadMetadata message. Does not implicitly {@link ForumThreadMetadata.verify|verify} messages.
+     * @param message ForumThreadMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IForumThreadMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ForumThreadMetadata message, length delimited. Does not implicitly {@link ForumThreadMetadata.verify|verify} messages.
+     * @param message ForumThreadMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IForumThreadMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ForumThreadMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ForumThreadMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ForumThreadMetadata;
+
+    /**
+     * Decodes a ForumThreadMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ForumThreadMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ForumThreadMetadata;
+
+    /**
+     * Verifies a ForumThreadMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ForumThreadMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ForumThreadMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): ForumThreadMetadata;
+
+    /**
+     * Creates a plain object from a ForumThreadMetadata message. Also converts values to other types if specified.
+     * @param message ForumThreadMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ForumThreadMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ForumThreadMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a MembershipMetadata. */
+export interface IMembershipMetadata {
+
+    /** MembershipMetadata name */
+    name?: (string|null);
+
+    /** MembershipMetadata avatarObject */
+    avatarObject?: (number|null);
+
+    /** MembershipMetadata avatarUri */
+    avatarUri?: (string|null);
+
+    /** MembershipMetadata about */
+    about?: (string|null);
+
+    /** MembershipMetadata externalResources */
+    externalResources?: (MembershipMetadata.IExternalResource[]|null);
+}
+
+/** Represents a MembershipMetadata. */
+export class MembershipMetadata implements IMembershipMetadata {
+
+    /**
+     * Constructs a new MembershipMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IMembershipMetadata);
+
+    /** MembershipMetadata name. */
+    public name: string;
+
+    /** MembershipMetadata avatarObject. */
+    public avatarObject?: (number|null);
+
+    /** MembershipMetadata avatarUri. */
+    public avatarUri?: (string|null);
+
+    /** MembershipMetadata about. */
+    public about: string;
+
+    /** MembershipMetadata externalResources. */
+    public externalResources: MembershipMetadata.IExternalResource[];
+
+    /** MembershipMetadata avatar. */
+    public avatar?: ("avatarObject"|"avatarUri");
+
+    /**
+     * Creates a new MembershipMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns MembershipMetadata instance
+     */
+    public static create(properties?: IMembershipMetadata): MembershipMetadata;
+
+    /**
+     * Encodes the specified MembershipMetadata message. Does not implicitly {@link MembershipMetadata.verify|verify} messages.
+     * @param message MembershipMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IMembershipMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified MembershipMetadata message, length delimited. Does not implicitly {@link MembershipMetadata.verify|verify} messages.
+     * @param message MembershipMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IMembershipMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a MembershipMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns MembershipMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MembershipMetadata;
+
+    /**
+     * Decodes a MembershipMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns MembershipMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MembershipMetadata;
+
+    /**
+     * Verifies a MembershipMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a MembershipMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns MembershipMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): MembershipMetadata;
+
+    /**
+     * Creates a plain object from a MembershipMetadata message. Also converts values to other types if specified.
+     * @param message MembershipMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: MembershipMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this MembershipMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace MembershipMetadata {
+
+    /** Properties of an ExternalResource. */
+    interface IExternalResource {
+
+        /** ExternalResource type */
+        type?: (MembershipMetadata.ExternalResource.ResourceType|null);
+
+        /** ExternalResource value */
+        value?: (string|null);
+    }
+
+    /** Represents an ExternalResource. */
+    class ExternalResource implements IExternalResource {
+
+        /**
+         * Constructs a new ExternalResource.
+         * @param [properties] Properties to set
+         */
+        constructor(properties?: MembershipMetadata.IExternalResource);
+
+        /** ExternalResource type. */
+        public type: MembershipMetadata.ExternalResource.ResourceType;
+
+        /** ExternalResource value. */
+        public value: string;
+
+        /**
+         * Creates a new ExternalResource instance using the specified properties.
+         * @param [properties] Properties to set
+         * @returns ExternalResource instance
+         */
+        public static create(properties?: MembershipMetadata.IExternalResource): MembershipMetadata.ExternalResource;
+
+        /**
+         * Encodes the specified ExternalResource message. Does not implicitly {@link MembershipMetadata.ExternalResource.verify|verify} messages.
+         * @param message ExternalResource message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encode(message: MembershipMetadata.IExternalResource, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Encodes the specified ExternalResource message, length delimited. Does not implicitly {@link MembershipMetadata.ExternalResource.verify|verify} messages.
+         * @param message ExternalResource message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encodeDelimited(message: MembershipMetadata.IExternalResource, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Decodes an ExternalResource message from the specified reader or buffer.
+         * @param reader Reader or buffer to decode from
+         * @param [length] Message length if known beforehand
+         * @returns ExternalResource
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MembershipMetadata.ExternalResource;
+
+        /**
+         * Decodes an ExternalResource message from the specified reader or buffer, length delimited.
+         * @param reader Reader or buffer to decode from
+         * @returns ExternalResource
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MembershipMetadata.ExternalResource;
+
+        /**
+         * Verifies an ExternalResource message.
+         * @param message Plain object to verify
+         * @returns `null` if valid, otherwise the reason why it is not
+         */
+        public static verify(message: { [k: string]: any }): (string|null);
+
+        /**
+         * Creates an ExternalResource message from a plain object. Also converts values to their respective internal types.
+         * @param object Plain object
+         * @returns ExternalResource
+         */
+        public static fromObject(object: { [k: string]: any }): MembershipMetadata.ExternalResource;
+
+        /**
+         * Creates a plain object from an ExternalResource message. Also converts values to other types if specified.
+         * @param message ExternalResource
+         * @param [options] Conversion options
+         * @returns Plain object
+         */
+        public static toObject(message: MembershipMetadata.ExternalResource, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+        /**
+         * Converts this ExternalResource to JSON.
+         * @returns JSON object
+         */
+        public toJSON(): { [k: string]: any };
+    }
+
+    namespace ExternalResource {
+
+        /** ResourceType enum. */
+        enum ResourceType {
+            EMAIL = 0,
+            HYPERLINK = 1,
+            TWITTER = 2,
+            TELEGRAM = 3,
+            DISCORD = 4,
+            FACEBOOK = 5,
+            YOUTUBE = 6,
+            MATRIX = 7,
+            IRC = 8,
+            WECHAT = 9,
+            WHATSAPP = 10
+        }
+    }
+}
+
+/** Properties of a ReactVideo. */
+export interface IReactVideo {
+
+    /** ReactVideo videoId */
+    videoId: Long;
+
+    /** ReactVideo reaction */
+    reaction: ReactVideo.Reaction;
+}
+
+/** Represents a ReactVideo. */
+export class ReactVideo implements IReactVideo {
+
+    /**
+     * Constructs a new ReactVideo.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IReactVideo);
+
+    /** ReactVideo videoId. */
+    public videoId: Long;
+
+    /** ReactVideo reaction. */
+    public reaction: ReactVideo.Reaction;
+
+    /**
+     * Creates a new ReactVideo instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ReactVideo instance
+     */
+    public static create(properties?: IReactVideo): ReactVideo;
+
+    /**
+     * Encodes the specified ReactVideo message. Does not implicitly {@link ReactVideo.verify|verify} messages.
+     * @param message ReactVideo message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IReactVideo, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ReactVideo message, length delimited. Does not implicitly {@link ReactVideo.verify|verify} messages.
+     * @param message ReactVideo message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IReactVideo, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ReactVideo message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ReactVideo
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ReactVideo;
+
+    /**
+     * Decodes a ReactVideo message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ReactVideo
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ReactVideo;
+
+    /**
+     * Verifies a ReactVideo message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ReactVideo message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ReactVideo
+     */
+    public static fromObject(object: { [k: string]: any }): ReactVideo;
+
+    /**
+     * Creates a plain object from a ReactVideo message. Also converts values to other types if specified.
+     * @param message ReactVideo
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ReactVideo, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ReactVideo to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace ReactVideo {
+
+    /** Reaction enum. */
+    enum Reaction {
+        LIKE = 0,
+        UNLIKE = 1
+    }
+}
+
+/** Properties of a ReactComment. */
+export interface IReactComment {
+
+    /** ReactComment commentId */
+    commentId: string;
+
+    /** ReactComment reactionId */
+    reactionId: number;
+}
+
+/** Represents a ReactComment. */
+export class ReactComment implements IReactComment {
+
+    /**
+     * Constructs a new ReactComment.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IReactComment);
+
+    /** ReactComment commentId. */
+    public commentId: string;
+
+    /** ReactComment reactionId. */
+    public reactionId: number;
+
+    /**
+     * Creates a new ReactComment instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ReactComment instance
+     */
+    public static create(properties?: IReactComment): ReactComment;
+
+    /**
+     * Encodes the specified ReactComment message. Does not implicitly {@link ReactComment.verify|verify} messages.
+     * @param message ReactComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IReactComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ReactComment message, length delimited. Does not implicitly {@link ReactComment.verify|verify} messages.
+     * @param message ReactComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IReactComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ReactComment message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ReactComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ReactComment;
+
+    /**
+     * Decodes a ReactComment message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ReactComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ReactComment;
+
+    /**
+     * Verifies a ReactComment message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ReactComment message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ReactComment
+     */
+    public static fromObject(object: { [k: string]: any }): ReactComment;
+
+    /**
+     * Creates a plain object from a ReactComment message. Also converts values to other types if specified.
+     * @param message ReactComment
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ReactComment, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ReactComment to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a CreateComment. */
+export interface ICreateComment {
+
+    /** CreateComment videoId */
+    videoId: Long;
+
+    /** CreateComment parentCommentId */
+    parentCommentId?: (string|null);
+
+    /** CreateComment body */
+    body: string;
+}
+
+/** Represents a CreateComment. */
+export class CreateComment implements ICreateComment {
+
+    /**
+     * Constructs a new CreateComment.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ICreateComment);
+
+    /** CreateComment videoId. */
+    public videoId: Long;
+
+    /** CreateComment parentCommentId. */
+    public parentCommentId: string;
+
+    /** CreateComment body. */
+    public body: string;
+
+    /**
+     * Creates a new CreateComment instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns CreateComment instance
+     */
+    public static create(properties?: ICreateComment): CreateComment;
+
+    /**
+     * Encodes the specified CreateComment message. Does not implicitly {@link CreateComment.verify|verify} messages.
+     * @param message CreateComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ICreateComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified CreateComment message, length delimited. Does not implicitly {@link CreateComment.verify|verify} messages.
+     * @param message CreateComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ICreateComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a CreateComment message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns CreateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): CreateComment;
+
+    /**
+     * Decodes a CreateComment message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns CreateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): CreateComment;
+
+    /**
+     * Verifies a CreateComment message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a CreateComment message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns CreateComment
+     */
+    public static fromObject(object: { [k: string]: any }): CreateComment;
+
+    /**
+     * Creates a plain object from a CreateComment message. Also converts values to other types if specified.
+     * @param message CreateComment
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: CreateComment, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this CreateComment to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an EditComment. */
+export interface IEditComment {
+
+    /** EditComment commentId */
+    commentId: string;
+
+    /** EditComment newBody */
+    newBody: string;
+}
+
+/** Represents an EditComment. */
+export class EditComment implements IEditComment {
+
+    /**
+     * Constructs a new EditComment.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IEditComment);
+
+    /** EditComment commentId. */
+    public commentId: string;
+
+    /** EditComment newBody. */
+    public newBody: string;
+
+    /**
+     * Creates a new EditComment instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns EditComment instance
+     */
+    public static create(properties?: IEditComment): EditComment;
+
+    /**
+     * Encodes the specified EditComment message. Does not implicitly {@link EditComment.verify|verify} messages.
+     * @param message EditComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IEditComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified EditComment message, length delimited. Does not implicitly {@link EditComment.verify|verify} messages.
+     * @param message EditComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IEditComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an EditComment message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns EditComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): EditComment;
+
+    /**
+     * Decodes an EditComment message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns EditComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): EditComment;
+
+    /**
+     * Verifies an EditComment message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an EditComment message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns EditComment
+     */
+    public static fromObject(object: { [k: string]: any }): EditComment;
+
+    /**
+     * Creates a plain object from an EditComment message. Also converts values to other types if specified.
+     * @param message EditComment
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: EditComment, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this EditComment to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a DeleteComment. */
+export interface IDeleteComment {
+
+    /** DeleteComment commentId */
+    commentId: string;
+}
+
+/** Represents a DeleteComment. */
+export class DeleteComment implements IDeleteComment {
+
+    /**
+     * Constructs a new DeleteComment.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IDeleteComment);
+
+    /** DeleteComment commentId. */
+    public commentId: string;
+
+    /**
+     * Creates a new DeleteComment instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns DeleteComment instance
+     */
+    public static create(properties?: IDeleteComment): DeleteComment;
+
+    /**
+     * Encodes the specified DeleteComment message. Does not implicitly {@link DeleteComment.verify|verify} messages.
+     * @param message DeleteComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IDeleteComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified DeleteComment message, length delimited. Does not implicitly {@link DeleteComment.verify|verify} messages.
+     * @param message DeleteComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IDeleteComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a DeleteComment message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns DeleteComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DeleteComment;
+
+    /**
+     * Decodes a DeleteComment message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns DeleteComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DeleteComment;
+
+    /**
+     * Verifies a DeleteComment message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a DeleteComment message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns DeleteComment
+     */
+    public static fromObject(object: { [k: string]: any }): DeleteComment;
+
+    /**
+     * Creates a plain object from a DeleteComment message. Also converts values to other types if specified.
+     * @param message DeleteComment
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: DeleteComment, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this DeleteComment to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a PinOrUnpinComment. */
+export interface IPinOrUnpinComment {
+
+    /** PinOrUnpinComment videoId */
+    videoId: Long;
+
+    /** PinOrUnpinComment commentId */
+    commentId: string;
+
+    /** PinOrUnpinComment option */
+    option: PinOrUnpinComment.Option;
+}
+
+/** Represents a PinOrUnpinComment. */
+export class PinOrUnpinComment implements IPinOrUnpinComment {
+
+    /**
+     * Constructs a new PinOrUnpinComment.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IPinOrUnpinComment);
+
+    /** PinOrUnpinComment videoId. */
+    public videoId: Long;
+
+    /** PinOrUnpinComment commentId. */
+    public commentId: string;
+
+    /** PinOrUnpinComment option. */
+    public option: PinOrUnpinComment.Option;
+
+    /**
+     * Creates a new PinOrUnpinComment instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns PinOrUnpinComment instance
+     */
+    public static create(properties?: IPinOrUnpinComment): PinOrUnpinComment;
+
+    /**
+     * Encodes the specified PinOrUnpinComment message. Does not implicitly {@link PinOrUnpinComment.verify|verify} messages.
+     * @param message PinOrUnpinComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IPinOrUnpinComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified PinOrUnpinComment message, length delimited. Does not implicitly {@link PinOrUnpinComment.verify|verify} messages.
+     * @param message PinOrUnpinComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IPinOrUnpinComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a PinOrUnpinComment message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns PinOrUnpinComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): PinOrUnpinComment;
+
+    /**
+     * Decodes a PinOrUnpinComment message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns PinOrUnpinComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): PinOrUnpinComment;
+
+    /**
+     * Verifies a PinOrUnpinComment message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a PinOrUnpinComment message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns PinOrUnpinComment
+     */
+    public static fromObject(object: { [k: string]: any }): PinOrUnpinComment;
+
+    /**
+     * Creates a plain object from a PinOrUnpinComment message. Also converts values to other types if specified.
+     * @param message PinOrUnpinComment
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: PinOrUnpinComment, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this PinOrUnpinComment to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace PinOrUnpinComment {
+
+    /** Option enum. */
+    enum Option {
+        PIN = 0,
+        UNPIN = 1
+    }
+}
+
+/** Properties of a ModerateComment. */
+export interface IModerateComment {
+
+    /** ModerateComment commentId */
+    commentId: string;
+
+    /** ModerateComment rationale */
+    rationale: string;
+}
+
+/** Represents a ModerateComment. */
+export class ModerateComment implements IModerateComment {
+
+    /**
+     * Constructs a new ModerateComment.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IModerateComment);
+
+    /** ModerateComment commentId. */
+    public commentId: string;
+
+    /** ModerateComment rationale. */
+    public rationale: string;
+
+    /**
+     * Creates a new ModerateComment instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ModerateComment instance
+     */
+    public static create(properties?: IModerateComment): ModerateComment;
+
+    /**
+     * Encodes the specified ModerateComment message. Does not implicitly {@link ModerateComment.verify|verify} messages.
+     * @param message ModerateComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IModerateComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ModerateComment message, length delimited. Does not implicitly {@link ModerateComment.verify|verify} messages.
+     * @param message ModerateComment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IModerateComment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ModerateComment message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ModerateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ModerateComment;
+
+    /**
+     * Decodes a ModerateComment message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ModerateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ModerateComment;
+
+    /**
+     * Verifies a ModerateComment message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ModerateComment message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ModerateComment
+     */
+    public static fromObject(object: { [k: string]: any }): ModerateComment;
+
+    /**
+     * Creates a plain object from a ModerateComment message. Also converts values to other types if specified.
+     * @param message ModerateComment
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ModerateComment, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ModerateComment to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a BanOrUnbanMemberFromChannel. */
+export interface IBanOrUnbanMemberFromChannel {
+
+    /** BanOrUnbanMemberFromChannel memberId */
+    memberId: Long;
+
+    /** BanOrUnbanMemberFromChannel option */
+    option: BanOrUnbanMemberFromChannel.Option;
+}
+
+/** Represents a BanOrUnbanMemberFromChannel. */
+export class BanOrUnbanMemberFromChannel implements IBanOrUnbanMemberFromChannel {
+
+    /**
+     * Constructs a new BanOrUnbanMemberFromChannel.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IBanOrUnbanMemberFromChannel);
+
+    /** BanOrUnbanMemberFromChannel memberId. */
+    public memberId: Long;
+
+    /** BanOrUnbanMemberFromChannel option. */
+    public option: BanOrUnbanMemberFromChannel.Option;
+
+    /**
+     * Creates a new BanOrUnbanMemberFromChannel instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns BanOrUnbanMemberFromChannel instance
+     */
+    public static create(properties?: IBanOrUnbanMemberFromChannel): BanOrUnbanMemberFromChannel;
+
+    /**
+     * Encodes the specified BanOrUnbanMemberFromChannel message. Does not implicitly {@link BanOrUnbanMemberFromChannel.verify|verify} messages.
+     * @param message BanOrUnbanMemberFromChannel message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IBanOrUnbanMemberFromChannel, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified BanOrUnbanMemberFromChannel message, length delimited. Does not implicitly {@link BanOrUnbanMemberFromChannel.verify|verify} messages.
+     * @param message BanOrUnbanMemberFromChannel message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IBanOrUnbanMemberFromChannel, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a BanOrUnbanMemberFromChannel message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns BanOrUnbanMemberFromChannel
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): BanOrUnbanMemberFromChannel;
+
+    /**
+     * Decodes a BanOrUnbanMemberFromChannel message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns BanOrUnbanMemberFromChannel
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): BanOrUnbanMemberFromChannel;
+
+    /**
+     * Verifies a BanOrUnbanMemberFromChannel message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a BanOrUnbanMemberFromChannel message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns BanOrUnbanMemberFromChannel
+     */
+    public static fromObject(object: { [k: string]: any }): BanOrUnbanMemberFromChannel;
+
+    /**
+     * Creates a plain object from a BanOrUnbanMemberFromChannel message. Also converts values to other types if specified.
+     * @param message BanOrUnbanMemberFromChannel
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: BanOrUnbanMemberFromChannel, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this BanOrUnbanMemberFromChannel to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace BanOrUnbanMemberFromChannel {
+
+    /** Option enum. */
+    enum Option {
+        BAN = 0,
+        UNBAN = 1
+    }
+}
+
+/** Properties of a VideoReactionsPreference. */
+export interface IVideoReactionsPreference {
+
+    /** VideoReactionsPreference videoId */
+    videoId: Long;
+
+    /** VideoReactionsPreference option */
+    option: VideoReactionsPreference.Option;
+}
+
+/** Represents a VideoReactionsPreference. */
+export class VideoReactionsPreference implements IVideoReactionsPreference {
+
+    /**
+     * Constructs a new VideoReactionsPreference.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IVideoReactionsPreference);
+
+    /** VideoReactionsPreference videoId. */
+    public videoId: Long;
+
+    /** VideoReactionsPreference option. */
+    public option: VideoReactionsPreference.Option;
+
+    /**
+     * Creates a new VideoReactionsPreference instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns VideoReactionsPreference instance
+     */
+    public static create(properties?: IVideoReactionsPreference): VideoReactionsPreference;
+
+    /**
+     * Encodes the specified VideoReactionsPreference message. Does not implicitly {@link VideoReactionsPreference.verify|verify} messages.
+     * @param message VideoReactionsPreference message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IVideoReactionsPreference, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified VideoReactionsPreference message, length delimited. Does not implicitly {@link VideoReactionsPreference.verify|verify} messages.
+     * @param message VideoReactionsPreference message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IVideoReactionsPreference, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a VideoReactionsPreference message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns VideoReactionsPreference
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): VideoReactionsPreference;
+
+    /**
+     * Decodes a VideoReactionsPreference message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns VideoReactionsPreference
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): VideoReactionsPreference;
+
+    /**
+     * Verifies a VideoReactionsPreference message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a VideoReactionsPreference message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns VideoReactionsPreference
+     */
+    public static fromObject(object: { [k: string]: any }): VideoReactionsPreference;
+
+    /**
+     * Creates a plain object from a VideoReactionsPreference message. Also converts values to other types if specified.
+     * @param message VideoReactionsPreference
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: VideoReactionsPreference, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this VideoReactionsPreference to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace VideoReactionsPreference {
+
+    /** Option enum. */
+    enum Option {
+        ENABLE = 0,
+        DISABLE = 1
+    }
+}
+
+/** Properties of a CreateVideoCategory. */
+export interface ICreateVideoCategory {
+
+    /** CreateVideoCategory name */
+    name: string;
+
+    /** CreateVideoCategory description */
+    description?: (string|null);
+
+    /** CreateVideoCategory parentCategoryId */
+    parentCategoryId?: (string|null);
+}
+
+/** Represents a CreateVideoCategory. */
+export class CreateVideoCategory implements ICreateVideoCategory {
+
+    /**
+     * Constructs a new CreateVideoCategory.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ICreateVideoCategory);
+
+    /** CreateVideoCategory name. */
+    public name: string;
+
+    /** CreateVideoCategory description. */
+    public description: string;
+
+    /** CreateVideoCategory parentCategoryId. */
+    public parentCategoryId: string;
+
+    /**
+     * Creates a new CreateVideoCategory instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns CreateVideoCategory instance
+     */
+    public static create(properties?: ICreateVideoCategory): CreateVideoCategory;
+
+    /**
+     * Encodes the specified CreateVideoCategory message. Does not implicitly {@link CreateVideoCategory.verify|verify} messages.
+     * @param message CreateVideoCategory message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ICreateVideoCategory, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified CreateVideoCategory message, length delimited. Does not implicitly {@link CreateVideoCategory.verify|verify} messages.
+     * @param message CreateVideoCategory message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ICreateVideoCategory, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a CreateVideoCategory message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns CreateVideoCategory
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): CreateVideoCategory;
+
+    /**
+     * Decodes a CreateVideoCategory message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns CreateVideoCategory
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): CreateVideoCategory;
+
+    /**
+     * Verifies a CreateVideoCategory message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a CreateVideoCategory message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns CreateVideoCategory
+     */
+    public static fromObject(object: { [k: string]: any }): CreateVideoCategory;
+
+    /**
+     * Creates a plain object from a CreateVideoCategory message. Also converts values to other types if specified.
+     * @param message CreateVideoCategory
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: CreateVideoCategory, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this CreateVideoCategory to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a MakeChannelPayment. */
+export interface IMakeChannelPayment {
+
+    /** MakeChannelPayment rationale */
+    rationale?: (string|null);
+
+    /** MakeChannelPayment videoId */
+    videoId?: (Long|null);
+}
+
+/** Represents a MakeChannelPayment. */
+export class MakeChannelPayment implements IMakeChannelPayment {
+
+    /**
+     * Constructs a new MakeChannelPayment.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IMakeChannelPayment);
+
+    /** MakeChannelPayment rationale. */
+    public rationale: string;
+
+    /** MakeChannelPayment videoId. */
+    public videoId?: (Long|null);
+
+    /** MakeChannelPayment paymentContext. */
+    public paymentContext?: "videoId";
+
+    /**
+     * Creates a new MakeChannelPayment instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns MakeChannelPayment instance
+     */
+    public static create(properties?: IMakeChannelPayment): MakeChannelPayment;
+
+    /**
+     * Encodes the specified MakeChannelPayment message. Does not implicitly {@link MakeChannelPayment.verify|verify} messages.
+     * @param message MakeChannelPayment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IMakeChannelPayment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified MakeChannelPayment message, length delimited. Does not implicitly {@link MakeChannelPayment.verify|verify} messages.
+     * @param message MakeChannelPayment message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IMakeChannelPayment, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a MakeChannelPayment message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns MakeChannelPayment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MakeChannelPayment;
+
+    /**
+     * Decodes a MakeChannelPayment message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns MakeChannelPayment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MakeChannelPayment;
+
+    /**
+     * Verifies a MakeChannelPayment message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a MakeChannelPayment message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns MakeChannelPayment
+     */
+    public static fromObject(object: { [k: string]: any }): MakeChannelPayment;
+
+    /**
+     * Creates a plain object from a MakeChannelPayment message. Also converts values to other types if specified.
+     * @param message MakeChannelPayment
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: MakeChannelPayment, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this MakeChannelPayment to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an AppMetadata. */
+export interface IAppMetadata {
+
+    /** AppMetadata websiteUrl */
+    websiteUrl?: (string|null);
+
+    /** AppMetadata useUri */
+    useUri?: (string|null);
+
+    /** AppMetadata smallIcon */
+    smallIcon?: (string|null);
+
+    /** AppMetadata mediumIcon */
+    mediumIcon?: (string|null);
+
+    /** AppMetadata bigIcon */
+    bigIcon?: (string|null);
+
+    /** AppMetadata oneLiner */
+    oneLiner?: (string|null);
+
+    /** AppMetadata description */
+    description?: (string|null);
+
+    /** AppMetadata termsOfService */
+    termsOfService?: (string|null);
+
+    /** AppMetadata authKey */
+    authKey?: (string|null);
+
+    /** AppMetadata platforms */
+    platforms?: (string[]|null);
+
+    /** AppMetadata category */
+    category?: (string|null);
+}
+
+/** Represents an AppMetadata. */
+export class AppMetadata implements IAppMetadata {
+
+    /**
+     * Constructs a new AppMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IAppMetadata);
+
+    /** AppMetadata websiteUrl. */
+    public websiteUrl: string;
+
+    /** AppMetadata useUri. */
+    public useUri: string;
+
+    /** AppMetadata smallIcon. */
+    public smallIcon: string;
+
+    /** AppMetadata mediumIcon. */
+    public mediumIcon: string;
+
+    /** AppMetadata bigIcon. */
+    public bigIcon: string;
+
+    /** AppMetadata oneLiner. */
+    public oneLiner: string;
+
+    /** AppMetadata description. */
+    public description: string;
+
+    /** AppMetadata termsOfService. */
+    public termsOfService: string;
+
+    /** AppMetadata authKey. */
+    public authKey: string;
+
+    /** AppMetadata platforms. */
+    public platforms: string[];
+
+    /** AppMetadata category. */
+    public category: string;
+
+    /**
+     * Creates a new AppMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns AppMetadata instance
+     */
+    public static create(properties?: IAppMetadata): AppMetadata;
+
+    /**
+     * Encodes the specified AppMetadata message. Does not implicitly {@link AppMetadata.verify|verify} messages.
+     * @param message AppMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IAppMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified AppMetadata message, length delimited. Does not implicitly {@link AppMetadata.verify|verify} messages.
+     * @param message AppMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IAppMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an AppMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns AppMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AppMetadata;
+
+    /**
+     * Decodes an AppMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns AppMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AppMetadata;
+
+    /**
+     * Verifies an AppMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an AppMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns AppMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): AppMetadata;
+
+    /**
+     * Creates a plain object from an AppMetadata message. Also converts values to other types if specified.
+     * @param message AppMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: AppMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this AppMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a CreateApp. */
+export interface ICreateApp {
+
+    /** CreateApp name */
+    name: string;
+
+    /** CreateApp appMetadata */
+    appMetadata?: (IAppMetadata|null);
+}
+
+/** Represents a CreateApp. */
+export class CreateApp implements ICreateApp {
+
+    /**
+     * Constructs a new CreateApp.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ICreateApp);
+
+    /** CreateApp name. */
+    public name: string;
+
+    /** CreateApp appMetadata. */
+    public appMetadata?: (IAppMetadata|null);
+
+    /**
+     * Creates a new CreateApp instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns CreateApp instance
+     */
+    public static create(properties?: ICreateApp): CreateApp;
+
+    /**
+     * Encodes the specified CreateApp message. Does not implicitly {@link CreateApp.verify|verify} messages.
+     * @param message CreateApp message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ICreateApp, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified CreateApp message, length delimited. Does not implicitly {@link CreateApp.verify|verify} messages.
+     * @param message CreateApp message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ICreateApp, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a CreateApp message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns CreateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): CreateApp;
+
+    /**
+     * Decodes a CreateApp message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns CreateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): CreateApp;
+
+    /**
+     * Verifies a CreateApp message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a CreateApp message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns CreateApp
+     */
+    public static fromObject(object: { [k: string]: any }): CreateApp;
+
+    /**
+     * Creates a plain object from a CreateApp message. Also converts values to other types if specified.
+     * @param message CreateApp
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: CreateApp, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this CreateApp to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an UpdateApp. */
+export interface IUpdateApp {
+
+    /** UpdateApp appId */
+    appId: string;
+
+    /** UpdateApp appMetadata */
+    appMetadata?: (IAppMetadata|null);
+}
+
+/** Represents an UpdateApp. */
+export class UpdateApp implements IUpdateApp {
+
+    /**
+     * Constructs a new UpdateApp.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IUpdateApp);
+
+    /** UpdateApp appId. */
+    public appId: string;
+
+    /** UpdateApp appMetadata. */
+    public appMetadata?: (IAppMetadata|null);
+
+    /**
+     * Creates a new UpdateApp instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns UpdateApp instance
+     */
+    public static create(properties?: IUpdateApp): UpdateApp;
+
+    /**
+     * Encodes the specified UpdateApp message. Does not implicitly {@link UpdateApp.verify|verify} messages.
+     * @param message UpdateApp message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IUpdateApp, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified UpdateApp message, length delimited. Does not implicitly {@link UpdateApp.verify|verify} messages.
+     * @param message UpdateApp message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IUpdateApp, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an UpdateApp message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns UpdateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): UpdateApp;
+
+    /**
+     * Decodes an UpdateApp message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns UpdateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): UpdateApp;
+
+    /**
+     * Verifies an UpdateApp message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an UpdateApp message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns UpdateApp
+     */
+    public static fromObject(object: { [k: string]: any }): UpdateApp;
+
+    /**
+     * Creates a plain object from an UpdateApp message. Also converts values to other types if specified.
+     * @param message UpdateApp
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: UpdateApp, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this UpdateApp to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a MemberRemarked. */
+export interface IMemberRemarked {
+
+    /** MemberRemarked reactVideo */
+    reactVideo?: (IReactVideo|null);
+
+    /** MemberRemarked reactComment */
+    reactComment?: (IReactComment|null);
+
+    /** MemberRemarked createComment */
+    createComment?: (ICreateComment|null);
+
+    /** MemberRemarked editComment */
+    editComment?: (IEditComment|null);
+
+    /** MemberRemarked deleteComment */
+    deleteComment?: (IDeleteComment|null);
+
+    /** MemberRemarked createVideoCategory */
+    createVideoCategory?: (ICreateVideoCategory|null);
+
+    /** MemberRemarked createApp */
+    createApp?: (ICreateApp|null);
+
+    /** MemberRemarked updateApp */
+    updateApp?: (IUpdateApp|null);
+
+    /** MemberRemarked makeChannelPayment */
+    makeChannelPayment?: (IMakeChannelPayment|null);
+}
+
+/** Represents a MemberRemarked. */
+export class MemberRemarked implements IMemberRemarked {
+
+    /**
+     * Constructs a new MemberRemarked.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IMemberRemarked);
+
+    /** MemberRemarked reactVideo. */
+    public reactVideo?: (IReactVideo|null);
+
+    /** MemberRemarked reactComment. */
+    public reactComment?: (IReactComment|null);
+
+    /** MemberRemarked createComment. */
+    public createComment?: (ICreateComment|null);
+
+    /** MemberRemarked editComment. */
+    public editComment?: (IEditComment|null);
+
+    /** MemberRemarked deleteComment. */
+    public deleteComment?: (IDeleteComment|null);
+
+    /** MemberRemarked createVideoCategory. */
+    public createVideoCategory?: (ICreateVideoCategory|null);
+
+    /** MemberRemarked createApp. */
+    public createApp?: (ICreateApp|null);
+
+    /** MemberRemarked updateApp. */
+    public updateApp?: (IUpdateApp|null);
+
+    /** MemberRemarked makeChannelPayment. */
+    public makeChannelPayment?: (IMakeChannelPayment|null);
+
+    /** MemberRemarked memberRemarked. */
+    public memberRemarked?: ("reactVideo"|"reactComment"|"createComment"|"editComment"|"deleteComment"|"createVideoCategory"|"createApp"|"updateApp"|"makeChannelPayment");
+
+    /**
+     * Creates a new MemberRemarked instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns MemberRemarked instance
+     */
+    public static create(properties?: IMemberRemarked): MemberRemarked;
+
+    /**
+     * Encodes the specified MemberRemarked message. Does not implicitly {@link MemberRemarked.verify|verify} messages.
+     * @param message MemberRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IMemberRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified MemberRemarked message, length delimited. Does not implicitly {@link MemberRemarked.verify|verify} messages.
+     * @param message MemberRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IMemberRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a MemberRemarked message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns MemberRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MemberRemarked;
+
+    /**
+     * Decodes a MemberRemarked message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns MemberRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MemberRemarked;
+
+    /**
+     * Verifies a MemberRemarked message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a MemberRemarked message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns MemberRemarked
+     */
+    public static fromObject(object: { [k: string]: any }): MemberRemarked;
+
+    /**
+     * Creates a plain object from a MemberRemarked message. Also converts values to other types if specified.
+     * @param message MemberRemarked
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: MemberRemarked, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this MemberRemarked to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ChannelModeratorRemarked. */
+export interface IChannelModeratorRemarked {
+
+    /** ChannelModeratorRemarked moderateComment */
+    moderateComment?: (IModerateComment|null);
+}
+
+/** Represents a ChannelModeratorRemarked. */
+export class ChannelModeratorRemarked implements IChannelModeratorRemarked {
+
+    /**
+     * Constructs a new ChannelModeratorRemarked.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IChannelModeratorRemarked);
+
+    /** ChannelModeratorRemarked moderateComment. */
+    public moderateComment?: (IModerateComment|null);
+
+    /** ChannelModeratorRemarked channelModeratorRemarked. */
+    public channelModeratorRemarked?: "moderateComment";
+
+    /**
+     * Creates a new ChannelModeratorRemarked instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ChannelModeratorRemarked instance
+     */
+    public static create(properties?: IChannelModeratorRemarked): ChannelModeratorRemarked;
+
+    /**
+     * Encodes the specified ChannelModeratorRemarked message. Does not implicitly {@link ChannelModeratorRemarked.verify|verify} messages.
+     * @param message ChannelModeratorRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IChannelModeratorRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ChannelModeratorRemarked message, length delimited. Does not implicitly {@link ChannelModeratorRemarked.verify|verify} messages.
+     * @param message ChannelModeratorRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IChannelModeratorRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ChannelModeratorRemarked message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ChannelModeratorRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelModeratorRemarked;
+
+    /**
+     * Decodes a ChannelModeratorRemarked message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ChannelModeratorRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelModeratorRemarked;
+
+    /**
+     * Verifies a ChannelModeratorRemarked message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ChannelModeratorRemarked message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ChannelModeratorRemarked
+     */
+    public static fromObject(object: { [k: string]: any }): ChannelModeratorRemarked;
+
+    /**
+     * Creates a plain object from a ChannelModeratorRemarked message. Also converts values to other types if specified.
+     * @param message ChannelModeratorRemarked
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ChannelModeratorRemarked, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ChannelModeratorRemarked to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ChannelOwnerRemarked. */
+export interface IChannelOwnerRemarked {
+
+    /** ChannelOwnerRemarked pinOrUnpinComment */
+    pinOrUnpinComment?: (IPinOrUnpinComment|null);
+
+    /** ChannelOwnerRemarked banOrUnbanMemberFromChannel */
+    banOrUnbanMemberFromChannel?: (IBanOrUnbanMemberFromChannel|null);
+
+    /** ChannelOwnerRemarked videoReactionsPreference */
+    videoReactionsPreference?: (IVideoReactionsPreference|null);
+
+    /** ChannelOwnerRemarked moderateComment */
+    moderateComment?: (IModerateComment|null);
+}
+
+/** Represents a ChannelOwnerRemarked. */
+export class ChannelOwnerRemarked implements IChannelOwnerRemarked {
+
+    /**
+     * Constructs a new ChannelOwnerRemarked.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IChannelOwnerRemarked);
+
+    /** ChannelOwnerRemarked pinOrUnpinComment. */
+    public pinOrUnpinComment?: (IPinOrUnpinComment|null);
+
+    /** ChannelOwnerRemarked banOrUnbanMemberFromChannel. */
+    public banOrUnbanMemberFromChannel?: (IBanOrUnbanMemberFromChannel|null);
+
+    /** ChannelOwnerRemarked videoReactionsPreference. */
+    public videoReactionsPreference?: (IVideoReactionsPreference|null);
+
+    /** ChannelOwnerRemarked moderateComment. */
+    public moderateComment?: (IModerateComment|null);
+
+    /** ChannelOwnerRemarked channelOwnerRemarked. */
+    public channelOwnerRemarked?: ("pinOrUnpinComment"|"banOrUnbanMemberFromChannel"|"videoReactionsPreference"|"moderateComment");
+
+    /**
+     * Creates a new ChannelOwnerRemarked instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ChannelOwnerRemarked instance
+     */
+    public static create(properties?: IChannelOwnerRemarked): ChannelOwnerRemarked;
+
+    /**
+     * Encodes the specified ChannelOwnerRemarked message. Does not implicitly {@link ChannelOwnerRemarked.verify|verify} messages.
+     * @param message ChannelOwnerRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IChannelOwnerRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ChannelOwnerRemarked message, length delimited. Does not implicitly {@link ChannelOwnerRemarked.verify|verify} messages.
+     * @param message ChannelOwnerRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IChannelOwnerRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ChannelOwnerRemarked message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ChannelOwnerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ChannelOwnerRemarked;
+
+    /**
+     * Decodes a ChannelOwnerRemarked message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ChannelOwnerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ChannelOwnerRemarked;
+
+    /**
+     * Verifies a ChannelOwnerRemarked message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ChannelOwnerRemarked message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ChannelOwnerRemarked
+     */
+    public static fromObject(object: { [k: string]: any }): ChannelOwnerRemarked;
+
+    /**
+     * Creates a plain object from a ChannelOwnerRemarked message. Also converts values to other types if specified.
+     * @param message ChannelOwnerRemarked
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ChannelOwnerRemarked, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ChannelOwnerRemarked to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a PersonMetadata. */
+export interface IPersonMetadata {
+
+    /** PersonMetadata firstName */
+    firstName?: (string|null);
+
+    /** PersonMetadata middleName */
+    middleName?: (string|null);
+
+    /** PersonMetadata lastName */
+    lastName?: (string|null);
+
+    /** PersonMetadata about */
+    about?: (string|null);
+
+    /** PersonMetadata coverPhoto */
+    coverPhoto?: (number|null);
+
+    /** PersonMetadata avatarPhoto */
+    avatarPhoto?: (number|null);
+}
+
+/** Represents a PersonMetadata. */
+export class PersonMetadata implements IPersonMetadata {
+
+    /**
+     * Constructs a new PersonMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IPersonMetadata);
+
+    /** PersonMetadata firstName. */
+    public firstName: string;
+
+    /** PersonMetadata middleName. */
+    public middleName: string;
+
+    /** PersonMetadata lastName. */
+    public lastName: string;
+
+    /** PersonMetadata about. */
+    public about: string;
+
+    /** PersonMetadata coverPhoto. */
+    public coverPhoto: number;
+
+    /** PersonMetadata avatarPhoto. */
+    public avatarPhoto: number;
+
+    /**
+     * Creates a new PersonMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns PersonMetadata instance
+     */
+    public static create(properties?: IPersonMetadata): PersonMetadata;
+
+    /**
+     * Encodes the specified PersonMetadata message. Does not implicitly {@link PersonMetadata.verify|verify} messages.
+     * @param message PersonMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IPersonMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified PersonMetadata message, length delimited. Does not implicitly {@link PersonMetadata.verify|verify} messages.
+     * @param message PersonMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IPersonMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a PersonMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns PersonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): PersonMetadata;
+
+    /**
+     * Decodes a PersonMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns PersonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): PersonMetadata;
+
+    /**
+     * Verifies a PersonMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a PersonMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns PersonMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): PersonMetadata;
+
+    /**
+     * Creates a plain object from a PersonMetadata message. Also converts values to other types if specified.
+     * @param message PersonMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: PersonMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this PersonMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ProposalsDiscussionPostMetadata. */
+export interface IProposalsDiscussionPostMetadata {
+
+    /** ProposalsDiscussionPostMetadata text */
+    text?: (string|null);
+
+    /** ProposalsDiscussionPostMetadata repliesTo */
+    repliesTo?: (number|null);
+}
+
+/** Represents a ProposalsDiscussionPostMetadata. */
+export class ProposalsDiscussionPostMetadata implements IProposalsDiscussionPostMetadata {
+
+    /**
+     * Constructs a new ProposalsDiscussionPostMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IProposalsDiscussionPostMetadata);
+
+    /** ProposalsDiscussionPostMetadata text. */
+    public text: string;
+
+    /** ProposalsDiscussionPostMetadata repliesTo. */
+    public repliesTo: number;
+
+    /**
+     * Creates a new ProposalsDiscussionPostMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ProposalsDiscussionPostMetadata instance
+     */
+    public static create(properties?: IProposalsDiscussionPostMetadata): ProposalsDiscussionPostMetadata;
+
+    /**
+     * Encodes the specified ProposalsDiscussionPostMetadata message. Does not implicitly {@link ProposalsDiscussionPostMetadata.verify|verify} messages.
+     * @param message ProposalsDiscussionPostMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IProposalsDiscussionPostMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ProposalsDiscussionPostMetadata message, length delimited. Does not implicitly {@link ProposalsDiscussionPostMetadata.verify|verify} messages.
+     * @param message ProposalsDiscussionPostMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IProposalsDiscussionPostMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ProposalsDiscussionPostMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ProposalsDiscussionPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ProposalsDiscussionPostMetadata;
+
+    /**
+     * Decodes a ProposalsDiscussionPostMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ProposalsDiscussionPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ProposalsDiscussionPostMetadata;
+
+    /**
+     * Verifies a ProposalsDiscussionPostMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ProposalsDiscussionPostMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ProposalsDiscussionPostMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): ProposalsDiscussionPostMetadata;
+
+    /**
+     * Creates a plain object from a ProposalsDiscussionPostMetadata message. Also converts values to other types if specified.
+     * @param message ProposalsDiscussionPostMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ProposalsDiscussionPostMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ProposalsDiscussionPostMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a SeriesMetadata. */
+export interface ISeriesMetadata {
+
+    /** SeriesMetadata title */
+    title?: (string|null);
+
+    /** SeriesMetadata description */
+    description?: (string|null);
+
+    /** SeriesMetadata coverPhoto */
+    coverPhoto?: (number|null);
+
+    /** SeriesMetadata persons */
+    persons?: (Long[]|null);
+}
+
+/** Represents a SeriesMetadata. */
+export class SeriesMetadata implements ISeriesMetadata {
+
+    /**
+     * Constructs a new SeriesMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ISeriesMetadata);
+
+    /** SeriesMetadata title. */
+    public title: string;
+
+    /** SeriesMetadata description. */
+    public description: string;
+
+    /** SeriesMetadata coverPhoto. */
+    public coverPhoto: number;
+
+    /** SeriesMetadata persons. */
+    public persons: Long[];
+
+    /**
+     * Creates a new SeriesMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns SeriesMetadata instance
+     */
+    public static create(properties?: ISeriesMetadata): SeriesMetadata;
+
+    /**
+     * Encodes the specified SeriesMetadata message. Does not implicitly {@link SeriesMetadata.verify|verify} messages.
+     * @param message SeriesMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ISeriesMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified SeriesMetadata message, length delimited. Does not implicitly {@link SeriesMetadata.verify|verify} messages.
+     * @param message SeriesMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ISeriesMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a SeriesMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns SeriesMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SeriesMetadata;
+
+    /**
+     * Decodes a SeriesMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns SeriesMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SeriesMetadata;
+
+    /**
+     * Verifies a SeriesMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a SeriesMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns SeriesMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): SeriesMetadata;
+
+    /**
+     * Creates a plain object from a SeriesMetadata message. Also converts values to other types if specified.
+     * @param message SeriesMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: SeriesMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this SeriesMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a SeasonMetadata. */
+export interface ISeasonMetadata {
+
+    /** SeasonMetadata title */
+    title?: (string|null);
+
+    /** SeasonMetadata description */
+    description?: (string|null);
+
+    /** SeasonMetadata coverPhoto */
+    coverPhoto?: (number|null);
+
+    /** SeasonMetadata persons */
+    persons?: (Long[]|null);
+}
+
+/** Represents a SeasonMetadata. */
+export class SeasonMetadata implements ISeasonMetadata {
+
+    /**
+     * Constructs a new SeasonMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ISeasonMetadata);
+
+    /** SeasonMetadata title. */
+    public title: string;
+
+    /** SeasonMetadata description. */
+    public description: string;
+
+    /** SeasonMetadata coverPhoto. */
+    public coverPhoto: number;
+
+    /** SeasonMetadata persons. */
+    public persons: Long[];
+
+    /**
+     * Creates a new SeasonMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns SeasonMetadata instance
+     */
+    public static create(properties?: ISeasonMetadata): SeasonMetadata;
+
+    /**
+     * Encodes the specified SeasonMetadata message. Does not implicitly {@link SeasonMetadata.verify|verify} messages.
+     * @param message SeasonMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ISeasonMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified SeasonMetadata message, length delimited. Does not implicitly {@link SeasonMetadata.verify|verify} messages.
+     * @param message SeasonMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ISeasonMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a SeasonMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns SeasonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SeasonMetadata;
+
+    /**
+     * Decodes a SeasonMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns SeasonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SeasonMetadata;
+
+    /**
+     * Verifies a SeasonMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a SeasonMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns SeasonMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): SeasonMetadata;
+
+    /**
+     * Creates a plain object from a SeasonMetadata message. Also converts values to other types if specified.
+     * @param message SeasonMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: SeasonMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this SeasonMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a GeoCoordiantes. */
+export interface IGeoCoordiantes {
+
+    /** GeoCoordiantes latitude */
+    latitude?: (number|null);
+
+    /** GeoCoordiantes longitude */
+    longitude?: (number|null);
+}
+
+/** Represents a GeoCoordiantes. */
+export class GeoCoordiantes implements IGeoCoordiantes {
+
+    /**
+     * Constructs a new GeoCoordiantes.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IGeoCoordiantes);
+
+    /** GeoCoordiantes latitude. */
+    public latitude: number;
+
+    /** GeoCoordiantes longitude. */
+    public longitude: number;
+
+    /**
+     * Creates a new GeoCoordiantes instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns GeoCoordiantes instance
+     */
+    public static create(properties?: IGeoCoordiantes): GeoCoordiantes;
+
+    /**
+     * Encodes the specified GeoCoordiantes message. Does not implicitly {@link GeoCoordiantes.verify|verify} messages.
+     * @param message GeoCoordiantes message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IGeoCoordiantes, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified GeoCoordiantes message, length delimited. Does not implicitly {@link GeoCoordiantes.verify|verify} messages.
+     * @param message GeoCoordiantes message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IGeoCoordiantes, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a GeoCoordiantes message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns GeoCoordiantes
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): GeoCoordiantes;
+
+    /**
+     * Decodes a GeoCoordiantes message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns GeoCoordiantes
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): GeoCoordiantes;
+
+    /**
+     * Verifies a GeoCoordiantes message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a GeoCoordiantes message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns GeoCoordiantes
+     */
+    public static fromObject(object: { [k: string]: any }): GeoCoordiantes;
+
+    /**
+     * Creates a plain object from a GeoCoordiantes message. Also converts values to other types if specified.
+     * @param message GeoCoordiantes
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: GeoCoordiantes, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this GeoCoordiantes to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a NodeLocationMetadata. */
+export interface INodeLocationMetadata {
+
+    /** NodeLocationMetadata countryCode */
+    countryCode?: (string|null);
+
+    /** NodeLocationMetadata city */
+    city?: (string|null);
+
+    /** NodeLocationMetadata coordinates */
+    coordinates?: (IGeoCoordiantes|null);
+}
+
+/** Represents a NodeLocationMetadata. */
+export class NodeLocationMetadata implements INodeLocationMetadata {
+
+    /**
+     * Constructs a new NodeLocationMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: INodeLocationMetadata);
+
+    /** NodeLocationMetadata countryCode. */
+    public countryCode: string;
+
+    /** NodeLocationMetadata city. */
+    public city: string;
+
+    /** NodeLocationMetadata coordinates. */
+    public coordinates?: (IGeoCoordiantes|null);
+
+    /**
+     * Creates a new NodeLocationMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns NodeLocationMetadata instance
+     */
+    public static create(properties?: INodeLocationMetadata): NodeLocationMetadata;
+
+    /**
+     * Encodes the specified NodeLocationMetadata message. Does not implicitly {@link NodeLocationMetadata.verify|verify} messages.
+     * @param message NodeLocationMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: INodeLocationMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified NodeLocationMetadata message, length delimited. Does not implicitly {@link NodeLocationMetadata.verify|verify} messages.
+     * @param message NodeLocationMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: INodeLocationMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a NodeLocationMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns NodeLocationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): NodeLocationMetadata;
+
+    /**
+     * Decodes a NodeLocationMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns NodeLocationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): NodeLocationMetadata;
+
+    /**
+     * Verifies a NodeLocationMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a NodeLocationMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns NodeLocationMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): NodeLocationMetadata;
+
+    /**
+     * Creates a plain object from a NodeLocationMetadata message. Also converts values to other types if specified.
+     * @param message NodeLocationMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: NodeLocationMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this NodeLocationMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a StorageBucketOperatorMetadata. */
+export interface IStorageBucketOperatorMetadata {
+
+    /** StorageBucketOperatorMetadata endpoint */
+    endpoint?: (string|null);
+
+    /** StorageBucketOperatorMetadata location */
+    location?: (INodeLocationMetadata|null);
+
+    /** StorageBucketOperatorMetadata extra */
+    extra?: (string|null);
+}
+
+/** Represents a StorageBucketOperatorMetadata. */
+export class StorageBucketOperatorMetadata implements IStorageBucketOperatorMetadata {
+
+    /**
+     * Constructs a new StorageBucketOperatorMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IStorageBucketOperatorMetadata);
+
+    /** StorageBucketOperatorMetadata endpoint. */
+    public endpoint: string;
+
+    /** StorageBucketOperatorMetadata location. */
+    public location?: (INodeLocationMetadata|null);
+
+    /** StorageBucketOperatorMetadata extra. */
+    public extra: string;
+
+    /**
+     * Creates a new StorageBucketOperatorMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns StorageBucketOperatorMetadata instance
+     */
+    public static create(properties?: IStorageBucketOperatorMetadata): StorageBucketOperatorMetadata;
+
+    /**
+     * Encodes the specified StorageBucketOperatorMetadata message. Does not implicitly {@link StorageBucketOperatorMetadata.verify|verify} messages.
+     * @param message StorageBucketOperatorMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IStorageBucketOperatorMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified StorageBucketOperatorMetadata message, length delimited. Does not implicitly {@link StorageBucketOperatorMetadata.verify|verify} messages.
+     * @param message StorageBucketOperatorMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IStorageBucketOperatorMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a StorageBucketOperatorMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns StorageBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): StorageBucketOperatorMetadata;
+
+    /**
+     * Decodes a StorageBucketOperatorMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns StorageBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): StorageBucketOperatorMetadata;
+
+    /**
+     * Verifies a StorageBucketOperatorMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a StorageBucketOperatorMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns StorageBucketOperatorMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): StorageBucketOperatorMetadata;
+
+    /**
+     * Creates a plain object from a StorageBucketOperatorMetadata message. Also converts values to other types if specified.
+     * @param message StorageBucketOperatorMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: StorageBucketOperatorMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this StorageBucketOperatorMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a DistributionBucketOperatorMetadata. */
+export interface IDistributionBucketOperatorMetadata {
+
+    /** DistributionBucketOperatorMetadata endpoint */
+    endpoint?: (string|null);
+
+    /** DistributionBucketOperatorMetadata location */
+    location?: (INodeLocationMetadata|null);
+
+    /** DistributionBucketOperatorMetadata extra */
+    extra?: (string|null);
+}
+
+/** Represents a DistributionBucketOperatorMetadata. */
+export class DistributionBucketOperatorMetadata implements IDistributionBucketOperatorMetadata {
+
+    /**
+     * Constructs a new DistributionBucketOperatorMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IDistributionBucketOperatorMetadata);
+
+    /** DistributionBucketOperatorMetadata endpoint. */
+    public endpoint: string;
+
+    /** DistributionBucketOperatorMetadata location. */
+    public location?: (INodeLocationMetadata|null);
+
+    /** DistributionBucketOperatorMetadata extra. */
+    public extra: string;
+
+    /**
+     * Creates a new DistributionBucketOperatorMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns DistributionBucketOperatorMetadata instance
+     */
+    public static create(properties?: IDistributionBucketOperatorMetadata): DistributionBucketOperatorMetadata;
+
+    /**
+     * Encodes the specified DistributionBucketOperatorMetadata message. Does not implicitly {@link DistributionBucketOperatorMetadata.verify|verify} messages.
+     * @param message DistributionBucketOperatorMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IDistributionBucketOperatorMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified DistributionBucketOperatorMetadata message, length delimited. Does not implicitly {@link DistributionBucketOperatorMetadata.verify|verify} messages.
+     * @param message DistributionBucketOperatorMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IDistributionBucketOperatorMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a DistributionBucketOperatorMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns DistributionBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DistributionBucketOperatorMetadata;
+
+    /**
+     * Decodes a DistributionBucketOperatorMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns DistributionBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DistributionBucketOperatorMetadata;
+
+    /**
+     * Verifies a DistributionBucketOperatorMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a DistributionBucketOperatorMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns DistributionBucketOperatorMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): DistributionBucketOperatorMetadata;
+
+    /**
+     * Creates a plain object from a DistributionBucketOperatorMetadata message. Also converts values to other types if specified.
+     * @param message DistributionBucketOperatorMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: DistributionBucketOperatorMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this DistributionBucketOperatorMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a GeographicalArea. */
+export interface IGeographicalArea {
+
+    /** GeographicalArea continent */
+    continent?: (GeographicalArea.Continent|null);
+
+    /** GeographicalArea countryCode */
+    countryCode?: (string|null);
+
+    /** GeographicalArea subdivisionCode */
+    subdivisionCode?: (string|null);
+}
+
+/** Represents a GeographicalArea. */
+export class GeographicalArea implements IGeographicalArea {
+
+    /**
+     * Constructs a new GeographicalArea.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IGeographicalArea);
+
+    /** GeographicalArea continent. */
+    public continent?: (GeographicalArea.Continent|null);
+
+    /** GeographicalArea countryCode. */
+    public countryCode?: (string|null);
+
+    /** GeographicalArea subdivisionCode. */
+    public subdivisionCode?: (string|null);
+
+    /** GeographicalArea code. */
+    public code?: ("continent"|"countryCode"|"subdivisionCode");
+
+    /**
+     * Creates a new GeographicalArea instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns GeographicalArea instance
+     */
+    public static create(properties?: IGeographicalArea): GeographicalArea;
+
+    /**
+     * Encodes the specified GeographicalArea message. Does not implicitly {@link GeographicalArea.verify|verify} messages.
+     * @param message GeographicalArea message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IGeographicalArea, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified GeographicalArea message, length delimited. Does not implicitly {@link GeographicalArea.verify|verify} messages.
+     * @param message GeographicalArea message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IGeographicalArea, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a GeographicalArea message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns GeographicalArea
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): GeographicalArea;
+
+    /**
+     * Decodes a GeographicalArea message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns GeographicalArea
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): GeographicalArea;
+
+    /**
+     * Verifies a GeographicalArea message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a GeographicalArea message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns GeographicalArea
+     */
+    public static fromObject(object: { [k: string]: any }): GeographicalArea;
+
+    /**
+     * Creates a plain object from a GeographicalArea message. Also converts values to other types if specified.
+     * @param message GeographicalArea
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: GeographicalArea, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this GeographicalArea to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace GeographicalArea {
+
+    /** Continent enum. */
+    enum Continent {
+        AF = 1,
+        NA = 2,
+        OC = 3,
+        AN = 4,
+        AS = 5,
+        EU = 6,
+        SA = 7
+    }
+}
+
+/** Properties of a DistributionBucketFamilyMetadata. */
+export interface IDistributionBucketFamilyMetadata {
+
+    /** DistributionBucketFamilyMetadata region */
+    region?: (string|null);
+
+    /** DistributionBucketFamilyMetadata description */
+    description?: (string|null);
+
+    /** DistributionBucketFamilyMetadata areas */
+    areas?: (IGeographicalArea[]|null);
+
+    /** DistributionBucketFamilyMetadata latencyTestTargets */
+    latencyTestTargets?: (string[]|null);
+}
+
+/** Represents a DistributionBucketFamilyMetadata. */
+export class DistributionBucketFamilyMetadata implements IDistributionBucketFamilyMetadata {
+
+    /**
+     * Constructs a new DistributionBucketFamilyMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IDistributionBucketFamilyMetadata);
+
+    /** DistributionBucketFamilyMetadata region. */
+    public region: string;
+
+    /** DistributionBucketFamilyMetadata description. */
+    public description: string;
+
+    /** DistributionBucketFamilyMetadata areas. */
+    public areas: IGeographicalArea[];
+
+    /** DistributionBucketFamilyMetadata latencyTestTargets. */
+    public latencyTestTargets: string[];
+
+    /**
+     * Creates a new DistributionBucketFamilyMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns DistributionBucketFamilyMetadata instance
+     */
+    public static create(properties?: IDistributionBucketFamilyMetadata): DistributionBucketFamilyMetadata;
+
+    /**
+     * Encodes the specified DistributionBucketFamilyMetadata message. Does not implicitly {@link DistributionBucketFamilyMetadata.verify|verify} messages.
+     * @param message DistributionBucketFamilyMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IDistributionBucketFamilyMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified DistributionBucketFamilyMetadata message, length delimited. Does not implicitly {@link DistributionBucketFamilyMetadata.verify|verify} messages.
+     * @param message DistributionBucketFamilyMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IDistributionBucketFamilyMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a DistributionBucketFamilyMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns DistributionBucketFamilyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DistributionBucketFamilyMetadata;
+
+    /**
+     * Decodes a DistributionBucketFamilyMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns DistributionBucketFamilyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DistributionBucketFamilyMetadata;
+
+    /**
+     * Verifies a DistributionBucketFamilyMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a DistributionBucketFamilyMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns DistributionBucketFamilyMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): DistributionBucketFamilyMetadata;
+
+    /**
+     * Creates a plain object from a DistributionBucketFamilyMetadata message. Also converts values to other types if specified.
+     * @param message DistributionBucketFamilyMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: DistributionBucketFamilyMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this DistributionBucketFamilyMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a TokenMetadata. */
+export interface ITokenMetadata {
+
+    /** TokenMetadata name */
+    name?: (string|null);
+
+    /** TokenMetadata description */
+    description?: (string|null);
+
+    /** TokenMetadata avatarObject */
+    avatarObject?: (number|null);
+
+    /** TokenMetadata avatarUri */
+    avatarUri?: (string|null);
+
+    /** TokenMetadata benefits */
+    benefits?: (IBenefit[]|null);
+
+    /** TokenMetadata whitelistApplicationNote */
+    whitelistApplicationNote?: (string|null);
+
+    /** TokenMetadata whitelistApplicationApplyLink */
+    whitelistApplicationApplyLink?: (string|null);
+}
+
+/** Represents a TokenMetadata. */
+export class TokenMetadata implements ITokenMetadata {
+
+    /**
+     * Constructs a new TokenMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ITokenMetadata);
+
+    /** TokenMetadata name. */
+    public name: string;
+
+    /** TokenMetadata description. */
+    public description: string;
+
+    /** TokenMetadata avatarObject. */
+    public avatarObject?: (number|null);
+
+    /** TokenMetadata avatarUri. */
+    public avatarUri?: (string|null);
+
+    /** TokenMetadata benefits. */
+    public benefits: IBenefit[];
+
+    /** TokenMetadata whitelistApplicationNote. */
+    public whitelistApplicationNote: string;
+
+    /** TokenMetadata whitelistApplicationApplyLink. */
+    public whitelistApplicationApplyLink: string;
+
+    /** TokenMetadata avatar. */
+    public avatar?: ("avatarObject"|"avatarUri");
+
+    /**
+     * Creates a new TokenMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns TokenMetadata instance
+     */
+    public static create(properties?: ITokenMetadata): TokenMetadata;
+
+    /**
+     * Encodes the specified TokenMetadata message. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @param message TokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ITokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified TokenMetadata message, length delimited. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @param message TokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ITokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TokenMetadata;
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TokenMetadata;
+
+    /**
+     * Verifies a TokenMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a TokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns TokenMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): TokenMetadata;
+
+    /**
+     * Creates a plain object from a TokenMetadata message. Also converts values to other types if specified.
+     * @param message TokenMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: TokenMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this TokenMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a Benefit. */
+export interface IBenefit {
+
+    /** Benefit title */
+    title?: (string|null);
+
+    /** Benefit description */
+    description?: (string|null);
+
+    /** Benefit emoji */
+    emoji?: (string|null);
+
+    /** Benefit displayOrder */
+    displayOrder?: (number|null);
+}
+
+/** Represents a Benefit. */
+export class Benefit implements IBenefit {
+
+    /**
+     * Constructs a new Benefit.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IBenefit);
+
+    /** Benefit title. */
+    public title: string;
+
+    /** Benefit description. */
+    public description: string;
+
+    /** Benefit emoji. */
+    public emoji: string;
+
+    /** Benefit displayOrder. */
+    public displayOrder: number;
+
+    /**
+     * Creates a new Benefit instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns Benefit instance
+     */
+    public static create(properties?: IBenefit): Benefit;
+
+    /**
+     * Encodes the specified Benefit message. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @param message Benefit message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IBenefit, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified Benefit message, length delimited. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @param message Benefit message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IBenefit, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Benefit;
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Benefit;
+
+    /**
+     * Verifies a Benefit message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a Benefit message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns Benefit
+     */
+    public static fromObject(object: { [k: string]: any }): Benefit;
+
+    /**
+     * Creates a plain object from a Benefit message. Also converts values to other types if specified.
+     * @param message Benefit
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: Benefit, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this Benefit to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a Sale. */
+export interface ISale {
+
+    /** Sale termsAndConditions */
+    termsAndConditions?: (string|null);
+}
+
+/** Represents a Sale. */
+export class Sale implements ISale {
+
+    /**
+     * Constructs a new Sale.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ISale);
+
+    /** Sale termsAndConditions. */
+    public termsAndConditions: string;
+
+    /**
+     * Creates a new Sale instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns Sale instance
+     */
+    public static create(properties?: ISale): Sale;
+
+    /**
+     * Encodes the specified Sale message. Does not implicitly {@link Sale.verify|verify} messages.
+     * @param message Sale message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ISale, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified Sale message, length delimited. Does not implicitly {@link Sale.verify|verify} messages.
+     * @param message Sale message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ISale, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a Sale message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns Sale
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Sale;
+
+    /**
+     * Decodes a Sale message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns Sale
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Sale;
+
+    /**
+     * Verifies a Sale message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a Sale message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns Sale
+     */
+    public static fromObject(object: { [k: string]: any }): Sale;
+
+    /**
+     * Creates a plain object from a Sale message. Also converts values to other types if specified.
+     * @param message Sale
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: Sale, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this Sale to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a PublishedBeforeJoystream. */
+export interface IPublishedBeforeJoystream {
+
+    /** PublishedBeforeJoystream isPublished */
+    isPublished?: (boolean|null);
+
+    /** PublishedBeforeJoystream date */
+    date?: (string|null);
+}
+
+/** Represents a PublishedBeforeJoystream. */
+export class PublishedBeforeJoystream implements IPublishedBeforeJoystream {
+
+    /**
+     * Constructs a new PublishedBeforeJoystream.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IPublishedBeforeJoystream);
+
+    /** PublishedBeforeJoystream isPublished. */
+    public isPublished: boolean;
+
+    /** PublishedBeforeJoystream date. */
+    public date: string;
+
+    /**
+     * Creates a new PublishedBeforeJoystream instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns PublishedBeforeJoystream instance
+     */
+    public static create(properties?: IPublishedBeforeJoystream): PublishedBeforeJoystream;
+
+    /**
+     * Encodes the specified PublishedBeforeJoystream message. Does not implicitly {@link PublishedBeforeJoystream.verify|verify} messages.
+     * @param message PublishedBeforeJoystream message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IPublishedBeforeJoystream, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified PublishedBeforeJoystream message, length delimited. Does not implicitly {@link PublishedBeforeJoystream.verify|verify} messages.
+     * @param message PublishedBeforeJoystream message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IPublishedBeforeJoystream, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a PublishedBeforeJoystream message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns PublishedBeforeJoystream
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): PublishedBeforeJoystream;
+
+    /**
+     * Decodes a PublishedBeforeJoystream message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns PublishedBeforeJoystream
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): PublishedBeforeJoystream;
+
+    /**
+     * Verifies a PublishedBeforeJoystream message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a PublishedBeforeJoystream message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns PublishedBeforeJoystream
+     */
+    public static fromObject(object: { [k: string]: any }): PublishedBeforeJoystream;
+
+    /**
+     * Creates a plain object from a PublishedBeforeJoystream message. Also converts values to other types if specified.
+     * @param message PublishedBeforeJoystream
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: PublishedBeforeJoystream, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this PublishedBeforeJoystream to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a License. */
+export interface ILicense {
+
+    /** License code */
+    code?: (number|null);
+
+    /** License attribution */
+    attribution?: (string|null);
+
+    /** License customText */
+    customText?: (string|null);
+}
+
+/** Represents a License. */
+export class License implements ILicense {
+
+    /**
+     * Constructs a new License.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ILicense);
+
+    /** License code. */
+    public code: number;
+
+    /** License attribution. */
+    public attribution: string;
+
+    /** License customText. */
+    public customText: string;
+
+    /**
+     * Creates a new License instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns License instance
+     */
+    public static create(properties?: ILicense): License;
+
+    /**
+     * Encodes the specified License message. Does not implicitly {@link License.verify|verify} messages.
+     * @param message License message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ILicense, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified License message, length delimited. Does not implicitly {@link License.verify|verify} messages.
+     * @param message License message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ILicense, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a License message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns License
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): License;
+
+    /**
+     * Decodes a License message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns License
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): License;
+
+    /**
+     * Verifies a License message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a License message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns License
+     */
+    public static fromObject(object: { [k: string]: any }): License;
+
+    /**
+     * Creates a plain object from a License message. Also converts values to other types if specified.
+     * @param message License
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: License, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this License to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a MediaType. */
+export interface IMediaType {
+
+    /** MediaType codecName */
+    codecName?: (string|null);
+
+    /** MediaType container */
+    container?: (string|null);
+
+    /** MediaType mimeMediaType */
+    mimeMediaType?: (string|null);
+}
+
+/** Represents a MediaType. */
+export class MediaType implements IMediaType {
+
+    /**
+     * Constructs a new MediaType.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IMediaType);
+
+    /** MediaType codecName. */
+    public codecName: string;
+
+    /** MediaType container. */
+    public container: string;
+
+    /** MediaType mimeMediaType. */
+    public mimeMediaType: string;
+
+    /**
+     * Creates a new MediaType instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns MediaType instance
+     */
+    public static create(properties?: IMediaType): MediaType;
+
+    /**
+     * Encodes the specified MediaType message. Does not implicitly {@link MediaType.verify|verify} messages.
+     * @param message MediaType message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IMediaType, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified MediaType message, length delimited. Does not implicitly {@link MediaType.verify|verify} messages.
+     * @param message MediaType message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IMediaType, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a MediaType message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns MediaType
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MediaType;
+
+    /**
+     * Decodes a MediaType message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns MediaType
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MediaType;
+
+    /**
+     * Verifies a MediaType message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a MediaType message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns MediaType
+     */
+    public static fromObject(object: { [k: string]: any }): MediaType;
+
+    /**
+     * Creates a plain object from a MediaType message. Also converts values to other types if specified.
+     * @param message MediaType
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: MediaType, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this MediaType to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a SubtitleMetadata. */
+export interface ISubtitleMetadata {
+
+    /** SubtitleMetadata type */
+    type: string;
+
+    /** SubtitleMetadata newAsset */
+    newAsset?: (number|null);
+
+    /** SubtitleMetadata language */
+    language: string;
+
+    /** SubtitleMetadata mimeType */
+    mimeType: string;
+}
+
+/** Represents a SubtitleMetadata. */
+export class SubtitleMetadata implements ISubtitleMetadata {
+
+    /**
+     * Constructs a new SubtitleMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ISubtitleMetadata);
+
+    /** SubtitleMetadata type. */
+    public type: string;
+
+    /** SubtitleMetadata newAsset. */
+    public newAsset: number;
+
+    /** SubtitleMetadata language. */
+    public language: string;
+
+    /** SubtitleMetadata mimeType. */
+    public mimeType: string;
+
+    /**
+     * Creates a new SubtitleMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns SubtitleMetadata instance
+     */
+    public static create(properties?: ISubtitleMetadata): SubtitleMetadata;
+
+    /**
+     * Encodes the specified SubtitleMetadata message. Does not implicitly {@link SubtitleMetadata.verify|verify} messages.
+     * @param message SubtitleMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ISubtitleMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified SubtitleMetadata message, length delimited. Does not implicitly {@link SubtitleMetadata.verify|verify} messages.
+     * @param message SubtitleMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ISubtitleMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a SubtitleMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns SubtitleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SubtitleMetadata;
+
+    /**
+     * Decodes a SubtitleMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns SubtitleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SubtitleMetadata;
+
+    /**
+     * Verifies a SubtitleMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a SubtitleMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns SubtitleMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): SubtitleMetadata;
+
+    /**
+     * Creates a plain object from a SubtitleMetadata message. Also converts values to other types if specified.
+     * @param message SubtitleMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: SubtitleMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this SubtitleMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a VideoMetadata. */
+export interface IVideoMetadata {
+
+    /** VideoMetadata title */
+    title?: (string|null);
+
+    /** VideoMetadata description */
+    description?: (string|null);
+
+    /** VideoMetadata video */
+    video?: (number|null);
+
+    /** VideoMetadata thumbnailPhoto */
+    thumbnailPhoto?: (number|null);
+
+    /** VideoMetadata duration */
+    duration?: (number|null);
+
+    /** VideoMetadata mediaPixelHeight */
+    mediaPixelHeight?: (number|null);
+
+    /** VideoMetadata mediaPixelWidth */
+    mediaPixelWidth?: (number|null);
+
+    /** VideoMetadata mediaType */
+    mediaType?: (IMediaType|null);
+
+    /** VideoMetadata language */
+    language?: (string|null);
+
+    /** VideoMetadata license */
+    license?: (ILicense|null);
+
+    /** VideoMetadata publishedBeforeJoystream */
+    publishedBeforeJoystream?: (IPublishedBeforeJoystream|null);
+
+    /** VideoMetadata hasMarketing */
+    hasMarketing?: (boolean|null);
+
+    /** VideoMetadata isPublic */
+    isPublic?: (boolean|null);
+
+    /** VideoMetadata isExplicit */
+    isExplicit?: (boolean|null);
+
+    /** VideoMetadata persons */
+    persons?: (Long[]|null);
+
+    /** VideoMetadata category */
+    category?: (string|null);
+
+    /** VideoMetadata subtitles */
+    subtitles?: (ISubtitleMetadata[]|null);
+
+    /** VideoMetadata enableComments */
+    enableComments?: (boolean|null);
+
+    /** VideoMetadata clearSubtitles */
+    clearSubtitles?: (boolean|null);
+}
+
+/** Represents a VideoMetadata. */
+export class VideoMetadata implements IVideoMetadata {
+
+    /**
+     * Constructs a new VideoMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IVideoMetadata);
+
+    /** VideoMetadata title. */
+    public title: string;
+
+    /** VideoMetadata description. */
+    public description: string;
+
+    /** VideoMetadata video. */
+    public video: number;
+
+    /** VideoMetadata thumbnailPhoto. */
+    public thumbnailPhoto: number;
+
+    /** VideoMetadata duration. */
+    public duration: number;
+
+    /** VideoMetadata mediaPixelHeight. */
+    public mediaPixelHeight: number;
+
+    /** VideoMetadata mediaPixelWidth. */
+    public mediaPixelWidth: number;
+
+    /** VideoMetadata mediaType. */
+    public mediaType?: (IMediaType|null);
+
+    /** VideoMetadata language. */
+    public language: string;
+
+    /** VideoMetadata license. */
+    public license?: (ILicense|null);
+
+    /** VideoMetadata publishedBeforeJoystream. */
+    public publishedBeforeJoystream?: (IPublishedBeforeJoystream|null);
+
+    /** VideoMetadata hasMarketing. */
+    public hasMarketing: boolean;
+
+    /** VideoMetadata isPublic. */
+    public isPublic: boolean;
+
+    /** VideoMetadata isExplicit. */
+    public isExplicit: boolean;
+
+    /** VideoMetadata persons. */
+    public persons: Long[];
+
+    /** VideoMetadata category. */
+    public category: string;
+
+    /** VideoMetadata subtitles. */
+    public subtitles: ISubtitleMetadata[];
+
+    /** VideoMetadata enableComments. */
+    public enableComments: boolean;
+
+    /** VideoMetadata clearSubtitles. */
+    public clearSubtitles: boolean;
+
+    /**
+     * Creates a new VideoMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns VideoMetadata instance
+     */
+    public static create(properties?: IVideoMetadata): VideoMetadata;
+
+    /**
+     * Encodes the specified VideoMetadata message. Does not implicitly {@link VideoMetadata.verify|verify} messages.
+     * @param message VideoMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IVideoMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified VideoMetadata message, length delimited. Does not implicitly {@link VideoMetadata.verify|verify} messages.
+     * @param message VideoMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IVideoMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a VideoMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns VideoMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): VideoMetadata;
+
+    /**
+     * Decodes a VideoMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns VideoMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): VideoMetadata;
+
+    /**
+     * Verifies a VideoMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a VideoMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns VideoMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): VideoMetadata;
+
+    /**
+     * Creates a plain object from a VideoMetadata message. Also converts values to other types if specified.
+     * @param message VideoMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: VideoMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this VideoMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ContentMetadata. */
+export interface IContentMetadata {
+
+    /** ContentMetadata videoMetadata */
+    videoMetadata?: (IVideoMetadata|null);
+}
+
+/** Represents a ContentMetadata. */
+export class ContentMetadata implements IContentMetadata {
+
+    /**
+     * Constructs a new ContentMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IContentMetadata);
+
+    /** ContentMetadata videoMetadata. */
+    public videoMetadata?: (IVideoMetadata|null);
+
+    /** ContentMetadata contentMetadata. */
+    public contentMetadata?: "videoMetadata";
+
+    /**
+     * Creates a new ContentMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ContentMetadata instance
+     */
+    public static create(properties?: IContentMetadata): ContentMetadata;
+
+    /**
+     * Encodes the specified ContentMetadata message. Does not implicitly {@link ContentMetadata.verify|verify} messages.
+     * @param message ContentMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IContentMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ContentMetadata message, length delimited. Does not implicitly {@link ContentMetadata.verify|verify} messages.
+     * @param message ContentMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IContentMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ContentMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ContentMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ContentMetadata;
+
+    /**
+     * Decodes a ContentMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ContentMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ContentMetadata;
+
+    /**
+     * Verifies a ContentMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ContentMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ContentMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): ContentMetadata;
+
+    /**
+     * Creates a plain object from a ContentMetadata message. Also converts values to other types if specified.
+     * @param message ContentMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ContentMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ContentMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an OpeningMetadata. */
+export interface IOpeningMetadata {
+
+    /** OpeningMetadata shortDescription */
+    shortDescription?: (string|null);
+
+    /** OpeningMetadata description */
+    description?: (string|null);
+
+    /** OpeningMetadata hiringLimit */
+    hiringLimit?: (number|null);
+
+    /** OpeningMetadata expectedEndingTimestamp */
+    expectedEndingTimestamp?: (number|null);
+
+    /** OpeningMetadata applicationDetails */
+    applicationDetails?: (string|null);
+
+    /** OpeningMetadata applicationFormQuestions */
+    applicationFormQuestions?: (OpeningMetadata.IApplicationFormQuestion[]|null);
+
+    /** OpeningMetadata title */
+    title?: (string|null);
+}
+
+/** Represents an OpeningMetadata. */
+export class OpeningMetadata implements IOpeningMetadata {
+
+    /**
+     * Constructs a new OpeningMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IOpeningMetadata);
+
+    /** OpeningMetadata shortDescription. */
+    public shortDescription: string;
+
+    /** OpeningMetadata description. */
+    public description: string;
+
+    /** OpeningMetadata hiringLimit. */
+    public hiringLimit: number;
+
+    /** OpeningMetadata expectedEndingTimestamp. */
+    public expectedEndingTimestamp: number;
+
+    /** OpeningMetadata applicationDetails. */
+    public applicationDetails: string;
+
+    /** OpeningMetadata applicationFormQuestions. */
+    public applicationFormQuestions: OpeningMetadata.IApplicationFormQuestion[];
+
+    /** OpeningMetadata title. */
+    public title: string;
+
+    /**
+     * Creates a new OpeningMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns OpeningMetadata instance
+     */
+    public static create(properties?: IOpeningMetadata): OpeningMetadata;
+
+    /**
+     * Encodes the specified OpeningMetadata message. Does not implicitly {@link OpeningMetadata.verify|verify} messages.
+     * @param message OpeningMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IOpeningMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified OpeningMetadata message, length delimited. Does not implicitly {@link OpeningMetadata.verify|verify} messages.
+     * @param message OpeningMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IOpeningMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an OpeningMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns OpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): OpeningMetadata;
+
+    /**
+     * Decodes an OpeningMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns OpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): OpeningMetadata;
+
+    /**
+     * Verifies an OpeningMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an OpeningMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns OpeningMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): OpeningMetadata;
+
+    /**
+     * Creates a plain object from an OpeningMetadata message. Also converts values to other types if specified.
+     * @param message OpeningMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: OpeningMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this OpeningMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+export namespace OpeningMetadata {
+
+    /** Properties of an ApplicationFormQuestion. */
+    interface IApplicationFormQuestion {
+
+        /** ApplicationFormQuestion question */
+        question?: (string|null);
+
+        /** ApplicationFormQuestion type */
+        type?: (OpeningMetadata.ApplicationFormQuestion.InputType|null);
+    }
+
+    /** Represents an ApplicationFormQuestion. */
+    class ApplicationFormQuestion implements IApplicationFormQuestion {
+
+        /**
+         * Constructs a new ApplicationFormQuestion.
+         * @param [properties] Properties to set
+         */
+        constructor(properties?: OpeningMetadata.IApplicationFormQuestion);
+
+        /** ApplicationFormQuestion question. */
+        public question: string;
+
+        /** ApplicationFormQuestion type. */
+        public type: OpeningMetadata.ApplicationFormQuestion.InputType;
+
+        /**
+         * Creates a new ApplicationFormQuestion instance using the specified properties.
+         * @param [properties] Properties to set
+         * @returns ApplicationFormQuestion instance
+         */
+        public static create(properties?: OpeningMetadata.IApplicationFormQuestion): OpeningMetadata.ApplicationFormQuestion;
+
+        /**
+         * Encodes the specified ApplicationFormQuestion message. Does not implicitly {@link OpeningMetadata.ApplicationFormQuestion.verify|verify} messages.
+         * @param message ApplicationFormQuestion message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encode(message: OpeningMetadata.IApplicationFormQuestion, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Encodes the specified ApplicationFormQuestion message, length delimited. Does not implicitly {@link OpeningMetadata.ApplicationFormQuestion.verify|verify} messages.
+         * @param message ApplicationFormQuestion message or plain object to encode
+         * @param [writer] Writer to encode to
+         * @returns Writer
+         */
+        public static encodeDelimited(message: OpeningMetadata.IApplicationFormQuestion, writer?: $protobuf.Writer): $protobuf.Writer;
+
+        /**
+         * Decodes an ApplicationFormQuestion message from the specified reader or buffer.
+         * @param reader Reader or buffer to decode from
+         * @param [length] Message length if known beforehand
+         * @returns ApplicationFormQuestion
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): OpeningMetadata.ApplicationFormQuestion;
+
+        /**
+         * Decodes an ApplicationFormQuestion message from the specified reader or buffer, length delimited.
+         * @param reader Reader or buffer to decode from
+         * @returns ApplicationFormQuestion
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): OpeningMetadata.ApplicationFormQuestion;
+
+        /**
+         * Verifies an ApplicationFormQuestion message.
+         * @param message Plain object to verify
+         * @returns `null` if valid, otherwise the reason why it is not
+         */
+        public static verify(message: { [k: string]: any }): (string|null);
+
+        /**
+         * Creates an ApplicationFormQuestion message from a plain object. Also converts values to their respective internal types.
+         * @param object Plain object
+         * @returns ApplicationFormQuestion
+         */
+        public static fromObject(object: { [k: string]: any }): OpeningMetadata.ApplicationFormQuestion;
+
+        /**
+         * Creates a plain object from an ApplicationFormQuestion message. Also converts values to other types if specified.
+         * @param message ApplicationFormQuestion
+         * @param [options] Conversion options
+         * @returns Plain object
+         */
+        public static toObject(message: OpeningMetadata.ApplicationFormQuestion, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+        /**
+         * Converts this ApplicationFormQuestion to JSON.
+         * @returns JSON object
+         */
+        public toJSON(): { [k: string]: any };
+    }
+
+    namespace ApplicationFormQuestion {
+
+        /** InputType enum. */
+        enum InputType {
+            TEXTAREA = 0,
+            TEXT = 1
+        }
+    }
+}
+
+/** Properties of an UpcomingOpeningMetadata. */
+export interface IUpcomingOpeningMetadata {
+
+    /** UpcomingOpeningMetadata expectedStart */
+    expectedStart?: (number|null);
+
+    /** UpcomingOpeningMetadata rewardPerBlock */
+    rewardPerBlock?: (Long|null);
+
+    /** UpcomingOpeningMetadata minApplicationStake */
+    minApplicationStake?: (Long|null);
+
+    /** UpcomingOpeningMetadata metadata */
+    metadata?: (IOpeningMetadata|null);
+}
+
+/** Represents an UpcomingOpeningMetadata. */
+export class UpcomingOpeningMetadata implements IUpcomingOpeningMetadata {
+
+    /**
+     * Constructs a new UpcomingOpeningMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IUpcomingOpeningMetadata);
+
+    /** UpcomingOpeningMetadata expectedStart. */
+    public expectedStart: number;
+
+    /** UpcomingOpeningMetadata rewardPerBlock. */
+    public rewardPerBlock: Long;
+
+    /** UpcomingOpeningMetadata minApplicationStake. */
+    public minApplicationStake: Long;
+
+    /** UpcomingOpeningMetadata metadata. */
+    public metadata?: (IOpeningMetadata|null);
+
+    /**
+     * Creates a new UpcomingOpeningMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns UpcomingOpeningMetadata instance
+     */
+    public static create(properties?: IUpcomingOpeningMetadata): UpcomingOpeningMetadata;
+
+    /**
+     * Encodes the specified UpcomingOpeningMetadata message. Does not implicitly {@link UpcomingOpeningMetadata.verify|verify} messages.
+     * @param message UpcomingOpeningMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IUpcomingOpeningMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified UpcomingOpeningMetadata message, length delimited. Does not implicitly {@link UpcomingOpeningMetadata.verify|verify} messages.
+     * @param message UpcomingOpeningMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IUpcomingOpeningMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an UpcomingOpeningMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns UpcomingOpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): UpcomingOpeningMetadata;
+
+    /**
+     * Decodes an UpcomingOpeningMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns UpcomingOpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): UpcomingOpeningMetadata;
+
+    /**
+     * Verifies an UpcomingOpeningMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an UpcomingOpeningMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns UpcomingOpeningMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): UpcomingOpeningMetadata;
+
+    /**
+     * Creates a plain object from an UpcomingOpeningMetadata message. Also converts values to other types if specified.
+     * @param message UpcomingOpeningMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: UpcomingOpeningMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this UpcomingOpeningMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an ApplicationMetadata. */
+export interface IApplicationMetadata {
+
+    /** ApplicationMetadata answers */
+    answers?: (string[]|null);
+}
+
+/** Represents an ApplicationMetadata. */
+export class ApplicationMetadata implements IApplicationMetadata {
+
+    /**
+     * Constructs a new ApplicationMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IApplicationMetadata);
+
+    /** ApplicationMetadata answers. */
+    public answers: string[];
+
+    /**
+     * Creates a new ApplicationMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ApplicationMetadata instance
+     */
+    public static create(properties?: IApplicationMetadata): ApplicationMetadata;
+
+    /**
+     * Encodes the specified ApplicationMetadata message. Does not implicitly {@link ApplicationMetadata.verify|verify} messages.
+     * @param message ApplicationMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IApplicationMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ApplicationMetadata message, length delimited. Does not implicitly {@link ApplicationMetadata.verify|verify} messages.
+     * @param message ApplicationMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IApplicationMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an ApplicationMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ApplicationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ApplicationMetadata;
+
+    /**
+     * Decodes an ApplicationMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ApplicationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ApplicationMetadata;
+
+    /**
+     * Verifies an ApplicationMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an ApplicationMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ApplicationMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): ApplicationMetadata;
+
+    /**
+     * Creates a plain object from an ApplicationMetadata message. Also converts values to other types if specified.
+     * @param message ApplicationMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ApplicationMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ApplicationMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a WorkingGroupMetadata. */
+export interface IWorkingGroupMetadata {
+
+    /** WorkingGroupMetadata description */
+    description?: (string|null);
+
+    /** WorkingGroupMetadata about */
+    about?: (string|null);
+
+    /** WorkingGroupMetadata status */
+    status?: (string|null);
+
+    /** WorkingGroupMetadata statusMessage */
+    statusMessage?: (string|null);
+}
+
+/** Represents a WorkingGroupMetadata. */
+export class WorkingGroupMetadata implements IWorkingGroupMetadata {
+
+    /**
+     * Constructs a new WorkingGroupMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IWorkingGroupMetadata);
+
+    /** WorkingGroupMetadata description. */
+    public description: string;
+
+    /** WorkingGroupMetadata about. */
+    public about: string;
+
+    /** WorkingGroupMetadata status. */
+    public status: string;
+
+    /** WorkingGroupMetadata statusMessage. */
+    public statusMessage: string;
+
+    /**
+     * Creates a new WorkingGroupMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns WorkingGroupMetadata instance
+     */
+    public static create(properties?: IWorkingGroupMetadata): WorkingGroupMetadata;
+
+    /**
+     * Encodes the specified WorkingGroupMetadata message. Does not implicitly {@link WorkingGroupMetadata.verify|verify} messages.
+     * @param message WorkingGroupMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IWorkingGroupMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified WorkingGroupMetadata message, length delimited. Does not implicitly {@link WorkingGroupMetadata.verify|verify} messages.
+     * @param message WorkingGroupMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IWorkingGroupMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a WorkingGroupMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns WorkingGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): WorkingGroupMetadata;
+
+    /**
+     * Decodes a WorkingGroupMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns WorkingGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): WorkingGroupMetadata;
+
+    /**
+     * Verifies a WorkingGroupMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a WorkingGroupMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns WorkingGroupMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): WorkingGroupMetadata;
+
+    /**
+     * Creates a plain object from a WorkingGroupMetadata message. Also converts values to other types if specified.
+     * @param message WorkingGroupMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: WorkingGroupMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this WorkingGroupMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a SetGroupMetadata. */
+export interface ISetGroupMetadata {
+
+    /** SetGroupMetadata newMetadata */
+    newMetadata?: (IWorkingGroupMetadata|null);
+}
+
+/** Represents a SetGroupMetadata. */
+export class SetGroupMetadata implements ISetGroupMetadata {
+
+    /**
+     * Constructs a new SetGroupMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ISetGroupMetadata);
+
+    /** SetGroupMetadata newMetadata. */
+    public newMetadata?: (IWorkingGroupMetadata|null);
+
+    /**
+     * Creates a new SetGroupMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns SetGroupMetadata instance
+     */
+    public static create(properties?: ISetGroupMetadata): SetGroupMetadata;
+
+    /**
+     * Encodes the specified SetGroupMetadata message. Does not implicitly {@link SetGroupMetadata.verify|verify} messages.
+     * @param message SetGroupMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ISetGroupMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified SetGroupMetadata message, length delimited. Does not implicitly {@link SetGroupMetadata.verify|verify} messages.
+     * @param message SetGroupMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ISetGroupMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a SetGroupMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns SetGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SetGroupMetadata;
+
+    /**
+     * Decodes a SetGroupMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns SetGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SetGroupMetadata;
+
+    /**
+     * Verifies a SetGroupMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a SetGroupMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns SetGroupMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): SetGroupMetadata;
+
+    /**
+     * Creates a plain object from a SetGroupMetadata message. Also converts values to other types if specified.
+     * @param message SetGroupMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: SetGroupMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this SetGroupMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an AddUpcomingOpening. */
+export interface IAddUpcomingOpening {
+
+    /** AddUpcomingOpening metadata */
+    metadata?: (IUpcomingOpeningMetadata|null);
+}
+
+/** Represents an AddUpcomingOpening. */
+export class AddUpcomingOpening implements IAddUpcomingOpening {
+
+    /**
+     * Constructs a new AddUpcomingOpening.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IAddUpcomingOpening);
+
+    /** AddUpcomingOpening metadata. */
+    public metadata?: (IUpcomingOpeningMetadata|null);
+
+    /**
+     * Creates a new AddUpcomingOpening instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns AddUpcomingOpening instance
+     */
+    public static create(properties?: IAddUpcomingOpening): AddUpcomingOpening;
+
+    /**
+     * Encodes the specified AddUpcomingOpening message. Does not implicitly {@link AddUpcomingOpening.verify|verify} messages.
+     * @param message AddUpcomingOpening message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IAddUpcomingOpening, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified AddUpcomingOpening message, length delimited. Does not implicitly {@link AddUpcomingOpening.verify|verify} messages.
+     * @param message AddUpcomingOpening message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IAddUpcomingOpening, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an AddUpcomingOpening message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns AddUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): AddUpcomingOpening;
+
+    /**
+     * Decodes an AddUpcomingOpening message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns AddUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): AddUpcomingOpening;
+
+    /**
+     * Verifies an AddUpcomingOpening message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an AddUpcomingOpening message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns AddUpcomingOpening
+     */
+    public static fromObject(object: { [k: string]: any }): AddUpcomingOpening;
+
+    /**
+     * Creates a plain object from an AddUpcomingOpening message. Also converts values to other types if specified.
+     * @param message AddUpcomingOpening
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: AddUpcomingOpening, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this AddUpcomingOpening to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a RemoveUpcomingOpening. */
+export interface IRemoveUpcomingOpening {
+
+    /** RemoveUpcomingOpening id */
+    id?: (string|null);
+}
+
+/** Represents a RemoveUpcomingOpening. */
+export class RemoveUpcomingOpening implements IRemoveUpcomingOpening {
+
+    /**
+     * Constructs a new RemoveUpcomingOpening.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IRemoveUpcomingOpening);
+
+    /** RemoveUpcomingOpening id. */
+    public id: string;
+
+    /**
+     * Creates a new RemoveUpcomingOpening instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns RemoveUpcomingOpening instance
+     */
+    public static create(properties?: IRemoveUpcomingOpening): RemoveUpcomingOpening;
+
+    /**
+     * Encodes the specified RemoveUpcomingOpening message. Does not implicitly {@link RemoveUpcomingOpening.verify|verify} messages.
+     * @param message RemoveUpcomingOpening message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IRemoveUpcomingOpening, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified RemoveUpcomingOpening message, length delimited. Does not implicitly {@link RemoveUpcomingOpening.verify|verify} messages.
+     * @param message RemoveUpcomingOpening message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IRemoveUpcomingOpening, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a RemoveUpcomingOpening message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns RemoveUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): RemoveUpcomingOpening;
+
+    /**
+     * Decodes a RemoveUpcomingOpening message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns RemoveUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): RemoveUpcomingOpening;
+
+    /**
+     * Verifies a RemoveUpcomingOpening message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a RemoveUpcomingOpening message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns RemoveUpcomingOpening
+     */
+    public static fromObject(object: { [k: string]: any }): RemoveUpcomingOpening;
+
+    /**
+     * Creates a plain object from a RemoveUpcomingOpening message. Also converts values to other types if specified.
+     * @param message RemoveUpcomingOpening
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: RemoveUpcomingOpening, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this RemoveUpcomingOpening to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a WorkingGroupMetadataAction. */
+export interface IWorkingGroupMetadataAction {
+
+    /** WorkingGroupMetadataAction setGroupMetadata */
+    setGroupMetadata?: (ISetGroupMetadata|null);
+
+    /** WorkingGroupMetadataAction addUpcomingOpening */
+    addUpcomingOpening?: (IAddUpcomingOpening|null);
+
+    /** WorkingGroupMetadataAction removeUpcomingOpening */
+    removeUpcomingOpening?: (IRemoveUpcomingOpening|null);
+}
+
+/** Represents a WorkingGroupMetadataAction. */
+export class WorkingGroupMetadataAction implements IWorkingGroupMetadataAction {
+
+    /**
+     * Constructs a new WorkingGroupMetadataAction.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IWorkingGroupMetadataAction);
+
+    /** WorkingGroupMetadataAction setGroupMetadata. */
+    public setGroupMetadata?: (ISetGroupMetadata|null);
+
+    /** WorkingGroupMetadataAction addUpcomingOpening. */
+    public addUpcomingOpening?: (IAddUpcomingOpening|null);
+
+    /** WorkingGroupMetadataAction removeUpcomingOpening. */
+    public removeUpcomingOpening?: (IRemoveUpcomingOpening|null);
+
+    /** WorkingGroupMetadataAction action. */
+    public action?: ("setGroupMetadata"|"addUpcomingOpening"|"removeUpcomingOpening");
+
+    /**
+     * Creates a new WorkingGroupMetadataAction instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns WorkingGroupMetadataAction instance
+     */
+    public static create(properties?: IWorkingGroupMetadataAction): WorkingGroupMetadataAction;
+
+    /**
+     * Encodes the specified WorkingGroupMetadataAction message. Does not implicitly {@link WorkingGroupMetadataAction.verify|verify} messages.
+     * @param message WorkingGroupMetadataAction message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IWorkingGroupMetadataAction, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified WorkingGroupMetadataAction message, length delimited. Does not implicitly {@link WorkingGroupMetadataAction.verify|verify} messages.
+     * @param message WorkingGroupMetadataAction message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IWorkingGroupMetadataAction, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a WorkingGroupMetadataAction message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns WorkingGroupMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): WorkingGroupMetadataAction;
+
+    /**
+     * Decodes a WorkingGroupMetadataAction message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns WorkingGroupMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): WorkingGroupMetadataAction;
+
+    /**
+     * Verifies a WorkingGroupMetadataAction message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a WorkingGroupMetadataAction message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns WorkingGroupMetadataAction
+     */
+    public static fromObject(object: { [k: string]: any }): WorkingGroupMetadataAction;
+
+    /**
+     * Creates a plain object from a WorkingGroupMetadataAction message. Also converts values to other types if specified.
+     * @param message WorkingGroupMetadataAction
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: WorkingGroupMetadataAction, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this WorkingGroupMetadataAction to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a ModeratePost. */
+export interface IModeratePost {
+
+    /** ModeratePost postId */
+    postId: Long;
+
+    /** ModeratePost rationale */
+    rationale: string;
+}
+
+/** Represents a ModeratePost. */
+export class ModeratePost implements IModeratePost {
+
+    /**
+     * Constructs a new ModeratePost.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IModeratePost);
+
+    /** ModeratePost postId. */
+    public postId: Long;
+
+    /** ModeratePost rationale. */
+    public rationale: string;
+
+    /**
+     * Creates a new ModeratePost instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns ModeratePost instance
+     */
+    public static create(properties?: IModeratePost): ModeratePost;
+
+    /**
+     * Encodes the specified ModeratePost message. Does not implicitly {@link ModeratePost.verify|verify} messages.
+     * @param message ModeratePost message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IModeratePost, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified ModeratePost message, length delimited. Does not implicitly {@link ModeratePost.verify|verify} messages.
+     * @param message ModeratePost message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IModeratePost, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a ModeratePost message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns ModeratePost
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ModeratePost;
+
+    /**
+     * Decodes a ModeratePost message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns ModeratePost
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ModeratePost;
+
+    /**
+     * Verifies a ModeratePost message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a ModeratePost message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns ModeratePost
+     */
+    public static fromObject(object: { [k: string]: any }): ModeratePost;
+
+    /**
+     * Creates a plain object from a ModeratePost message. Also converts values to other types if specified.
+     * @param message ModeratePost
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: ModeratePost, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this ModeratePost to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a RemarkMetadataAction. */
+export interface IRemarkMetadataAction {
+
+    /** RemarkMetadataAction moderatePost */
+    moderatePost?: (IModeratePost|null);
+}
+
+/** Represents a RemarkMetadataAction. */
+export class RemarkMetadataAction implements IRemarkMetadataAction {
+
+    /**
+     * Constructs a new RemarkMetadataAction.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IRemarkMetadataAction);
+
+    /** RemarkMetadataAction moderatePost. */
+    public moderatePost?: (IModeratePost|null);
+
+    /** RemarkMetadataAction action. */
+    public action?: "moderatePost";
+
+    /**
+     * Creates a new RemarkMetadataAction instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns RemarkMetadataAction instance
+     */
+    public static create(properties?: IRemarkMetadataAction): RemarkMetadataAction;
+
+    /**
+     * Encodes the specified RemarkMetadataAction message. Does not implicitly {@link RemarkMetadataAction.verify|verify} messages.
+     * @param message RemarkMetadataAction message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IRemarkMetadataAction, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified RemarkMetadataAction message, length delimited. Does not implicitly {@link RemarkMetadataAction.verify|verify} messages.
+     * @param message RemarkMetadataAction message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IRemarkMetadataAction, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a RemarkMetadataAction message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns RemarkMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): RemarkMetadataAction;
+
+    /**
+     * Decodes a RemarkMetadataAction message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns RemarkMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): RemarkMetadataAction;
+
+    /**
+     * Verifies a RemarkMetadataAction message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a RemarkMetadataAction message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns RemarkMetadataAction
+     */
+    public static fromObject(object: { [k: string]: any }): RemarkMetadataAction;
+
+    /**
+     * Creates a plain object from a RemarkMetadataAction message. Also converts values to other types if specified.
+     * @param message RemarkMetadataAction
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: RemarkMetadataAction, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this RemarkMetadataAction to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
diff --git a/node_modules/@joystream/metadata-protobuf/compiled/compiled/index.js b/node_modules/@joystream/metadata-protobuf/compiled/compiled/index.js
new file mode 100644
index 0000000..f4f8d2e
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/compiled/compiled/index.js
@@ -0,0 +1,16346 @@
+/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
+"use strict";
+
+var $protobuf = require("protobufjs/minimal");
+
+// Common aliases
+var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
+
+// Exported root namespace
+var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
+
+$root.AppActionMetadata = (function() {
+
+    /**
+     * Properties of an AppActionMetadata.
+     * @exports IAppActionMetadata
+     * @interface IAppActionMetadata
+     * @property {string|null} [videoId] AppActionMetadata videoId
+     */
+
+    /**
+     * Constructs a new AppActionMetadata.
+     * @exports AppActionMetadata
+     * @classdesc Represents an AppActionMetadata.
+     * @implements IAppActionMetadata
+     * @constructor
+     * @param {IAppActionMetadata=} [properties] Properties to set
+     */
+    function AppActionMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * AppActionMetadata videoId.
+     * @member {string} videoId
+     * @memberof AppActionMetadata
+     * @instance
+     */
+    AppActionMetadata.prototype.videoId = "";
+
+    /**
+     * Creates a new AppActionMetadata instance using the specified properties.
+     * @function create
+     * @memberof AppActionMetadata
+     * @static
+     * @param {IAppActionMetadata=} [properties] Properties to set
+     * @returns {AppActionMetadata} AppActionMetadata instance
+     */
+    AppActionMetadata.create = function create(properties) {
+        return new AppActionMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified AppActionMetadata message. Does not implicitly {@link AppActionMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof AppActionMetadata
+     * @static
+     * @param {IAppActionMetadata} message AppActionMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AppActionMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.videoId);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified AppActionMetadata message, length delimited. Does not implicitly {@link AppActionMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof AppActionMetadata
+     * @static
+     * @param {IAppActionMetadata} message AppActionMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AppActionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an AppActionMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof AppActionMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {AppActionMetadata} AppActionMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AppActionMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppActionMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 2:
+                message.videoId = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes an AppActionMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof AppActionMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {AppActionMetadata} AppActionMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AppActionMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an AppActionMetadata message.
+     * @function verify
+     * @memberof AppActionMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    AppActionMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.videoId != null && message.hasOwnProperty("videoId"))
+            if (!$util.isString(message.videoId))
+                return "videoId: string expected";
+        return null;
+    };
+
+    /**
+     * Creates an AppActionMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof AppActionMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {AppActionMetadata} AppActionMetadata
+     */
+    AppActionMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.AppActionMetadata)
+            return object;
+        var message = new $root.AppActionMetadata();
+        if (object.videoId != null)
+            message.videoId = String(object.videoId);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an AppActionMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof AppActionMetadata
+     * @static
+     * @param {AppActionMetadata} message AppActionMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    AppActionMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.videoId = "";
+        if (message.videoId != null && message.hasOwnProperty("videoId"))
+            object.videoId = message.videoId;
+        return object;
+    };
+
+    /**
+     * Converts this AppActionMetadata to JSON.
+     * @function toJSON
+     * @memberof AppActionMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    AppActionMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return AppActionMetadata;
+})();
+
+$root.AppAction = (function() {
+
+    /**
+     * Properties of an AppAction.
+     * @exports IAppAction
+     * @interface IAppAction
+     * @property {string} appId AppAction appId
+     * @property {Uint8Array|null} [metadata] AppAction metadata
+     * @property {Uint8Array|null} [rawAction] AppAction rawAction
+     * @property {Uint8Array|null} [signature] AppAction signature
+     */
+
+    /**
+     * Constructs a new AppAction.
+     * @exports AppAction
+     * @classdesc Represents an AppAction.
+     * @implements IAppAction
+     * @constructor
+     * @param {IAppAction=} [properties] Properties to set
+     */
+    function AppAction(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * AppAction appId.
+     * @member {string} appId
+     * @memberof AppAction
+     * @instance
+     */
+    AppAction.prototype.appId = "";
+
+    /**
+     * AppAction metadata.
+     * @member {Uint8Array} metadata
+     * @memberof AppAction
+     * @instance
+     */
+    AppAction.prototype.metadata = $util.newBuffer([]);
+
+    /**
+     * AppAction rawAction.
+     * @member {Uint8Array} rawAction
+     * @memberof AppAction
+     * @instance
+     */
+    AppAction.prototype.rawAction = $util.newBuffer([]);
+
+    /**
+     * AppAction signature.
+     * @member {Uint8Array} signature
+     * @memberof AppAction
+     * @instance
+     */
+    AppAction.prototype.signature = $util.newBuffer([]);
+
+    /**
+     * Creates a new AppAction instance using the specified properties.
+     * @function create
+     * @memberof AppAction
+     * @static
+     * @param {IAppAction=} [properties] Properties to set
+     * @returns {AppAction} AppAction instance
+     */
+    AppAction.create = function create(properties) {
+        return new AppAction(properties);
+    };
+
+    /**
+     * Encodes the specified AppAction message. Does not implicitly {@link AppAction.verify|verify} messages.
+     * @function encode
+     * @memberof AppAction
+     * @static
+     * @param {IAppAction} message AppAction message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AppAction.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
+            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.metadata);
+        if (message.rawAction != null && Object.hasOwnProperty.call(message, "rawAction"))
+            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rawAction);
+        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
+            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
+        writer.uint32(/* id 999, wireType 2 =*/7994).string(message.appId);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified AppAction message, length delimited. Does not implicitly {@link AppAction.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof AppAction
+     * @static
+     * @param {IAppAction} message AppAction message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AppAction.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an AppAction message from the specified reader or buffer.
+     * @function decode
+     * @memberof AppAction
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {AppAction} AppAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AppAction.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppAction();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 999:
+                message.appId = reader.string();
+                break;
+            case 2:
+                message.metadata = reader.bytes();
+                break;
+            case 3:
+                message.rawAction = reader.bytes();
+                break;
+            case 4:
+                message.signature = reader.bytes();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("appId"))
+            throw $util.ProtocolError("missing required 'appId'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes an AppAction message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof AppAction
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {AppAction} AppAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AppAction.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an AppAction message.
+     * @function verify
+     * @memberof AppAction
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    AppAction.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.appId))
+            return "appId: string expected";
+        if (message.metadata != null && message.hasOwnProperty("metadata"))
+            if (!(message.metadata && typeof message.metadata.length === "number" || $util.isString(message.metadata)))
+                return "metadata: buffer expected";
+        if (message.rawAction != null && message.hasOwnProperty("rawAction"))
+            if (!(message.rawAction && typeof message.rawAction.length === "number" || $util.isString(message.rawAction)))
+                return "rawAction: buffer expected";
+        if (message.signature != null && message.hasOwnProperty("signature"))
+            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
+                return "signature: buffer expected";
+        return null;
+    };
+
+    /**
+     * Creates an AppAction message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof AppAction
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {AppAction} AppAction
+     */
+    AppAction.fromObject = function fromObject(object) {
+        if (object instanceof $root.AppAction)
+            return object;
+        var message = new $root.AppAction();
+        if (object.appId != null)
+            message.appId = String(object.appId);
+        if (object.metadata != null)
+            if (typeof object.metadata === "string")
+                $util.base64.decode(object.metadata, message.metadata = $util.newBuffer($util.base64.length(object.metadata)), 0);
+            else if (object.metadata.length)
+                message.metadata = object.metadata;
+        if (object.rawAction != null)
+            if (typeof object.rawAction === "string")
+                $util.base64.decode(object.rawAction, message.rawAction = $util.newBuffer($util.base64.length(object.rawAction)), 0);
+            else if (object.rawAction.length)
+                message.rawAction = object.rawAction;
+        if (object.signature != null)
+            if (typeof object.signature === "string")
+                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
+            else if (object.signature.length)
+                message.signature = object.signature;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an AppAction message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof AppAction
+     * @static
+     * @param {AppAction} message AppAction
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    AppAction.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            if (options.bytes === String)
+                object.metadata = "";
+            else {
+                object.metadata = [];
+                if (options.bytes !== Array)
+                    object.metadata = $util.newBuffer(object.metadata);
+            }
+            if (options.bytes === String)
+                object.rawAction = "";
+            else {
+                object.rawAction = [];
+                if (options.bytes !== Array)
+                    object.rawAction = $util.newBuffer(object.rawAction);
+            }
+            if (options.bytes === String)
+                object.signature = "";
+            else {
+                object.signature = [];
+                if (options.bytes !== Array)
+                    object.signature = $util.newBuffer(object.signature);
+            }
+            object.appId = "";
+        }
+        if (message.metadata != null && message.hasOwnProperty("metadata"))
+            object.metadata = options.bytes === String ? $util.base64.encode(message.metadata, 0, message.metadata.length) : options.bytes === Array ? Array.prototype.slice.call(message.metadata) : message.metadata;
+        if (message.rawAction != null && message.hasOwnProperty("rawAction"))
+            object.rawAction = options.bytes === String ? $util.base64.encode(message.rawAction, 0, message.rawAction.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawAction) : message.rawAction;
+        if (message.signature != null && message.hasOwnProperty("signature"))
+            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
+        if (message.appId != null && message.hasOwnProperty("appId"))
+            object.appId = message.appId;
+        return object;
+    };
+
+    /**
+     * Converts this AppAction to JSON.
+     * @function toJSON
+     * @memberof AppAction
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    AppAction.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    /**
+     * ActionType enum.
+     * @name AppAction.ActionType
+     * @enum {number}
+     * @property {number} CREATE_VIDEO=0 CREATE_VIDEO value
+     * @property {number} CREATE_CHANNEL=1 CREATE_CHANNEL value
+     */
+    AppAction.ActionType = (function() {
+        var valuesById = {}, values = Object.create(valuesById);
+        values[valuesById[0] = "CREATE_VIDEO"] = 0;
+        values[valuesById[1] = "CREATE_CHANNEL"] = 1;
+        return values;
+    })();
+
+    /**
+     * CreatorType enum.
+     * @name AppAction.CreatorType
+     * @enum {number}
+     * @property {number} CHANNEL=0 CHANNEL value
+     * @property {number} MEMBER=1 MEMBER value
+     * @property {number} CURATOR_GROUP=2 CURATOR_GROUP value
+     */
+    AppAction.CreatorType = (function() {
+        var valuesById = {}, values = Object.create(valuesById);
+        values[valuesById[0] = "CHANNEL"] = 0;
+        values[valuesById[1] = "MEMBER"] = 1;
+        values[valuesById[2] = "CURATOR_GROUP"] = 2;
+        return values;
+    })();
+
+    return AppAction;
+})();
+
+$root.BountyMetadata = (function() {
+
+    /**
+     * Properties of a BountyMetadata.
+     * @exports IBountyMetadata
+     * @interface IBountyMetadata
+     * @property {string|null} [title] BountyMetadata title
+     * @property {string|null} [description] BountyMetadata description
+     * @property {Long|null} [discussionThread] BountyMetadata discussionThread
+     * @property {string|null} [bannerImageUri] BountyMetadata bannerImageUri
+     */
+
+    /**
+     * Constructs a new BountyMetadata.
+     * @exports BountyMetadata
+     * @classdesc Represents a BountyMetadata.
+     * @implements IBountyMetadata
+     * @constructor
+     * @param {IBountyMetadata=} [properties] Properties to set
+     */
+    function BountyMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * BountyMetadata title.
+     * @member {string} title
+     * @memberof BountyMetadata
+     * @instance
+     */
+    BountyMetadata.prototype.title = "";
+
+    /**
+     * BountyMetadata description.
+     * @member {string} description
+     * @memberof BountyMetadata
+     * @instance
+     */
+    BountyMetadata.prototype.description = "";
+
+    /**
+     * BountyMetadata discussionThread.
+     * @member {Long} discussionThread
+     * @memberof BountyMetadata
+     * @instance
+     */
+    BountyMetadata.prototype.discussionThread = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * BountyMetadata bannerImageUri.
+     * @member {string} bannerImageUri
+     * @memberof BountyMetadata
+     * @instance
+     */
+    BountyMetadata.prototype.bannerImageUri = "";
+
+    /**
+     * Creates a new BountyMetadata instance using the specified properties.
+     * @function create
+     * @memberof BountyMetadata
+     * @static
+     * @param {IBountyMetadata=} [properties] Properties to set
+     * @returns {BountyMetadata} BountyMetadata instance
+     */
+    BountyMetadata.create = function create(properties) {
+        return new BountyMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified BountyMetadata message. Does not implicitly {@link BountyMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof BountyMetadata
+     * @static
+     * @param {IBountyMetadata} message BountyMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    BountyMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.discussionThread != null && Object.hasOwnProperty.call(message, "discussionThread"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.discussionThread);
+        if (message.bannerImageUri != null && Object.hasOwnProperty.call(message, "bannerImageUri"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.bannerImageUri);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified BountyMetadata message, length delimited. Does not implicitly {@link BountyMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof BountyMetadata
+     * @static
+     * @param {IBountyMetadata} message BountyMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    BountyMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a BountyMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof BountyMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {BountyMetadata} BountyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    BountyMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BountyMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.discussionThread = reader.uint64();
+                break;
+            case 4:
+                message.bannerImageUri = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a BountyMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof BountyMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {BountyMetadata} BountyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    BountyMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a BountyMetadata message.
+     * @function verify
+     * @memberof BountyMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    BountyMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.discussionThread != null && message.hasOwnProperty("discussionThread"))
+            if (!$util.isInteger(message.discussionThread) && !(message.discussionThread && $util.isInteger(message.discussionThread.low) && $util.isInteger(message.discussionThread.high)))
+                return "discussionThread: integer|Long expected";
+        if (message.bannerImageUri != null && message.hasOwnProperty("bannerImageUri"))
+            if (!$util.isString(message.bannerImageUri))
+                return "bannerImageUri: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a BountyMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof BountyMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {BountyMetadata} BountyMetadata
+     */
+    BountyMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.BountyMetadata)
+            return object;
+        var message = new $root.BountyMetadata();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.discussionThread != null)
+            if ($util.Long)
+                (message.discussionThread = $util.Long.fromValue(object.discussionThread)).unsigned = true;
+            else if (typeof object.discussionThread === "string")
+                message.discussionThread = parseInt(object.discussionThread, 10);
+            else if (typeof object.discussionThread === "number")
+                message.discussionThread = object.discussionThread;
+            else if (typeof object.discussionThread === "object")
+                message.discussionThread = new $util.LongBits(object.discussionThread.low >>> 0, object.discussionThread.high >>> 0).toNumber(true);
+        if (object.bannerImageUri != null)
+            message.bannerImageUri = String(object.bannerImageUri);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a BountyMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof BountyMetadata
+     * @static
+     * @param {BountyMetadata} message BountyMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    BountyMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.discussionThread = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.discussionThread = options.longs === String ? "0" : 0;
+            object.bannerImageUri = "";
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.discussionThread != null && message.hasOwnProperty("discussionThread"))
+            if (typeof message.discussionThread === "number")
+                object.discussionThread = options.longs === String ? String(message.discussionThread) : message.discussionThread;
+            else
+                object.discussionThread = options.longs === String ? $util.Long.prototype.toString.call(message.discussionThread) : options.longs === Number ? new $util.LongBits(message.discussionThread.low >>> 0, message.discussionThread.high >>> 0).toNumber(true) : message.discussionThread;
+        if (message.bannerImageUri != null && message.hasOwnProperty("bannerImageUri"))
+            object.bannerImageUri = message.bannerImageUri;
+        return object;
+    };
+
+    /**
+     * Converts this BountyMetadata to JSON.
+     * @function toJSON
+     * @memberof BountyMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    BountyMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return BountyMetadata;
+})();
+
+$root.BountyWorkData = (function() {
+
+    /**
+     * Properties of a BountyWorkData.
+     * @exports IBountyWorkData
+     * @interface IBountyWorkData
+     * @property {string|null} [title] BountyWorkData title
+     * @property {string|null} [description] BountyWorkData description
+     */
+
+    /**
+     * Constructs a new BountyWorkData.
+     * @exports BountyWorkData
+     * @classdesc Represents a BountyWorkData.
+     * @implements IBountyWorkData
+     * @constructor
+     * @param {IBountyWorkData=} [properties] Properties to set
+     */
+    function BountyWorkData(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * BountyWorkData title.
+     * @member {string} title
+     * @memberof BountyWorkData
+     * @instance
+     */
+    BountyWorkData.prototype.title = "";
+
+    /**
+     * BountyWorkData description.
+     * @member {string} description
+     * @memberof BountyWorkData
+     * @instance
+     */
+    BountyWorkData.prototype.description = "";
+
+    /**
+     * Creates a new BountyWorkData instance using the specified properties.
+     * @function create
+     * @memberof BountyWorkData
+     * @static
+     * @param {IBountyWorkData=} [properties] Properties to set
+     * @returns {BountyWorkData} BountyWorkData instance
+     */
+    BountyWorkData.create = function create(properties) {
+        return new BountyWorkData(properties);
+    };
+
+    /**
+     * Encodes the specified BountyWorkData message. Does not implicitly {@link BountyWorkData.verify|verify} messages.
+     * @function encode
+     * @memberof BountyWorkData
+     * @static
+     * @param {IBountyWorkData} message BountyWorkData message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    BountyWorkData.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified BountyWorkData message, length delimited. Does not implicitly {@link BountyWorkData.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof BountyWorkData
+     * @static
+     * @param {IBountyWorkData} message BountyWorkData message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    BountyWorkData.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a BountyWorkData message from the specified reader or buffer.
+     * @function decode
+     * @memberof BountyWorkData
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {BountyWorkData} BountyWorkData
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    BountyWorkData.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BountyWorkData();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a BountyWorkData message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof BountyWorkData
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {BountyWorkData} BountyWorkData
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    BountyWorkData.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a BountyWorkData message.
+     * @function verify
+     * @memberof BountyWorkData
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    BountyWorkData.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a BountyWorkData message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof BountyWorkData
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {BountyWorkData} BountyWorkData
+     */
+    BountyWorkData.fromObject = function fromObject(object) {
+        if (object instanceof $root.BountyWorkData)
+            return object;
+        var message = new $root.BountyWorkData();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a BountyWorkData message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof BountyWorkData
+     * @static
+     * @param {BountyWorkData} message BountyWorkData
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    BountyWorkData.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        return object;
+    };
+
+    /**
+     * Converts this BountyWorkData to JSON.
+     * @function toJSON
+     * @memberof BountyWorkData
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    BountyWorkData.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return BountyWorkData;
+})();
+
+$root.ChannelMetadata = (function() {
+
+    /**
+     * Properties of a ChannelMetadata.
+     * @exports IChannelMetadata
+     * @interface IChannelMetadata
+     * @property {string|null} [title] ChannelMetadata title
+     * @property {string|null} [description] ChannelMetadata description
+     * @property {boolean|null} [isPublic] ChannelMetadata isPublic
+     * @property {string|null} [language] ChannelMetadata language
+     * @property {number|null} [coverPhoto] ChannelMetadata coverPhoto
+     * @property {number|null} [avatarPhoto] ChannelMetadata avatarPhoto
+     */
+
+    /**
+     * Constructs a new ChannelMetadata.
+     * @exports ChannelMetadata
+     * @classdesc Represents a ChannelMetadata.
+     * @implements IChannelMetadata
+     * @constructor
+     * @param {IChannelMetadata=} [properties] Properties to set
+     */
+    function ChannelMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ChannelMetadata title.
+     * @member {string} title
+     * @memberof ChannelMetadata
+     * @instance
+     */
+    ChannelMetadata.prototype.title = "";
+
+    /**
+     * ChannelMetadata description.
+     * @member {string} description
+     * @memberof ChannelMetadata
+     * @instance
+     */
+    ChannelMetadata.prototype.description = "";
+
+    /**
+     * ChannelMetadata isPublic.
+     * @member {boolean} isPublic
+     * @memberof ChannelMetadata
+     * @instance
+     */
+    ChannelMetadata.prototype.isPublic = false;
+
+    /**
+     * ChannelMetadata language.
+     * @member {string} language
+     * @memberof ChannelMetadata
+     * @instance
+     */
+    ChannelMetadata.prototype.language = "";
+
+    /**
+     * ChannelMetadata coverPhoto.
+     * @member {number} coverPhoto
+     * @memberof ChannelMetadata
+     * @instance
+     */
+    ChannelMetadata.prototype.coverPhoto = 0;
+
+    /**
+     * ChannelMetadata avatarPhoto.
+     * @member {number} avatarPhoto
+     * @memberof ChannelMetadata
+     * @instance
+     */
+    ChannelMetadata.prototype.avatarPhoto = 0;
+
+    /**
+     * Creates a new ChannelMetadata instance using the specified properties.
+     * @function create
+     * @memberof ChannelMetadata
+     * @static
+     * @param {IChannelMetadata=} [properties] Properties to set
+     * @returns {ChannelMetadata} ChannelMetadata instance
+     */
+    ChannelMetadata.create = function create(properties) {
+        return new ChannelMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified ChannelMetadata message. Does not implicitly {@link ChannelMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof ChannelMetadata
+     * @static
+     * @param {IChannelMetadata} message ChannelMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.isPublic != null && Object.hasOwnProperty.call(message, "isPublic"))
+            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isPublic);
+        if (message.language != null && Object.hasOwnProperty.call(message, "language"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.language);
+        if (message.coverPhoto != null && Object.hasOwnProperty.call(message, "coverPhoto"))
+            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.coverPhoto);
+        if (message.avatarPhoto != null && Object.hasOwnProperty.call(message, "avatarPhoto"))
+            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.avatarPhoto);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ChannelMetadata message, length delimited. Does not implicitly {@link ChannelMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ChannelMetadata
+     * @static
+     * @param {IChannelMetadata} message ChannelMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ChannelMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof ChannelMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ChannelMetadata} ChannelMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.isPublic = reader.bool();
+                break;
+            case 4:
+                message.language = reader.string();
+                break;
+            case 5:
+                message.coverPhoto = reader.uint32();
+                break;
+            case 6:
+                message.avatarPhoto = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a ChannelMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ChannelMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ChannelMetadata} ChannelMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ChannelMetadata message.
+     * @function verify
+     * @memberof ChannelMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ChannelMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.isPublic != null && message.hasOwnProperty("isPublic"))
+            if (typeof message.isPublic !== "boolean")
+                return "isPublic: boolean expected";
+        if (message.language != null && message.hasOwnProperty("language"))
+            if (!$util.isString(message.language))
+                return "language: string expected";
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            if (!$util.isInteger(message.coverPhoto))
+                return "coverPhoto: integer expected";
+        if (message.avatarPhoto != null && message.hasOwnProperty("avatarPhoto"))
+            if (!$util.isInteger(message.avatarPhoto))
+                return "avatarPhoto: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a ChannelMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ChannelMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ChannelMetadata} ChannelMetadata
+     */
+    ChannelMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.ChannelMetadata)
+            return object;
+        var message = new $root.ChannelMetadata();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.isPublic != null)
+            message.isPublic = Boolean(object.isPublic);
+        if (object.language != null)
+            message.language = String(object.language);
+        if (object.coverPhoto != null)
+            message.coverPhoto = object.coverPhoto >>> 0;
+        if (object.avatarPhoto != null)
+            message.avatarPhoto = object.avatarPhoto >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ChannelMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ChannelMetadata
+     * @static
+     * @param {ChannelMetadata} message ChannelMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ChannelMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            object.isPublic = false;
+            object.language = "";
+            object.coverPhoto = 0;
+            object.avatarPhoto = 0;
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.isPublic != null && message.hasOwnProperty("isPublic"))
+            object.isPublic = message.isPublic;
+        if (message.language != null && message.hasOwnProperty("language"))
+            object.language = message.language;
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            object.coverPhoto = message.coverPhoto;
+        if (message.avatarPhoto != null && message.hasOwnProperty("avatarPhoto"))
+            object.avatarPhoto = message.avatarPhoto;
+        return object;
+    };
+
+    /**
+     * Converts this ChannelMetadata to JSON.
+     * @function toJSON
+     * @memberof ChannelMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ChannelMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ChannelMetadata;
+})();
+
+$root.ChannelPayoutsMetadata = (function() {
+
+    /**
+     * Properties of a ChannelPayoutsMetadata.
+     * @exports IChannelPayoutsMetadata
+     * @interface IChannelPayoutsMetadata
+     * @property {ChannelPayoutsMetadata.IHeader} header ChannelPayoutsMetadata header
+     * @property {ChannelPayoutsMetadata.IBody} body ChannelPayoutsMetadata body
+     */
+
+    /**
+     * Constructs a new ChannelPayoutsMetadata.
+     * @exports ChannelPayoutsMetadata
+     * @classdesc Represents a ChannelPayoutsMetadata.
+     * @implements IChannelPayoutsMetadata
+     * @constructor
+     * @param {IChannelPayoutsMetadata=} [properties] Properties to set
+     */
+    function ChannelPayoutsMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ChannelPayoutsMetadata header.
+     * @member {ChannelPayoutsMetadata.IHeader} header
+     * @memberof ChannelPayoutsMetadata
+     * @instance
+     */
+    ChannelPayoutsMetadata.prototype.header = null;
+
+    /**
+     * ChannelPayoutsMetadata body.
+     * @member {ChannelPayoutsMetadata.IBody} body
+     * @memberof ChannelPayoutsMetadata
+     * @instance
+     */
+    ChannelPayoutsMetadata.prototype.body = null;
+
+    /**
+     * Creates a new ChannelPayoutsMetadata instance using the specified properties.
+     * @function create
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {IChannelPayoutsMetadata=} [properties] Properties to set
+     * @returns {ChannelPayoutsMetadata} ChannelPayoutsMetadata instance
+     */
+    ChannelPayoutsMetadata.create = function create(properties) {
+        return new ChannelPayoutsMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified ChannelPayoutsMetadata message. Does not implicitly {@link ChannelPayoutsMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {IChannelPayoutsMetadata} message ChannelPayoutsMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelPayoutsMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        $root.ChannelPayoutsMetadata.Header.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        $root.ChannelPayoutsMetadata.Body.encode(message.body, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ChannelPayoutsMetadata message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {IChannelPayoutsMetadata} message ChannelPayoutsMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelPayoutsMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ChannelPayoutsMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ChannelPayoutsMetadata} ChannelPayoutsMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelPayoutsMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelPayoutsMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.header = $root.ChannelPayoutsMetadata.Header.decode(reader, reader.uint32());
+                break;
+            case 2:
+                message.body = $root.ChannelPayoutsMetadata.Body.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("header"))
+            throw $util.ProtocolError("missing required 'header'", { instance: message });
+        if (!message.hasOwnProperty("body"))
+            throw $util.ProtocolError("missing required 'body'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a ChannelPayoutsMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ChannelPayoutsMetadata} ChannelPayoutsMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelPayoutsMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ChannelPayoutsMetadata message.
+     * @function verify
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ChannelPayoutsMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        {
+            var error = $root.ChannelPayoutsMetadata.Header.verify(message.header);
+            if (error)
+                return "header." + error;
+        }
+        {
+            var error = $root.ChannelPayoutsMetadata.Body.verify(message.body);
+            if (error)
+                return "body." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a ChannelPayoutsMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ChannelPayoutsMetadata} ChannelPayoutsMetadata
+     */
+    ChannelPayoutsMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.ChannelPayoutsMetadata)
+            return object;
+        var message = new $root.ChannelPayoutsMetadata();
+        if (object.header != null) {
+            if (typeof object.header !== "object")
+                throw TypeError(".ChannelPayoutsMetadata.header: object expected");
+            message.header = $root.ChannelPayoutsMetadata.Header.fromObject(object.header);
+        }
+        if (object.body != null) {
+            if (typeof object.body !== "object")
+                throw TypeError(".ChannelPayoutsMetadata.body: object expected");
+            message.body = $root.ChannelPayoutsMetadata.Body.fromObject(object.body);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ChannelPayoutsMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ChannelPayoutsMetadata
+     * @static
+     * @param {ChannelPayoutsMetadata} message ChannelPayoutsMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ChannelPayoutsMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.header = null;
+            object.body = null;
+        }
+        if (message.header != null && message.hasOwnProperty("header"))
+            object.header = $root.ChannelPayoutsMetadata.Header.toObject(message.header, options);
+        if (message.body != null && message.hasOwnProperty("body"))
+            object.body = $root.ChannelPayoutsMetadata.Body.toObject(message.body, options);
+        return object;
+    };
+
+    /**
+     * Converts this ChannelPayoutsMetadata to JSON.
+     * @function toJSON
+     * @memberof ChannelPayoutsMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ChannelPayoutsMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    ChannelPayoutsMetadata.Header = (function() {
+
+        /**
+         * Properties of a Header.
+         * @memberof ChannelPayoutsMetadata
+         * @interface IHeader
+         * @property {Long} payloadLengthInBytes Header payloadLengthInBytes
+         * @property {Long} headerLengthInBytes Header headerLengthInBytes
+         * @property {number} numberOfChannels Header numberOfChannels
+         * @property {Array.<ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset>|null} [channelPayoutByteOffsets] Header channelPayoutByteOffsets
+         */
+
+        /**
+         * Constructs a new Header.
+         * @memberof ChannelPayoutsMetadata
+         * @classdesc Fields in the payload header are encoded in fixed length 32/64 bits instead of [varint encoding](https://developers.google.com/protocol-buffers/docs/encoding#varints) (uint64/32).
+         * This allows first calculating, and then setting the byte offset of each `ChannelPayoutProof` accurately, e.g.
+         * `byte_offset` = `size(Header)` + `position_where_record_for_channel_exists_in_Body`
+         * If varint encoding is used for header fields, then calculating the byte offset of `ChannelPayoutProof`
+         * w.r.t the start of the payload would be improbable since the header size won't be known.
+         * @implements IHeader
+         * @constructor
+         * @param {ChannelPayoutsMetadata.IHeader=} [properties] Properties to set
+         */
+        function Header(properties) {
+            this.channelPayoutByteOffsets = [];
+            if (properties)
+                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                    if (properties[keys[i]] != null)
+                        this[keys[i]] = properties[keys[i]];
+        }
+
+        /**
+         * Header payloadLengthInBytes.
+         * @member {Long} payloadLengthInBytes
+         * @memberof ChannelPayoutsMetadata.Header
+         * @instance
+         */
+        Header.prototype.payloadLengthInBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
+
+        /**
+         * Header headerLengthInBytes.
+         * @member {Long} headerLengthInBytes
+         * @memberof ChannelPayoutsMetadata.Header
+         * @instance
+         */
+        Header.prototype.headerLengthInBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
+
+        /**
+         * Header numberOfChannels.
+         * @member {number} numberOfChannels
+         * @memberof ChannelPayoutsMetadata.Header
+         * @instance
+         */
+        Header.prototype.numberOfChannels = 0;
+
+        /**
+         * Header channelPayoutByteOffsets.
+         * @member {Array.<ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset>} channelPayoutByteOffsets
+         * @memberof ChannelPayoutsMetadata.Header
+         * @instance
+         */
+        Header.prototype.channelPayoutByteOffsets = $util.emptyArray;
+
+        /**
+         * Creates a new Header instance using the specified properties.
+         * @function create
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {ChannelPayoutsMetadata.IHeader=} [properties] Properties to set
+         * @returns {ChannelPayoutsMetadata.Header} Header instance
+         */
+        Header.create = function create(properties) {
+            return new Header(properties);
+        };
+
+        /**
+         * Encodes the specified Header message. Does not implicitly {@link ChannelPayoutsMetadata.Header.verify|verify} messages.
+         * @function encode
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {ChannelPayoutsMetadata.IHeader} message Header message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        Header.encode = function encode(message, writer) {
+            if (!writer)
+                writer = $Writer.create();
+            writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.payloadLengthInBytes);
+            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.headerLengthInBytes);
+            writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.numberOfChannels);
+            if (message.channelPayoutByteOffsets != null && message.channelPayoutByteOffsets.length)
+                for (var i = 0; i < message.channelPayoutByteOffsets.length; ++i)
+                    $root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.encode(message.channelPayoutByteOffsets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
+            return writer;
+        };
+
+        /**
+         * Encodes the specified Header message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Header.verify|verify} messages.
+         * @function encodeDelimited
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {ChannelPayoutsMetadata.IHeader} message Header message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        Header.encodeDelimited = function encodeDelimited(message, writer) {
+            return this.encode(message, writer).ldelim();
+        };
+
+        /**
+         * Decodes a Header message from the specified reader or buffer.
+         * @function decode
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @param {number} [length] Message length if known beforehand
+         * @returns {ChannelPayoutsMetadata.Header} Header
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        Header.decode = function decode(reader, length) {
+            if (!(reader instanceof $Reader))
+                reader = $Reader.create(reader);
+            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelPayoutsMetadata.Header();
+            while (reader.pos < end) {
+                var tag = reader.uint32();
+                switch (tag >>> 3) {
+                case 1:
+                    message.payloadLengthInBytes = reader.fixed64();
+                    break;
+                case 2:
+                    message.headerLengthInBytes = reader.fixed64();
+                    break;
+                case 3:
+                    message.numberOfChannels = reader.fixed32();
+                    break;
+                case 4:
+                    if (!(message.channelPayoutByteOffsets && message.channelPayoutByteOffsets.length))
+                        message.channelPayoutByteOffsets = [];
+                    message.channelPayoutByteOffsets.push($root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.decode(reader, reader.uint32()));
+                    break;
+                default:
+                    reader.skipType(tag & 7);
+                    break;
+                }
+            }
+            if (!message.hasOwnProperty("payloadLengthInBytes"))
+                throw $util.ProtocolError("missing required 'payloadLengthInBytes'", { instance: message });
+            if (!message.hasOwnProperty("headerLengthInBytes"))
+                throw $util.ProtocolError("missing required 'headerLengthInBytes'", { instance: message });
+            if (!message.hasOwnProperty("numberOfChannels"))
+                throw $util.ProtocolError("missing required 'numberOfChannels'", { instance: message });
+            return message;
+        };
+
+        /**
+         * Decodes a Header message from the specified reader or buffer, length delimited.
+         * @function decodeDelimited
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @returns {ChannelPayoutsMetadata.Header} Header
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        Header.decodeDelimited = function decodeDelimited(reader) {
+            if (!(reader instanceof $Reader))
+                reader = new $Reader(reader);
+            return this.decode(reader, reader.uint32());
+        };
+
+        /**
+         * Verifies a Header message.
+         * @function verify
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {Object.<string,*>} message Plain object to verify
+         * @returns {string|null} `null` if valid, otherwise the reason why it is not
+         */
+        Header.verify = function verify(message) {
+            if (typeof message !== "object" || message === null)
+                return "object expected";
+            if (!$util.isInteger(message.payloadLengthInBytes) && !(message.payloadLengthInBytes && $util.isInteger(message.payloadLengthInBytes.low) && $util.isInteger(message.payloadLengthInBytes.high)))
+                return "payloadLengthInBytes: integer|Long expected";
+            if (!$util.isInteger(message.headerLengthInBytes) && !(message.headerLengthInBytes && $util.isInteger(message.headerLengthInBytes.low) && $util.isInteger(message.headerLengthInBytes.high)))
+                return "headerLengthInBytes: integer|Long expected";
+            if (!$util.isInteger(message.numberOfChannels))
+                return "numberOfChannels: integer expected";
+            if (message.channelPayoutByteOffsets != null && message.hasOwnProperty("channelPayoutByteOffsets")) {
+                if (!Array.isArray(message.channelPayoutByteOffsets))
+                    return "channelPayoutByteOffsets: array expected";
+                for (var i = 0; i < message.channelPayoutByteOffsets.length; ++i) {
+                    var error = $root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.verify(message.channelPayoutByteOffsets[i]);
+                    if (error)
+                        return "channelPayoutByteOffsets." + error;
+                }
+            }
+            return null;
+        };
+
+        /**
+         * Creates a Header message from a plain object. Also converts values to their respective internal types.
+         * @function fromObject
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {Object.<string,*>} object Plain object
+         * @returns {ChannelPayoutsMetadata.Header} Header
+         */
+        Header.fromObject = function fromObject(object) {
+            if (object instanceof $root.ChannelPayoutsMetadata.Header)
+                return object;
+            var message = new $root.ChannelPayoutsMetadata.Header();
+            if (object.payloadLengthInBytes != null)
+                if ($util.Long)
+                    (message.payloadLengthInBytes = $util.Long.fromValue(object.payloadLengthInBytes)).unsigned = false;
+                else if (typeof object.payloadLengthInBytes === "string")
+                    message.payloadLengthInBytes = parseInt(object.payloadLengthInBytes, 10);
+                else if (typeof object.payloadLengthInBytes === "number")
+                    message.payloadLengthInBytes = object.payloadLengthInBytes;
+                else if (typeof object.payloadLengthInBytes === "object")
+                    message.payloadLengthInBytes = new $util.LongBits(object.payloadLengthInBytes.low >>> 0, object.payloadLengthInBytes.high >>> 0).toNumber();
+            if (object.headerLengthInBytes != null)
+                if ($util.Long)
+                    (message.headerLengthInBytes = $util.Long.fromValue(object.headerLengthInBytes)).unsigned = false;
+                else if (typeof object.headerLengthInBytes === "string")
+                    message.headerLengthInBytes = parseInt(object.headerLengthInBytes, 10);
+                else if (typeof object.headerLengthInBytes === "number")
+                    message.headerLengthInBytes = object.headerLengthInBytes;
+                else if (typeof object.headerLengthInBytes === "object")
+                    message.headerLengthInBytes = new $util.LongBits(object.headerLengthInBytes.low >>> 0, object.headerLengthInBytes.high >>> 0).toNumber();
+            if (object.numberOfChannels != null)
+                message.numberOfChannels = object.numberOfChannels >>> 0;
+            if (object.channelPayoutByteOffsets) {
+                if (!Array.isArray(object.channelPayoutByteOffsets))
+                    throw TypeError(".ChannelPayoutsMetadata.Header.channelPayoutByteOffsets: array expected");
+                message.channelPayoutByteOffsets = [];
+                for (var i = 0; i < object.channelPayoutByteOffsets.length; ++i) {
+                    if (typeof object.channelPayoutByteOffsets[i] !== "object")
+                        throw TypeError(".ChannelPayoutsMetadata.Header.channelPayoutByteOffsets: object expected");
+                    message.channelPayoutByteOffsets[i] = $root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.fromObject(object.channelPayoutByteOffsets[i]);
+                }
+            }
+            return message;
+        };
+
+        /**
+         * Creates a plain object from a Header message. Also converts values to other types if specified.
+         * @function toObject
+         * @memberof ChannelPayoutsMetadata.Header
+         * @static
+         * @param {ChannelPayoutsMetadata.Header} message Header
+         * @param {$protobuf.IConversionOptions} [options] Conversion options
+         * @returns {Object.<string,*>} Plain object
+         */
+        Header.toObject = function toObject(message, options) {
+            if (!options)
+                options = {};
+            var object = {};
+            if (options.arrays || options.defaults)
+                object.channelPayoutByteOffsets = [];
+            if (options.defaults) {
+                if ($util.Long) {
+                    var long = new $util.Long(0, 0, false);
+                    object.payloadLengthInBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+                } else
+                    object.payloadLengthInBytes = options.longs === String ? "0" : 0;
+                if ($util.Long) {
+                    var long = new $util.Long(0, 0, false);
+                    object.headerLengthInBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+                } else
+                    object.headerLengthInBytes = options.longs === String ? "0" : 0;
+                object.numberOfChannels = 0;
+            }
+            if (message.payloadLengthInBytes != null && message.hasOwnProperty("payloadLengthInBytes"))
+                if (typeof message.payloadLengthInBytes === "number")
+                    object.payloadLengthInBytes = options.longs === String ? String(message.payloadLengthInBytes) : message.payloadLengthInBytes;
+                else
+                    object.payloadLengthInBytes = options.longs === String ? $util.Long.prototype.toString.call(message.payloadLengthInBytes) : options.longs === Number ? new $util.LongBits(message.payloadLengthInBytes.low >>> 0, message.payloadLengthInBytes.high >>> 0).toNumber() : message.payloadLengthInBytes;
+            if (message.headerLengthInBytes != null && message.hasOwnProperty("headerLengthInBytes"))
+                if (typeof message.headerLengthInBytes === "number")
+                    object.headerLengthInBytes = options.longs === String ? String(message.headerLengthInBytes) : message.headerLengthInBytes;
+                else
+                    object.headerLengthInBytes = options.longs === String ? $util.Long.prototype.toString.call(message.headerLengthInBytes) : options.longs === Number ? new $util.LongBits(message.headerLengthInBytes.low >>> 0, message.headerLengthInBytes.high >>> 0).toNumber() : message.headerLengthInBytes;
+            if (message.numberOfChannels != null && message.hasOwnProperty("numberOfChannels"))
+                object.numberOfChannels = message.numberOfChannels;
+            if (message.channelPayoutByteOffsets && message.channelPayoutByteOffsets.length) {
+                object.channelPayoutByteOffsets = [];
+                for (var j = 0; j < message.channelPayoutByteOffsets.length; ++j)
+                    object.channelPayoutByteOffsets[j] = $root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.toObject(message.channelPayoutByteOffsets[j], options);
+            }
+            return object;
+        };
+
+        /**
+         * Converts this Header to JSON.
+         * @function toJSON
+         * @memberof ChannelPayoutsMetadata.Header
+         * @instance
+         * @returns {Object.<string,*>} JSON object
+         */
+        Header.prototype.toJSON = function toJSON() {
+            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+        };
+
+        Header.ChannelPayoutByteOffset = (function() {
+
+            /**
+             * Properties of a ChannelPayoutByteOffset.
+             * @memberof ChannelPayoutsMetadata.Header
+             * @interface IChannelPayoutByteOffset
+             * @property {number} channelId ChannelPayoutByteOffset channelId
+             * @property {Long} byteOffset ChannelPayoutByteOffset byteOffset
+             */
+
+            /**
+             * Constructs a new ChannelPayoutByteOffset.
+             * @memberof ChannelPayoutsMetadata.Header
+             * @classdesc Represents a ChannelPayoutByteOffset.
+             * @implements IChannelPayoutByteOffset
+             * @constructor
+             * @param {ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset=} [properties] Properties to set
+             */
+            function ChannelPayoutByteOffset(properties) {
+                if (properties)
+                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                        if (properties[keys[i]] != null)
+                            this[keys[i]] = properties[keys[i]];
+            }
+
+            /**
+             * ChannelPayoutByteOffset channelId.
+             * @member {number} channelId
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @instance
+             */
+            ChannelPayoutByteOffset.prototype.channelId = 0;
+
+            /**
+             * ChannelPayoutByteOffset byteOffset.
+             * @member {Long} byteOffset
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @instance
+             */
+            ChannelPayoutByteOffset.prototype.byteOffset = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
+
+            /**
+             * Creates a new ChannelPayoutByteOffset instance using the specified properties.
+             * @function create
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset=} [properties] Properties to set
+             * @returns {ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset} ChannelPayoutByteOffset instance
+             */
+            ChannelPayoutByteOffset.create = function create(properties) {
+                return new ChannelPayoutByteOffset(properties);
+            };
+
+            /**
+             * Encodes the specified ChannelPayoutByteOffset message. Does not implicitly {@link ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.verify|verify} messages.
+             * @function encode
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset} message ChannelPayoutByteOffset message or plain object to encode
+             * @param {$protobuf.Writer} [writer] Writer to encode to
+             * @returns {$protobuf.Writer} Writer
+             */
+            ChannelPayoutByteOffset.encode = function encode(message, writer) {
+                if (!writer)
+                    writer = $Writer.create();
+                writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.channelId);
+                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.byteOffset);
+                return writer;
+            };
+
+            /**
+             * Encodes the specified ChannelPayoutByteOffset message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset.verify|verify} messages.
+             * @function encodeDelimited
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {ChannelPayoutsMetadata.Header.IChannelPayoutByteOffset} message ChannelPayoutByteOffset message or plain object to encode
+             * @param {$protobuf.Writer} [writer] Writer to encode to
+             * @returns {$protobuf.Writer} Writer
+             */
+            ChannelPayoutByteOffset.encodeDelimited = function encodeDelimited(message, writer) {
+                return this.encode(message, writer).ldelim();
+            };
+
+            /**
+             * Decodes a ChannelPayoutByteOffset message from the specified reader or buffer.
+             * @function decode
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+             * @param {number} [length] Message length if known beforehand
+             * @returns {ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset} ChannelPayoutByteOffset
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            ChannelPayoutByteOffset.decode = function decode(reader, length) {
+                if (!(reader instanceof $Reader))
+                    reader = $Reader.create(reader);
+                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset();
+                while (reader.pos < end) {
+                    var tag = reader.uint32();
+                    switch (tag >>> 3) {
+                    case 1:
+                        message.channelId = reader.fixed32();
+                        break;
+                    case 2:
+                        message.byteOffset = reader.fixed64();
+                        break;
+                    default:
+                        reader.skipType(tag & 7);
+                        break;
+                    }
+                }
+                if (!message.hasOwnProperty("channelId"))
+                    throw $util.ProtocolError("missing required 'channelId'", { instance: message });
+                if (!message.hasOwnProperty("byteOffset"))
+                    throw $util.ProtocolError("missing required 'byteOffset'", { instance: message });
+                return message;
+            };
+
+            /**
+             * Decodes a ChannelPayoutByteOffset message from the specified reader or buffer, length delimited.
+             * @function decodeDelimited
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+             * @returns {ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset} ChannelPayoutByteOffset
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            ChannelPayoutByteOffset.decodeDelimited = function decodeDelimited(reader) {
+                if (!(reader instanceof $Reader))
+                    reader = new $Reader(reader);
+                return this.decode(reader, reader.uint32());
+            };
+
+            /**
+             * Verifies a ChannelPayoutByteOffset message.
+             * @function verify
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {Object.<string,*>} message Plain object to verify
+             * @returns {string|null} `null` if valid, otherwise the reason why it is not
+             */
+            ChannelPayoutByteOffset.verify = function verify(message) {
+                if (typeof message !== "object" || message === null)
+                    return "object expected";
+                if (!$util.isInteger(message.channelId))
+                    return "channelId: integer expected";
+                if (!$util.isInteger(message.byteOffset) && !(message.byteOffset && $util.isInteger(message.byteOffset.low) && $util.isInteger(message.byteOffset.high)))
+                    return "byteOffset: integer|Long expected";
+                return null;
+            };
+
+            /**
+             * Creates a ChannelPayoutByteOffset message from a plain object. Also converts values to their respective internal types.
+             * @function fromObject
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {Object.<string,*>} object Plain object
+             * @returns {ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset} ChannelPayoutByteOffset
+             */
+            ChannelPayoutByteOffset.fromObject = function fromObject(object) {
+                if (object instanceof $root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset)
+                    return object;
+                var message = new $root.ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset();
+                if (object.channelId != null)
+                    message.channelId = object.channelId >>> 0;
+                if (object.byteOffset != null)
+                    if ($util.Long)
+                        (message.byteOffset = $util.Long.fromValue(object.byteOffset)).unsigned = false;
+                    else if (typeof object.byteOffset === "string")
+                        message.byteOffset = parseInt(object.byteOffset, 10);
+                    else if (typeof object.byteOffset === "number")
+                        message.byteOffset = object.byteOffset;
+                    else if (typeof object.byteOffset === "object")
+                        message.byteOffset = new $util.LongBits(object.byteOffset.low >>> 0, object.byteOffset.high >>> 0).toNumber();
+                return message;
+            };
+
+            /**
+             * Creates a plain object from a ChannelPayoutByteOffset message. Also converts values to other types if specified.
+             * @function toObject
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @static
+             * @param {ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset} message ChannelPayoutByteOffset
+             * @param {$protobuf.IConversionOptions} [options] Conversion options
+             * @returns {Object.<string,*>} Plain object
+             */
+            ChannelPayoutByteOffset.toObject = function toObject(message, options) {
+                if (!options)
+                    options = {};
+                var object = {};
+                if (options.defaults) {
+                    object.channelId = 0;
+                    if ($util.Long) {
+                        var long = new $util.Long(0, 0, false);
+                        object.byteOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+                    } else
+                        object.byteOffset = options.longs === String ? "0" : 0;
+                }
+                if (message.channelId != null && message.hasOwnProperty("channelId"))
+                    object.channelId = message.channelId;
+                if (message.byteOffset != null && message.hasOwnProperty("byteOffset"))
+                    if (typeof message.byteOffset === "number")
+                        object.byteOffset = options.longs === String ? String(message.byteOffset) : message.byteOffset;
+                    else
+                        object.byteOffset = options.longs === String ? $util.Long.prototype.toString.call(message.byteOffset) : options.longs === Number ? new $util.LongBits(message.byteOffset.low >>> 0, message.byteOffset.high >>> 0).toNumber() : message.byteOffset;
+                return object;
+            };
+
+            /**
+             * Converts this ChannelPayoutByteOffset to JSON.
+             * @function toJSON
+             * @memberof ChannelPayoutsMetadata.Header.ChannelPayoutByteOffset
+             * @instance
+             * @returns {Object.<string,*>} JSON object
+             */
+            ChannelPayoutByteOffset.prototype.toJSON = function toJSON() {
+                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+            };
+
+            return ChannelPayoutByteOffset;
+        })();
+
+        return Header;
+    })();
+
+    ChannelPayoutsMetadata.Body = (function() {
+
+        /**
+         * Properties of a Body.
+         * @memberof ChannelPayoutsMetadata
+         * @interface IBody
+         * @property {Array.<ChannelPayoutsMetadata.Body.IChannelPayoutProof>|null} [channelPayouts] Body channelPayouts
+         */
+
+        /**
+         * Constructs a new Body.
+         * @memberof ChannelPayoutsMetadata
+         * @classdesc Represents a Body.
+         * @implements IBody
+         * @constructor
+         * @param {ChannelPayoutsMetadata.IBody=} [properties] Properties to set
+         */
+        function Body(properties) {
+            this.channelPayouts = [];
+            if (properties)
+                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                    if (properties[keys[i]] != null)
+                        this[keys[i]] = properties[keys[i]];
+        }
+
+        /**
+         * Body channelPayouts.
+         * @member {Array.<ChannelPayoutsMetadata.Body.IChannelPayoutProof>} channelPayouts
+         * @memberof ChannelPayoutsMetadata.Body
+         * @instance
+         */
+        Body.prototype.channelPayouts = $util.emptyArray;
+
+        /**
+         * Creates a new Body instance using the specified properties.
+         * @function create
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {ChannelPayoutsMetadata.IBody=} [properties] Properties to set
+         * @returns {ChannelPayoutsMetadata.Body} Body instance
+         */
+        Body.create = function create(properties) {
+            return new Body(properties);
+        };
+
+        /**
+         * Encodes the specified Body message. Does not implicitly {@link ChannelPayoutsMetadata.Body.verify|verify} messages.
+         * @function encode
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {ChannelPayoutsMetadata.IBody} message Body message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        Body.encode = function encode(message, writer) {
+            if (!writer)
+                writer = $Writer.create();
+            if (message.channelPayouts != null && message.channelPayouts.length)
+                for (var i = 0; i < message.channelPayouts.length; ++i)
+                    $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.encode(message.channelPayouts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+            return writer;
+        };
+
+        /**
+         * Encodes the specified Body message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Body.verify|verify} messages.
+         * @function encodeDelimited
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {ChannelPayoutsMetadata.IBody} message Body message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        Body.encodeDelimited = function encodeDelimited(message, writer) {
+            return this.encode(message, writer).ldelim();
+        };
+
+        /**
+         * Decodes a Body message from the specified reader or buffer.
+         * @function decode
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @param {number} [length] Message length if known beforehand
+         * @returns {ChannelPayoutsMetadata.Body} Body
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        Body.decode = function decode(reader, length) {
+            if (!(reader instanceof $Reader))
+                reader = $Reader.create(reader);
+            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelPayoutsMetadata.Body();
+            while (reader.pos < end) {
+                var tag = reader.uint32();
+                switch (tag >>> 3) {
+                case 1:
+                    if (!(message.channelPayouts && message.channelPayouts.length))
+                        message.channelPayouts = [];
+                    message.channelPayouts.push($root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.decode(reader, reader.uint32()));
+                    break;
+                default:
+                    reader.skipType(tag & 7);
+                    break;
+                }
+            }
+            return message;
+        };
+
+        /**
+         * Decodes a Body message from the specified reader or buffer, length delimited.
+         * @function decodeDelimited
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @returns {ChannelPayoutsMetadata.Body} Body
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        Body.decodeDelimited = function decodeDelimited(reader) {
+            if (!(reader instanceof $Reader))
+                reader = new $Reader(reader);
+            return this.decode(reader, reader.uint32());
+        };
+
+        /**
+         * Verifies a Body message.
+         * @function verify
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {Object.<string,*>} message Plain object to verify
+         * @returns {string|null} `null` if valid, otherwise the reason why it is not
+         */
+        Body.verify = function verify(message) {
+            if (typeof message !== "object" || message === null)
+                return "object expected";
+            if (message.channelPayouts != null && message.hasOwnProperty("channelPayouts")) {
+                if (!Array.isArray(message.channelPayouts))
+                    return "channelPayouts: array expected";
+                for (var i = 0; i < message.channelPayouts.length; ++i) {
+                    var error = $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.verify(message.channelPayouts[i]);
+                    if (error)
+                        return "channelPayouts." + error;
+                }
+            }
+            return null;
+        };
+
+        /**
+         * Creates a Body message from a plain object. Also converts values to their respective internal types.
+         * @function fromObject
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {Object.<string,*>} object Plain object
+         * @returns {ChannelPayoutsMetadata.Body} Body
+         */
+        Body.fromObject = function fromObject(object) {
+            if (object instanceof $root.ChannelPayoutsMetadata.Body)
+                return object;
+            var message = new $root.ChannelPayoutsMetadata.Body();
+            if (object.channelPayouts) {
+                if (!Array.isArray(object.channelPayouts))
+                    throw TypeError(".ChannelPayoutsMetadata.Body.channelPayouts: array expected");
+                message.channelPayouts = [];
+                for (var i = 0; i < object.channelPayouts.length; ++i) {
+                    if (typeof object.channelPayouts[i] !== "object")
+                        throw TypeError(".ChannelPayoutsMetadata.Body.channelPayouts: object expected");
+                    message.channelPayouts[i] = $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.fromObject(object.channelPayouts[i]);
+                }
+            }
+            return message;
+        };
+
+        /**
+         * Creates a plain object from a Body message. Also converts values to other types if specified.
+         * @function toObject
+         * @memberof ChannelPayoutsMetadata.Body
+         * @static
+         * @param {ChannelPayoutsMetadata.Body} message Body
+         * @param {$protobuf.IConversionOptions} [options] Conversion options
+         * @returns {Object.<string,*>} Plain object
+         */
+        Body.toObject = function toObject(message, options) {
+            if (!options)
+                options = {};
+            var object = {};
+            if (options.arrays || options.defaults)
+                object.channelPayouts = [];
+            if (message.channelPayouts && message.channelPayouts.length) {
+                object.channelPayouts = [];
+                for (var j = 0; j < message.channelPayouts.length; ++j)
+                    object.channelPayouts[j] = $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.toObject(message.channelPayouts[j], options);
+            }
+            return object;
+        };
+
+        /**
+         * Converts this Body to JSON.
+         * @function toJSON
+         * @memberof ChannelPayoutsMetadata.Body
+         * @instance
+         * @returns {Object.<string,*>} JSON object
+         */
+        Body.prototype.toJSON = function toJSON() {
+            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+        };
+
+        Body.ChannelPayoutProof = (function() {
+
+            /**
+             * Properties of a ChannelPayoutProof.
+             * @memberof ChannelPayoutsMetadata.Body
+             * @interface IChannelPayoutProof
+             * @property {number} channelId ChannelPayoutProof channelId
+             * @property {string} cumulativeRewardEarned ChannelPayoutProof cumulativeRewardEarned
+             * @property {Array.<ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement>|null} [merkleBranch] ChannelPayoutProof merkleBranch
+             * @property {string} reason ChannelPayoutProof reason
+             */
+
+            /**
+             * Constructs a new ChannelPayoutProof.
+             * @memberof ChannelPayoutsMetadata.Body
+             * @classdesc Represents a ChannelPayoutProof.
+             * @implements IChannelPayoutProof
+             * @constructor
+             * @param {ChannelPayoutsMetadata.Body.IChannelPayoutProof=} [properties] Properties to set
+             */
+            function ChannelPayoutProof(properties) {
+                this.merkleBranch = [];
+                if (properties)
+                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                        if (properties[keys[i]] != null)
+                            this[keys[i]] = properties[keys[i]];
+            }
+
+            /**
+             * ChannelPayoutProof channelId.
+             * @member {number} channelId
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @instance
+             */
+            ChannelPayoutProof.prototype.channelId = 0;
+
+            /**
+             * ChannelPayoutProof cumulativeRewardEarned.
+             * @member {string} cumulativeRewardEarned
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @instance
+             */
+            ChannelPayoutProof.prototype.cumulativeRewardEarned = "";
+
+            /**
+             * ChannelPayoutProof merkleBranch.
+             * @member {Array.<ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement>} merkleBranch
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @instance
+             */
+            ChannelPayoutProof.prototype.merkleBranch = $util.emptyArray;
+
+            /**
+             * ChannelPayoutProof reason.
+             * @member {string} reason
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @instance
+             */
+            ChannelPayoutProof.prototype.reason = "";
+
+            /**
+             * Creates a new ChannelPayoutProof instance using the specified properties.
+             * @function create
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {ChannelPayoutsMetadata.Body.IChannelPayoutProof=} [properties] Properties to set
+             * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof} ChannelPayoutProof instance
+             */
+            ChannelPayoutProof.create = function create(properties) {
+                return new ChannelPayoutProof(properties);
+            };
+
+            /**
+             * Encodes the specified ChannelPayoutProof message. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.verify|verify} messages.
+             * @function encode
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {ChannelPayoutsMetadata.Body.IChannelPayoutProof} message ChannelPayoutProof message or plain object to encode
+             * @param {$protobuf.Writer} [writer] Writer to encode to
+             * @returns {$protobuf.Writer} Writer
+             */
+            ChannelPayoutProof.encode = function encode(message, writer) {
+                if (!writer)
+                    writer = $Writer.create();
+                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.channelId);
+                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cumulativeRewardEarned);
+                if (message.merkleBranch != null && message.merkleBranch.length)
+                    for (var i = 0; i < message.merkleBranch.length; ++i)
+                        $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.encode(message.merkleBranch[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
+                writer.uint32(/* id 4, wireType 2 =*/34).string(message.reason);
+                return writer;
+            };
+
+            /**
+             * Encodes the specified ChannelPayoutProof message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.verify|verify} messages.
+             * @function encodeDelimited
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {ChannelPayoutsMetadata.Body.IChannelPayoutProof} message ChannelPayoutProof message or plain object to encode
+             * @param {$protobuf.Writer} [writer] Writer to encode to
+             * @returns {$protobuf.Writer} Writer
+             */
+            ChannelPayoutProof.encodeDelimited = function encodeDelimited(message, writer) {
+                return this.encode(message, writer).ldelim();
+            };
+
+            /**
+             * Decodes a ChannelPayoutProof message from the specified reader or buffer.
+             * @function decode
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+             * @param {number} [length] Message length if known beforehand
+             * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof} ChannelPayoutProof
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            ChannelPayoutProof.decode = function decode(reader, length) {
+                if (!(reader instanceof $Reader))
+                    reader = $Reader.create(reader);
+                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof();
+                while (reader.pos < end) {
+                    var tag = reader.uint32();
+                    switch (tag >>> 3) {
+                    case 1:
+                        message.channelId = reader.uint32();
+                        break;
+                    case 2:
+                        message.cumulativeRewardEarned = reader.string();
+                        break;
+                    case 3:
+                        if (!(message.merkleBranch && message.merkleBranch.length))
+                            message.merkleBranch = [];
+                        message.merkleBranch.push($root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.decode(reader, reader.uint32()));
+                        break;
+                    case 4:
+                        message.reason = reader.string();
+                        break;
+                    default:
+                        reader.skipType(tag & 7);
+                        break;
+                    }
+                }
+                if (!message.hasOwnProperty("channelId"))
+                    throw $util.ProtocolError("missing required 'channelId'", { instance: message });
+                if (!message.hasOwnProperty("cumulativeRewardEarned"))
+                    throw $util.ProtocolError("missing required 'cumulativeRewardEarned'", { instance: message });
+                if (!message.hasOwnProperty("reason"))
+                    throw $util.ProtocolError("missing required 'reason'", { instance: message });
+                return message;
+            };
+
+            /**
+             * Decodes a ChannelPayoutProof message from the specified reader or buffer, length delimited.
+             * @function decodeDelimited
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+             * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof} ChannelPayoutProof
+             * @throws {Error} If the payload is not a reader or valid buffer
+             * @throws {$protobuf.util.ProtocolError} If required fields are missing
+             */
+            ChannelPayoutProof.decodeDelimited = function decodeDelimited(reader) {
+                if (!(reader instanceof $Reader))
+                    reader = new $Reader(reader);
+                return this.decode(reader, reader.uint32());
+            };
+
+            /**
+             * Verifies a ChannelPayoutProof message.
+             * @function verify
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {Object.<string,*>} message Plain object to verify
+             * @returns {string|null} `null` if valid, otherwise the reason why it is not
+             */
+            ChannelPayoutProof.verify = function verify(message) {
+                if (typeof message !== "object" || message === null)
+                    return "object expected";
+                if (!$util.isInteger(message.channelId))
+                    return "channelId: integer expected";
+                if (!$util.isString(message.cumulativeRewardEarned))
+                    return "cumulativeRewardEarned: string expected";
+                if (message.merkleBranch != null && message.hasOwnProperty("merkleBranch")) {
+                    if (!Array.isArray(message.merkleBranch))
+                        return "merkleBranch: array expected";
+                    for (var i = 0; i < message.merkleBranch.length; ++i) {
+                        var error = $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.verify(message.merkleBranch[i]);
+                        if (error)
+                            return "merkleBranch." + error;
+                    }
+                }
+                if (!$util.isString(message.reason))
+                    return "reason: string expected";
+                return null;
+            };
+
+            /**
+             * Creates a ChannelPayoutProof message from a plain object. Also converts values to their respective internal types.
+             * @function fromObject
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {Object.<string,*>} object Plain object
+             * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof} ChannelPayoutProof
+             */
+            ChannelPayoutProof.fromObject = function fromObject(object) {
+                if (object instanceof $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof)
+                    return object;
+                var message = new $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof();
+                if (object.channelId != null)
+                    message.channelId = object.channelId >>> 0;
+                if (object.cumulativeRewardEarned != null)
+                    message.cumulativeRewardEarned = String(object.cumulativeRewardEarned);
+                if (object.merkleBranch) {
+                    if (!Array.isArray(object.merkleBranch))
+                        throw TypeError(".ChannelPayoutsMetadata.Body.ChannelPayoutProof.merkleBranch: array expected");
+                    message.merkleBranch = [];
+                    for (var i = 0; i < object.merkleBranch.length; ++i) {
+                        if (typeof object.merkleBranch[i] !== "object")
+                            throw TypeError(".ChannelPayoutsMetadata.Body.ChannelPayoutProof.merkleBranch: object expected");
+                        message.merkleBranch[i] = $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.fromObject(object.merkleBranch[i]);
+                    }
+                }
+                if (object.reason != null)
+                    message.reason = String(object.reason);
+                return message;
+            };
+
+            /**
+             * Creates a plain object from a ChannelPayoutProof message. Also converts values to other types if specified.
+             * @function toObject
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @static
+             * @param {ChannelPayoutsMetadata.Body.ChannelPayoutProof} message ChannelPayoutProof
+             * @param {$protobuf.IConversionOptions} [options] Conversion options
+             * @returns {Object.<string,*>} Plain object
+             */
+            ChannelPayoutProof.toObject = function toObject(message, options) {
+                if (!options)
+                    options = {};
+                var object = {};
+                if (options.arrays || options.defaults)
+                    object.merkleBranch = [];
+                if (options.defaults) {
+                    object.channelId = 0;
+                    object.cumulativeRewardEarned = "";
+                    object.reason = "";
+                }
+                if (message.channelId != null && message.hasOwnProperty("channelId"))
+                    object.channelId = message.channelId;
+                if (message.cumulativeRewardEarned != null && message.hasOwnProperty("cumulativeRewardEarned"))
+                    object.cumulativeRewardEarned = message.cumulativeRewardEarned;
+                if (message.merkleBranch && message.merkleBranch.length) {
+                    object.merkleBranch = [];
+                    for (var j = 0; j < message.merkleBranch.length; ++j)
+                        object.merkleBranch[j] = $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.toObject(message.merkleBranch[j], options);
+                }
+                if (message.reason != null && message.hasOwnProperty("reason"))
+                    object.reason = message.reason;
+                return object;
+            };
+
+            /**
+             * Converts this ChannelPayoutProof to JSON.
+             * @function toJSON
+             * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+             * @instance
+             * @returns {Object.<string,*>} JSON object
+             */
+            ChannelPayoutProof.prototype.toJSON = function toJSON() {
+                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+            };
+
+            /**
+             * Side enum.
+             * @name ChannelPayoutsMetadata.Body.ChannelPayoutProof.Side
+             * @enum {number}
+             * @property {number} Left=0 Left value
+             * @property {number} Right=1 Right value
+             */
+            ChannelPayoutProof.Side = (function() {
+                var valuesById = {}, values = Object.create(valuesById);
+                values[valuesById[0] = "Left"] = 0;
+                values[valuesById[1] = "Right"] = 1;
+                return values;
+            })();
+
+            ChannelPayoutProof.ProofElement = (function() {
+
+                /**
+                 * Properties of a ProofElement.
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+                 * @interface IProofElement
+                 * @property {string} hash ProofElement hash
+                 * @property {ChannelPayoutsMetadata.Body.ChannelPayoutProof.Side} side ProofElement side
+                 */
+
+                /**
+                 * Constructs a new ProofElement.
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof
+                 * @classdesc Represents a ProofElement.
+                 * @implements IProofElement
+                 * @constructor
+                 * @param {ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement=} [properties] Properties to set
+                 */
+                function ProofElement(properties) {
+                    if (properties)
+                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                            if (properties[keys[i]] != null)
+                                this[keys[i]] = properties[keys[i]];
+                }
+
+                /**
+                 * ProofElement hash.
+                 * @member {string} hash
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @instance
+                 */
+                ProofElement.prototype.hash = "";
+
+                /**
+                 * ProofElement side.
+                 * @member {ChannelPayoutsMetadata.Body.ChannelPayoutProof.Side} side
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @instance
+                 */
+                ProofElement.prototype.side = 0;
+
+                /**
+                 * Creates a new ProofElement instance using the specified properties.
+                 * @function create
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement=} [properties] Properties to set
+                 * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement} ProofElement instance
+                 */
+                ProofElement.create = function create(properties) {
+                    return new ProofElement(properties);
+                };
+
+                /**
+                 * Encodes the specified ProofElement message. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.verify|verify} messages.
+                 * @function encode
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement} message ProofElement message or plain object to encode
+                 * @param {$protobuf.Writer} [writer] Writer to encode to
+                 * @returns {$protobuf.Writer} Writer
+                 */
+                ProofElement.encode = function encode(message, writer) {
+                    if (!writer)
+                        writer = $Writer.create();
+                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.hash);
+                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.side);
+                    return writer;
+                };
+
+                /**
+                 * Encodes the specified ProofElement message, length delimited. Does not implicitly {@link ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement.verify|verify} messages.
+                 * @function encodeDelimited
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {ChannelPayoutsMetadata.Body.ChannelPayoutProof.IProofElement} message ProofElement message or plain object to encode
+                 * @param {$protobuf.Writer} [writer] Writer to encode to
+                 * @returns {$protobuf.Writer} Writer
+                 */
+                ProofElement.encodeDelimited = function encodeDelimited(message, writer) {
+                    return this.encode(message, writer).ldelim();
+                };
+
+                /**
+                 * Decodes a ProofElement message from the specified reader or buffer.
+                 * @function decode
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+                 * @param {number} [length] Message length if known beforehand
+                 * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement} ProofElement
+                 * @throws {Error} If the payload is not a reader or valid buffer
+                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
+                 */
+                ProofElement.decode = function decode(reader, length) {
+                    if (!(reader instanceof $Reader))
+                        reader = $Reader.create(reader);
+                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement();
+                    while (reader.pos < end) {
+                        var tag = reader.uint32();
+                        switch (tag >>> 3) {
+                        case 1:
+                            message.hash = reader.string();
+                            break;
+                        case 2:
+                            message.side = reader.int32();
+                            break;
+                        default:
+                            reader.skipType(tag & 7);
+                            break;
+                        }
+                    }
+                    if (!message.hasOwnProperty("hash"))
+                        throw $util.ProtocolError("missing required 'hash'", { instance: message });
+                    if (!message.hasOwnProperty("side"))
+                        throw $util.ProtocolError("missing required 'side'", { instance: message });
+                    return message;
+                };
+
+                /**
+                 * Decodes a ProofElement message from the specified reader or buffer, length delimited.
+                 * @function decodeDelimited
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+                 * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement} ProofElement
+                 * @throws {Error} If the payload is not a reader or valid buffer
+                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
+                 */
+                ProofElement.decodeDelimited = function decodeDelimited(reader) {
+                    if (!(reader instanceof $Reader))
+                        reader = new $Reader(reader);
+                    return this.decode(reader, reader.uint32());
+                };
+
+                /**
+                 * Verifies a ProofElement message.
+                 * @function verify
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {Object.<string,*>} message Plain object to verify
+                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
+                 */
+                ProofElement.verify = function verify(message) {
+                    if (typeof message !== "object" || message === null)
+                        return "object expected";
+                    if (!$util.isString(message.hash))
+                        return "hash: string expected";
+                    switch (message.side) {
+                    default:
+                        return "side: enum value expected";
+                    case 0:
+                    case 1:
+                        break;
+                    }
+                    return null;
+                };
+
+                /**
+                 * Creates a ProofElement message from a plain object. Also converts values to their respective internal types.
+                 * @function fromObject
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {Object.<string,*>} object Plain object
+                 * @returns {ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement} ProofElement
+                 */
+                ProofElement.fromObject = function fromObject(object) {
+                    if (object instanceof $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement)
+                        return object;
+                    var message = new $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement();
+                    if (object.hash != null)
+                        message.hash = String(object.hash);
+                    switch (object.side) {
+                    case "Left":
+                    case 0:
+                        message.side = 0;
+                        break;
+                    case "Right":
+                    case 1:
+                        message.side = 1;
+                        break;
+                    }
+                    return message;
+                };
+
+                /**
+                 * Creates a plain object from a ProofElement message. Also converts values to other types if specified.
+                 * @function toObject
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @static
+                 * @param {ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement} message ProofElement
+                 * @param {$protobuf.IConversionOptions} [options] Conversion options
+                 * @returns {Object.<string,*>} Plain object
+                 */
+                ProofElement.toObject = function toObject(message, options) {
+                    if (!options)
+                        options = {};
+                    var object = {};
+                    if (options.defaults) {
+                        object.hash = "";
+                        object.side = options.enums === String ? "Left" : 0;
+                    }
+                    if (message.hash != null && message.hasOwnProperty("hash"))
+                        object.hash = message.hash;
+                    if (message.side != null && message.hasOwnProperty("side"))
+                        object.side = options.enums === String ? $root.ChannelPayoutsMetadata.Body.ChannelPayoutProof.Side[message.side] : message.side;
+                    return object;
+                };
+
+                /**
+                 * Converts this ProofElement to JSON.
+                 * @function toJSON
+                 * @memberof ChannelPayoutsMetadata.Body.ChannelPayoutProof.ProofElement
+                 * @instance
+                 * @returns {Object.<string,*>} JSON object
+                 */
+                ProofElement.prototype.toJSON = function toJSON() {
+                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+                };
+
+                return ProofElement;
+            })();
+
+            return ChannelPayoutProof;
+        })();
+
+        return Body;
+    })();
+
+    return ChannelPayoutsMetadata;
+})();
+
+$root.CouncilCandidacyNoteMetadata = (function() {
+
+    /**
+     * Properties of a CouncilCandidacyNoteMetadata.
+     * @exports ICouncilCandidacyNoteMetadata
+     * @interface ICouncilCandidacyNoteMetadata
+     * @property {string|null} [header] CouncilCandidacyNoteMetadata header
+     * @property {Array.<string>|null} [bulletPoints] CouncilCandidacyNoteMetadata bulletPoints
+     * @property {string|null} [bannerImageUri] CouncilCandidacyNoteMetadata bannerImageUri
+     * @property {string|null} [description] CouncilCandidacyNoteMetadata description
+     */
+
+    /**
+     * Constructs a new CouncilCandidacyNoteMetadata.
+     * @exports CouncilCandidacyNoteMetadata
+     * @classdesc Represents a CouncilCandidacyNoteMetadata.
+     * @implements ICouncilCandidacyNoteMetadata
+     * @constructor
+     * @param {ICouncilCandidacyNoteMetadata=} [properties] Properties to set
+     */
+    function CouncilCandidacyNoteMetadata(properties) {
+        this.bulletPoints = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * CouncilCandidacyNoteMetadata header.
+     * @member {string} header
+     * @memberof CouncilCandidacyNoteMetadata
+     * @instance
+     */
+    CouncilCandidacyNoteMetadata.prototype.header = "";
+
+    /**
+     * CouncilCandidacyNoteMetadata bulletPoints.
+     * @member {Array.<string>} bulletPoints
+     * @memberof CouncilCandidacyNoteMetadata
+     * @instance
+     */
+    CouncilCandidacyNoteMetadata.prototype.bulletPoints = $util.emptyArray;
+
+    /**
+     * CouncilCandidacyNoteMetadata bannerImageUri.
+     * @member {string} bannerImageUri
+     * @memberof CouncilCandidacyNoteMetadata
+     * @instance
+     */
+    CouncilCandidacyNoteMetadata.prototype.bannerImageUri = "";
+
+    /**
+     * CouncilCandidacyNoteMetadata description.
+     * @member {string} description
+     * @memberof CouncilCandidacyNoteMetadata
+     * @instance
+     */
+    CouncilCandidacyNoteMetadata.prototype.description = "";
+
+    /**
+     * Creates a new CouncilCandidacyNoteMetadata instance using the specified properties.
+     * @function create
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {ICouncilCandidacyNoteMetadata=} [properties] Properties to set
+     * @returns {CouncilCandidacyNoteMetadata} CouncilCandidacyNoteMetadata instance
+     */
+    CouncilCandidacyNoteMetadata.create = function create(properties) {
+        return new CouncilCandidacyNoteMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified CouncilCandidacyNoteMetadata message. Does not implicitly {@link CouncilCandidacyNoteMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {ICouncilCandidacyNoteMetadata} message CouncilCandidacyNoteMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CouncilCandidacyNoteMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.header != null && Object.hasOwnProperty.call(message, "header"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.header);
+        if (message.bulletPoints != null && message.bulletPoints.length)
+            for (var i = 0; i < message.bulletPoints.length; ++i)
+                writer.uint32(/* id 2, wireType 2 =*/18).string(message.bulletPoints[i]);
+        if (message.bannerImageUri != null && Object.hasOwnProperty.call(message, "bannerImageUri"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.bannerImageUri);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified CouncilCandidacyNoteMetadata message, length delimited. Does not implicitly {@link CouncilCandidacyNoteMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {ICouncilCandidacyNoteMetadata} message CouncilCandidacyNoteMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CouncilCandidacyNoteMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a CouncilCandidacyNoteMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {CouncilCandidacyNoteMetadata} CouncilCandidacyNoteMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CouncilCandidacyNoteMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CouncilCandidacyNoteMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.header = reader.string();
+                break;
+            case 2:
+                if (!(message.bulletPoints && message.bulletPoints.length))
+                    message.bulletPoints = [];
+                message.bulletPoints.push(reader.string());
+                break;
+            case 3:
+                message.bannerImageUri = reader.string();
+                break;
+            case 4:
+                message.description = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a CouncilCandidacyNoteMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {CouncilCandidacyNoteMetadata} CouncilCandidacyNoteMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CouncilCandidacyNoteMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a CouncilCandidacyNoteMetadata message.
+     * @function verify
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    CouncilCandidacyNoteMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.header != null && message.hasOwnProperty("header"))
+            if (!$util.isString(message.header))
+                return "header: string expected";
+        if (message.bulletPoints != null && message.hasOwnProperty("bulletPoints")) {
+            if (!Array.isArray(message.bulletPoints))
+                return "bulletPoints: array expected";
+            for (var i = 0; i < message.bulletPoints.length; ++i)
+                if (!$util.isString(message.bulletPoints[i]))
+                    return "bulletPoints: string[] expected";
+        }
+        if (message.bannerImageUri != null && message.hasOwnProperty("bannerImageUri"))
+            if (!$util.isString(message.bannerImageUri))
+                return "bannerImageUri: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a CouncilCandidacyNoteMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {CouncilCandidacyNoteMetadata} CouncilCandidacyNoteMetadata
+     */
+    CouncilCandidacyNoteMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.CouncilCandidacyNoteMetadata)
+            return object;
+        var message = new $root.CouncilCandidacyNoteMetadata();
+        if (object.header != null)
+            message.header = String(object.header);
+        if (object.bulletPoints) {
+            if (!Array.isArray(object.bulletPoints))
+                throw TypeError(".CouncilCandidacyNoteMetadata.bulletPoints: array expected");
+            message.bulletPoints = [];
+            for (var i = 0; i < object.bulletPoints.length; ++i)
+                message.bulletPoints[i] = String(object.bulletPoints[i]);
+        }
+        if (object.bannerImageUri != null)
+            message.bannerImageUri = String(object.bannerImageUri);
+        if (object.description != null)
+            message.description = String(object.description);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a CouncilCandidacyNoteMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof CouncilCandidacyNoteMetadata
+     * @static
+     * @param {CouncilCandidacyNoteMetadata} message CouncilCandidacyNoteMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    CouncilCandidacyNoteMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.bulletPoints = [];
+        if (options.defaults) {
+            object.header = "";
+            object.bannerImageUri = "";
+            object.description = "";
+        }
+        if (message.header != null && message.hasOwnProperty("header"))
+            object.header = message.header;
+        if (message.bulletPoints && message.bulletPoints.length) {
+            object.bulletPoints = [];
+            for (var j = 0; j < message.bulletPoints.length; ++j)
+                object.bulletPoints[j] = message.bulletPoints[j];
+        }
+        if (message.bannerImageUri != null && message.hasOwnProperty("bannerImageUri"))
+            object.bannerImageUri = message.bannerImageUri;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        return object;
+    };
+
+    /**
+     * Converts this CouncilCandidacyNoteMetadata to JSON.
+     * @function toJSON
+     * @memberof CouncilCandidacyNoteMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    CouncilCandidacyNoteMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return CouncilCandidacyNoteMetadata;
+})();
+
+$root.ForumPostMetadata = (function() {
+
+    /**
+     * Properties of a ForumPostMetadata.
+     * @exports IForumPostMetadata
+     * @interface IForumPostMetadata
+     * @property {string|null} [text] ForumPostMetadata text
+     * @property {number|null} [repliesTo] ForumPostMetadata repliesTo
+     */
+
+    /**
+     * Constructs a new ForumPostMetadata.
+     * @exports ForumPostMetadata
+     * @classdesc Represents a ForumPostMetadata.
+     * @implements IForumPostMetadata
+     * @constructor
+     * @param {IForumPostMetadata=} [properties] Properties to set
+     */
+    function ForumPostMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ForumPostMetadata text.
+     * @member {string} text
+     * @memberof ForumPostMetadata
+     * @instance
+     */
+    ForumPostMetadata.prototype.text = "";
+
+    /**
+     * ForumPostMetadata repliesTo.
+     * @member {number} repliesTo
+     * @memberof ForumPostMetadata
+     * @instance
+     */
+    ForumPostMetadata.prototype.repliesTo = 0;
+
+    /**
+     * Creates a new ForumPostMetadata instance using the specified properties.
+     * @function create
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {IForumPostMetadata=} [properties] Properties to set
+     * @returns {ForumPostMetadata} ForumPostMetadata instance
+     */
+    ForumPostMetadata.create = function create(properties) {
+        return new ForumPostMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified ForumPostMetadata message. Does not implicitly {@link ForumPostMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {IForumPostMetadata} message ForumPostMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ForumPostMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
+        if (message.repliesTo != null && Object.hasOwnProperty.call(message, "repliesTo"))
+            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.repliesTo);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ForumPostMetadata message, length delimited. Does not implicitly {@link ForumPostMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {IForumPostMetadata} message ForumPostMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ForumPostMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ForumPostMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ForumPostMetadata} ForumPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ForumPostMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ForumPostMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.text = reader.string();
+                break;
+            case 2:
+                message.repliesTo = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a ForumPostMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ForumPostMetadata} ForumPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ForumPostMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ForumPostMetadata message.
+     * @function verify
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ForumPostMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.text != null && message.hasOwnProperty("text"))
+            if (!$util.isString(message.text))
+                return "text: string expected";
+        if (message.repliesTo != null && message.hasOwnProperty("repliesTo"))
+            if (!$util.isInteger(message.repliesTo))
+                return "repliesTo: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a ForumPostMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ForumPostMetadata} ForumPostMetadata
+     */
+    ForumPostMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.ForumPostMetadata)
+            return object;
+        var message = new $root.ForumPostMetadata();
+        if (object.text != null)
+            message.text = String(object.text);
+        if (object.repliesTo != null)
+            message.repliesTo = object.repliesTo >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ForumPostMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ForumPostMetadata
+     * @static
+     * @param {ForumPostMetadata} message ForumPostMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ForumPostMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.text = "";
+            object.repliesTo = 0;
+        }
+        if (message.text != null && message.hasOwnProperty("text"))
+            object.text = message.text;
+        if (message.repliesTo != null && message.hasOwnProperty("repliesTo"))
+            object.repliesTo = message.repliesTo;
+        return object;
+    };
+
+    /**
+     * Converts this ForumPostMetadata to JSON.
+     * @function toJSON
+     * @memberof ForumPostMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ForumPostMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ForumPostMetadata;
+})();
+
+$root.ForumThreadMetadata = (function() {
+
+    /**
+     * Properties of a ForumThreadMetadata.
+     * @exports IForumThreadMetadata
+     * @interface IForumThreadMetadata
+     * @property {string|null} [title] ForumThreadMetadata title
+     * @property {Array.<string>|null} [tags] ForumThreadMetadata tags
+     */
+
+    /**
+     * Constructs a new ForumThreadMetadata.
+     * @exports ForumThreadMetadata
+     * @classdesc Represents a ForumThreadMetadata.
+     * @implements IForumThreadMetadata
+     * @constructor
+     * @param {IForumThreadMetadata=} [properties] Properties to set
+     */
+    function ForumThreadMetadata(properties) {
+        this.tags = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ForumThreadMetadata title.
+     * @member {string} title
+     * @memberof ForumThreadMetadata
+     * @instance
+     */
+    ForumThreadMetadata.prototype.title = "";
+
+    /**
+     * ForumThreadMetadata tags.
+     * @member {Array.<string>} tags
+     * @memberof ForumThreadMetadata
+     * @instance
+     */
+    ForumThreadMetadata.prototype.tags = $util.emptyArray;
+
+    /**
+     * Creates a new ForumThreadMetadata instance using the specified properties.
+     * @function create
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {IForumThreadMetadata=} [properties] Properties to set
+     * @returns {ForumThreadMetadata} ForumThreadMetadata instance
+     */
+    ForumThreadMetadata.create = function create(properties) {
+        return new ForumThreadMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified ForumThreadMetadata message. Does not implicitly {@link ForumThreadMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {IForumThreadMetadata} message ForumThreadMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ForumThreadMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.tags != null && message.tags.length)
+            for (var i = 0; i < message.tags.length; ++i)
+                writer.uint32(/* id 2, wireType 2 =*/18).string(message.tags[i]);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ForumThreadMetadata message, length delimited. Does not implicitly {@link ForumThreadMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {IForumThreadMetadata} message ForumThreadMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ForumThreadMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ForumThreadMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ForumThreadMetadata} ForumThreadMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ForumThreadMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ForumThreadMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                if (!(message.tags && message.tags.length))
+                    message.tags = [];
+                message.tags.push(reader.string());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a ForumThreadMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ForumThreadMetadata} ForumThreadMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ForumThreadMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ForumThreadMetadata message.
+     * @function verify
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ForumThreadMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.tags != null && message.hasOwnProperty("tags")) {
+            if (!Array.isArray(message.tags))
+                return "tags: array expected";
+            for (var i = 0; i < message.tags.length; ++i)
+                if (!$util.isString(message.tags[i]))
+                    return "tags: string[] expected";
+        }
+        return null;
+    };
+
+    /**
+     * Creates a ForumThreadMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ForumThreadMetadata} ForumThreadMetadata
+     */
+    ForumThreadMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.ForumThreadMetadata)
+            return object;
+        var message = new $root.ForumThreadMetadata();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.tags) {
+            if (!Array.isArray(object.tags))
+                throw TypeError(".ForumThreadMetadata.tags: array expected");
+            message.tags = [];
+            for (var i = 0; i < object.tags.length; ++i)
+                message.tags[i] = String(object.tags[i]);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ForumThreadMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ForumThreadMetadata
+     * @static
+     * @param {ForumThreadMetadata} message ForumThreadMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ForumThreadMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.tags = [];
+        if (options.defaults)
+            object.title = "";
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.tags && message.tags.length) {
+            object.tags = [];
+            for (var j = 0; j < message.tags.length; ++j)
+                object.tags[j] = message.tags[j];
+        }
+        return object;
+    };
+
+    /**
+     * Converts this ForumThreadMetadata to JSON.
+     * @function toJSON
+     * @memberof ForumThreadMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ForumThreadMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ForumThreadMetadata;
+})();
+
+$root.MembershipMetadata = (function() {
+
+    /**
+     * Properties of a MembershipMetadata.
+     * @exports IMembershipMetadata
+     * @interface IMembershipMetadata
+     * @property {string|null} [name] MembershipMetadata name
+     * @property {number|null} [avatarObject] MembershipMetadata avatarObject
+     * @property {string|null} [avatarUri] MembershipMetadata avatarUri
+     * @property {string|null} [about] MembershipMetadata about
+     * @property {Array.<MembershipMetadata.IExternalResource>|null} [externalResources] MembershipMetadata externalResources
+     */
+
+    /**
+     * Constructs a new MembershipMetadata.
+     * @exports MembershipMetadata
+     * @classdesc Represents a MembershipMetadata.
+     * @implements IMembershipMetadata
+     * @constructor
+     * @param {IMembershipMetadata=} [properties] Properties to set
+     */
+    function MembershipMetadata(properties) {
+        this.externalResources = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * MembershipMetadata name.
+     * @member {string} name
+     * @memberof MembershipMetadata
+     * @instance
+     */
+    MembershipMetadata.prototype.name = "";
+
+    /**
+     * MembershipMetadata avatarObject.
+     * @member {number|null|undefined} avatarObject
+     * @memberof MembershipMetadata
+     * @instance
+     */
+    MembershipMetadata.prototype.avatarObject = null;
+
+    /**
+     * MembershipMetadata avatarUri.
+     * @member {string|null|undefined} avatarUri
+     * @memberof MembershipMetadata
+     * @instance
+     */
+    MembershipMetadata.prototype.avatarUri = null;
+
+    /**
+     * MembershipMetadata about.
+     * @member {string} about
+     * @memberof MembershipMetadata
+     * @instance
+     */
+    MembershipMetadata.prototype.about = "";
+
+    /**
+     * MembershipMetadata externalResources.
+     * @member {Array.<MembershipMetadata.IExternalResource>} externalResources
+     * @memberof MembershipMetadata
+     * @instance
+     */
+    MembershipMetadata.prototype.externalResources = $util.emptyArray;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * MembershipMetadata avatar.
+     * @member {"avatarObject"|"avatarUri"|undefined} avatar
+     * @memberof MembershipMetadata
+     * @instance
+     */
+    Object.defineProperty(MembershipMetadata.prototype, "avatar", {
+        get: $util.oneOfGetter($oneOfFields = ["avatarObject", "avatarUri"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new MembershipMetadata instance using the specified properties.
+     * @function create
+     * @memberof MembershipMetadata
+     * @static
+     * @param {IMembershipMetadata=} [properties] Properties to set
+     * @returns {MembershipMetadata} MembershipMetadata instance
+     */
+    MembershipMetadata.create = function create(properties) {
+        return new MembershipMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified MembershipMetadata message. Does not implicitly {@link MembershipMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof MembershipMetadata
+     * @static
+     * @param {IMembershipMetadata} message MembershipMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MembershipMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
+        if (message.avatarObject != null && Object.hasOwnProperty.call(message, "avatarObject"))
+            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.avatarObject);
+        if (message.about != null && Object.hasOwnProperty.call(message, "about"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.about);
+        if (message.avatarUri != null && Object.hasOwnProperty.call(message, "avatarUri"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarUri);
+        if (message.externalResources != null && message.externalResources.length)
+            for (var i = 0; i < message.externalResources.length; ++i)
+                $root.MembershipMetadata.ExternalResource.encode(message.externalResources[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified MembershipMetadata message, length delimited. Does not implicitly {@link MembershipMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof MembershipMetadata
+     * @static
+     * @param {IMembershipMetadata} message MembershipMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MembershipMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a MembershipMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof MembershipMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {MembershipMetadata} MembershipMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MembershipMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MembershipMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.name = reader.string();
+                break;
+            case 2:
+                message.avatarObject = reader.uint32();
+                break;
+            case 4:
+                message.avatarUri = reader.string();
+                break;
+            case 3:
+                message.about = reader.string();
+                break;
+            case 5:
+                if (!(message.externalResources && message.externalResources.length))
+                    message.externalResources = [];
+                message.externalResources.push($root.MembershipMetadata.ExternalResource.decode(reader, reader.uint32()));
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a MembershipMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof MembershipMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {MembershipMetadata} MembershipMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MembershipMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a MembershipMetadata message.
+     * @function verify
+     * @memberof MembershipMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    MembershipMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.name != null && message.hasOwnProperty("name"))
+            if (!$util.isString(message.name))
+                return "name: string expected";
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            properties.avatar = 1;
+            if (!$util.isInteger(message.avatarObject))
+                return "avatarObject: integer expected";
+        }
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            if (properties.avatar === 1)
+                return "avatar: multiple values";
+            properties.avatar = 1;
+            if (!$util.isString(message.avatarUri))
+                return "avatarUri: string expected";
+        }
+        if (message.about != null && message.hasOwnProperty("about"))
+            if (!$util.isString(message.about))
+                return "about: string expected";
+        if (message.externalResources != null && message.hasOwnProperty("externalResources")) {
+            if (!Array.isArray(message.externalResources))
+                return "externalResources: array expected";
+            for (var i = 0; i < message.externalResources.length; ++i) {
+                var error = $root.MembershipMetadata.ExternalResource.verify(message.externalResources[i]);
+                if (error)
+                    return "externalResources." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a MembershipMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof MembershipMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {MembershipMetadata} MembershipMetadata
+     */
+    MembershipMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.MembershipMetadata)
+            return object;
+        var message = new $root.MembershipMetadata();
+        if (object.name != null)
+            message.name = String(object.name);
+        if (object.avatarObject != null)
+            message.avatarObject = object.avatarObject >>> 0;
+        if (object.avatarUri != null)
+            message.avatarUri = String(object.avatarUri);
+        if (object.about != null)
+            message.about = String(object.about);
+        if (object.externalResources) {
+            if (!Array.isArray(object.externalResources))
+                throw TypeError(".MembershipMetadata.externalResources: array expected");
+            message.externalResources = [];
+            for (var i = 0; i < object.externalResources.length; ++i) {
+                if (typeof object.externalResources[i] !== "object")
+                    throw TypeError(".MembershipMetadata.externalResources: object expected");
+                message.externalResources[i] = $root.MembershipMetadata.ExternalResource.fromObject(object.externalResources[i]);
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a MembershipMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof MembershipMetadata
+     * @static
+     * @param {MembershipMetadata} message MembershipMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    MembershipMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.externalResources = [];
+        if (options.defaults) {
+            object.name = "";
+            object.about = "";
+        }
+        if (message.name != null && message.hasOwnProperty("name"))
+            object.name = message.name;
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            object.avatarObject = message.avatarObject;
+            if (options.oneofs)
+                object.avatar = "avatarObject";
+        }
+        if (message.about != null && message.hasOwnProperty("about"))
+            object.about = message.about;
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            object.avatarUri = message.avatarUri;
+            if (options.oneofs)
+                object.avatar = "avatarUri";
+        }
+        if (message.externalResources && message.externalResources.length) {
+            object.externalResources = [];
+            for (var j = 0; j < message.externalResources.length; ++j)
+                object.externalResources[j] = $root.MembershipMetadata.ExternalResource.toObject(message.externalResources[j], options);
+        }
+        return object;
+    };
+
+    /**
+     * Converts this MembershipMetadata to JSON.
+     * @function toJSON
+     * @memberof MembershipMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    MembershipMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    MembershipMetadata.ExternalResource = (function() {
+
+        /**
+         * Properties of an ExternalResource.
+         * @memberof MembershipMetadata
+         * @interface IExternalResource
+         * @property {MembershipMetadata.ExternalResource.ResourceType|null} [type] ExternalResource type
+         * @property {string|null} [value] ExternalResource value
+         */
+
+        /**
+         * Constructs a new ExternalResource.
+         * @memberof MembershipMetadata
+         * @classdesc Represents an ExternalResource.
+         * @implements IExternalResource
+         * @constructor
+         * @param {MembershipMetadata.IExternalResource=} [properties] Properties to set
+         */
+        function ExternalResource(properties) {
+            if (properties)
+                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                    if (properties[keys[i]] != null)
+                        this[keys[i]] = properties[keys[i]];
+        }
+
+        /**
+         * ExternalResource type.
+         * @member {MembershipMetadata.ExternalResource.ResourceType} type
+         * @memberof MembershipMetadata.ExternalResource
+         * @instance
+         */
+        ExternalResource.prototype.type = 0;
+
+        /**
+         * ExternalResource value.
+         * @member {string} value
+         * @memberof MembershipMetadata.ExternalResource
+         * @instance
+         */
+        ExternalResource.prototype.value = "";
+
+        /**
+         * Creates a new ExternalResource instance using the specified properties.
+         * @function create
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {MembershipMetadata.IExternalResource=} [properties] Properties to set
+         * @returns {MembershipMetadata.ExternalResource} ExternalResource instance
+         */
+        ExternalResource.create = function create(properties) {
+            return new ExternalResource(properties);
+        };
+
+        /**
+         * Encodes the specified ExternalResource message. Does not implicitly {@link MembershipMetadata.ExternalResource.verify|verify} messages.
+         * @function encode
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {MembershipMetadata.IExternalResource} message ExternalResource message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        ExternalResource.encode = function encode(message, writer) {
+            if (!writer)
+                writer = $Writer.create();
+            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
+                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
+            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
+                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
+            return writer;
+        };
+
+        /**
+         * Encodes the specified ExternalResource message, length delimited. Does not implicitly {@link MembershipMetadata.ExternalResource.verify|verify} messages.
+         * @function encodeDelimited
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {MembershipMetadata.IExternalResource} message ExternalResource message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        ExternalResource.encodeDelimited = function encodeDelimited(message, writer) {
+            return this.encode(message, writer).ldelim();
+        };
+
+        /**
+         * Decodes an ExternalResource message from the specified reader or buffer.
+         * @function decode
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @param {number} [length] Message length if known beforehand
+         * @returns {MembershipMetadata.ExternalResource} ExternalResource
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        ExternalResource.decode = function decode(reader, length) {
+            if (!(reader instanceof $Reader))
+                reader = $Reader.create(reader);
+            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MembershipMetadata.ExternalResource();
+            while (reader.pos < end) {
+                var tag = reader.uint32();
+                switch (tag >>> 3) {
+                case 1:
+                    message.type = reader.int32();
+                    break;
+                case 2:
+                    message.value = reader.string();
+                    break;
+                default:
+                    reader.skipType(tag & 7);
+                    break;
+                }
+            }
+            return message;
+        };
+
+        /**
+         * Decodes an ExternalResource message from the specified reader or buffer, length delimited.
+         * @function decodeDelimited
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @returns {MembershipMetadata.ExternalResource} ExternalResource
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        ExternalResource.decodeDelimited = function decodeDelimited(reader) {
+            if (!(reader instanceof $Reader))
+                reader = new $Reader(reader);
+            return this.decode(reader, reader.uint32());
+        };
+
+        /**
+         * Verifies an ExternalResource message.
+         * @function verify
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {Object.<string,*>} message Plain object to verify
+         * @returns {string|null} `null` if valid, otherwise the reason why it is not
+         */
+        ExternalResource.verify = function verify(message) {
+            if (typeof message !== "object" || message === null)
+                return "object expected";
+            if (message.type != null && message.hasOwnProperty("type"))
+                switch (message.type) {
+                default:
+                    return "type: enum value expected";
+                case 0:
+                case 1:
+                case 2:
+                case 3:
+                case 4:
+                case 5:
+                case 6:
+                case 7:
+                case 8:
+                case 9:
+                case 10:
+                    break;
+                }
+            if (message.value != null && message.hasOwnProperty("value"))
+                if (!$util.isString(message.value))
+                    return "value: string expected";
+            return null;
+        };
+
+        /**
+         * Creates an ExternalResource message from a plain object. Also converts values to their respective internal types.
+         * @function fromObject
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {Object.<string,*>} object Plain object
+         * @returns {MembershipMetadata.ExternalResource} ExternalResource
+         */
+        ExternalResource.fromObject = function fromObject(object) {
+            if (object instanceof $root.MembershipMetadata.ExternalResource)
+                return object;
+            var message = new $root.MembershipMetadata.ExternalResource();
+            switch (object.type) {
+            case "EMAIL":
+            case 0:
+                message.type = 0;
+                break;
+            case "HYPERLINK":
+            case 1:
+                message.type = 1;
+                break;
+            case "TWITTER":
+            case 2:
+                message.type = 2;
+                break;
+            case "TELEGRAM":
+            case 3:
+                message.type = 3;
+                break;
+            case "DISCORD":
+            case 4:
+                message.type = 4;
+                break;
+            case "FACEBOOK":
+            case 5:
+                message.type = 5;
+                break;
+            case "YOUTUBE":
+            case 6:
+                message.type = 6;
+                break;
+            case "MATRIX":
+            case 7:
+                message.type = 7;
+                break;
+            case "IRC":
+            case 8:
+                message.type = 8;
+                break;
+            case "WECHAT":
+            case 9:
+                message.type = 9;
+                break;
+            case "WHATSAPP":
+            case 10:
+                message.type = 10;
+                break;
+            }
+            if (object.value != null)
+                message.value = String(object.value);
+            return message;
+        };
+
+        /**
+         * Creates a plain object from an ExternalResource message. Also converts values to other types if specified.
+         * @function toObject
+         * @memberof MembershipMetadata.ExternalResource
+         * @static
+         * @param {MembershipMetadata.ExternalResource} message ExternalResource
+         * @param {$protobuf.IConversionOptions} [options] Conversion options
+         * @returns {Object.<string,*>} Plain object
+         */
+        ExternalResource.toObject = function toObject(message, options) {
+            if (!options)
+                options = {};
+            var object = {};
+            if (options.defaults) {
+                object.type = options.enums === String ? "EMAIL" : 0;
+                object.value = "";
+            }
+            if (message.type != null && message.hasOwnProperty("type"))
+                object.type = options.enums === String ? $root.MembershipMetadata.ExternalResource.ResourceType[message.type] : message.type;
+            if (message.value != null && message.hasOwnProperty("value"))
+                object.value = message.value;
+            return object;
+        };
+
+        /**
+         * Converts this ExternalResource to JSON.
+         * @function toJSON
+         * @memberof MembershipMetadata.ExternalResource
+         * @instance
+         * @returns {Object.<string,*>} JSON object
+         */
+        ExternalResource.prototype.toJSON = function toJSON() {
+            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+        };
+
+        /**
+         * ResourceType enum.
+         * @name MembershipMetadata.ExternalResource.ResourceType
+         * @enum {number}
+         * @property {number} EMAIL=0 EMAIL value
+         * @property {number} HYPERLINK=1 HYPERLINK value
+         * @property {number} TWITTER=2 TWITTER value
+         * @property {number} TELEGRAM=3 TELEGRAM value
+         * @property {number} DISCORD=4 DISCORD value
+         * @property {number} FACEBOOK=5 FACEBOOK value
+         * @property {number} YOUTUBE=6 YOUTUBE value
+         * @property {number} MATRIX=7 MATRIX value
+         * @property {number} IRC=8 IRC value
+         * @property {number} WECHAT=9 WECHAT value
+         * @property {number} WHATSAPP=10 WHATSAPP value
+         */
+        ExternalResource.ResourceType = (function() {
+            var valuesById = {}, values = Object.create(valuesById);
+            values[valuesById[0] = "EMAIL"] = 0;
+            values[valuesById[1] = "HYPERLINK"] = 1;
+            values[valuesById[2] = "TWITTER"] = 2;
+            values[valuesById[3] = "TELEGRAM"] = 3;
+            values[valuesById[4] = "DISCORD"] = 4;
+            values[valuesById[5] = "FACEBOOK"] = 5;
+            values[valuesById[6] = "YOUTUBE"] = 6;
+            values[valuesById[7] = "MATRIX"] = 7;
+            values[valuesById[8] = "IRC"] = 8;
+            values[valuesById[9] = "WECHAT"] = 9;
+            values[valuesById[10] = "WHATSAPP"] = 10;
+            return values;
+        })();
+
+        return ExternalResource;
+    })();
+
+    return MembershipMetadata;
+})();
+
+$root.ReactVideo = (function() {
+
+    /**
+     * Properties of a ReactVideo.
+     * @exports IReactVideo
+     * @interface IReactVideo
+     * @property {Long} videoId ReactVideo videoId
+     * @property {ReactVideo.Reaction} reaction ReactVideo reaction
+     */
+
+    /**
+     * Constructs a new ReactVideo.
+     * @exports ReactVideo
+     * @classdesc Represents a ReactVideo.
+     * @implements IReactVideo
+     * @constructor
+     * @param {IReactVideo=} [properties] Properties to set
+     */
+    function ReactVideo(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ReactVideo videoId.
+     * @member {Long} videoId
+     * @memberof ReactVideo
+     * @instance
+     */
+    ReactVideo.prototype.videoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * ReactVideo reaction.
+     * @member {ReactVideo.Reaction} reaction
+     * @memberof ReactVideo
+     * @instance
+     */
+    ReactVideo.prototype.reaction = 0;
+
+    /**
+     * Creates a new ReactVideo instance using the specified properties.
+     * @function create
+     * @memberof ReactVideo
+     * @static
+     * @param {IReactVideo=} [properties] Properties to set
+     * @returns {ReactVideo} ReactVideo instance
+     */
+    ReactVideo.create = function create(properties) {
+        return new ReactVideo(properties);
+    };
+
+    /**
+     * Encodes the specified ReactVideo message. Does not implicitly {@link ReactVideo.verify|verify} messages.
+     * @function encode
+     * @memberof ReactVideo
+     * @static
+     * @param {IReactVideo} message ReactVideo message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ReactVideo.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.videoId);
+        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.reaction);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ReactVideo message, length delimited. Does not implicitly {@link ReactVideo.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ReactVideo
+     * @static
+     * @param {IReactVideo} message ReactVideo message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ReactVideo.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ReactVideo message from the specified reader or buffer.
+     * @function decode
+     * @memberof ReactVideo
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ReactVideo} ReactVideo
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ReactVideo.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReactVideo();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.videoId = reader.uint64();
+                break;
+            case 2:
+                message.reaction = reader.int32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("videoId"))
+            throw $util.ProtocolError("missing required 'videoId'", { instance: message });
+        if (!message.hasOwnProperty("reaction"))
+            throw $util.ProtocolError("missing required 'reaction'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a ReactVideo message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ReactVideo
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ReactVideo} ReactVideo
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ReactVideo.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ReactVideo message.
+     * @function verify
+     * @memberof ReactVideo
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ReactVideo.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isInteger(message.videoId) && !(message.videoId && $util.isInteger(message.videoId.low) && $util.isInteger(message.videoId.high)))
+            return "videoId: integer|Long expected";
+        switch (message.reaction) {
+        default:
+            return "reaction: enum value expected";
+        case 0:
+        case 1:
+            break;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a ReactVideo message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ReactVideo
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ReactVideo} ReactVideo
+     */
+    ReactVideo.fromObject = function fromObject(object) {
+        if (object instanceof $root.ReactVideo)
+            return object;
+        var message = new $root.ReactVideo();
+        if (object.videoId != null)
+            if ($util.Long)
+                (message.videoId = $util.Long.fromValue(object.videoId)).unsigned = true;
+            else if (typeof object.videoId === "string")
+                message.videoId = parseInt(object.videoId, 10);
+            else if (typeof object.videoId === "number")
+                message.videoId = object.videoId;
+            else if (typeof object.videoId === "object")
+                message.videoId = new $util.LongBits(object.videoId.low >>> 0, object.videoId.high >>> 0).toNumber(true);
+        switch (object.reaction) {
+        case "LIKE":
+        case 0:
+            message.reaction = 0;
+            break;
+        case "UNLIKE":
+        case 1:
+            message.reaction = 1;
+            break;
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ReactVideo message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ReactVideo
+     * @static
+     * @param {ReactVideo} message ReactVideo
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ReactVideo.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.videoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.videoId = options.longs === String ? "0" : 0;
+            object.reaction = options.enums === String ? "LIKE" : 0;
+        }
+        if (message.videoId != null && message.hasOwnProperty("videoId"))
+            if (typeof message.videoId === "number")
+                object.videoId = options.longs === String ? String(message.videoId) : message.videoId;
+            else
+                object.videoId = options.longs === String ? $util.Long.prototype.toString.call(message.videoId) : options.longs === Number ? new $util.LongBits(message.videoId.low >>> 0, message.videoId.high >>> 0).toNumber(true) : message.videoId;
+        if (message.reaction != null && message.hasOwnProperty("reaction"))
+            object.reaction = options.enums === String ? $root.ReactVideo.Reaction[message.reaction] : message.reaction;
+        return object;
+    };
+
+    /**
+     * Converts this ReactVideo to JSON.
+     * @function toJSON
+     * @memberof ReactVideo
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ReactVideo.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    /**
+     * Reaction enum.
+     * @name ReactVideo.Reaction
+     * @enum {number}
+     * @property {number} LIKE=0 LIKE value
+     * @property {number} UNLIKE=1 UNLIKE value
+     */
+    ReactVideo.Reaction = (function() {
+        var valuesById = {}, values = Object.create(valuesById);
+        values[valuesById[0] = "LIKE"] = 0;
+        values[valuesById[1] = "UNLIKE"] = 1;
+        return values;
+    })();
+
+    return ReactVideo;
+})();
+
+$root.ReactComment = (function() {
+
+    /**
+     * Properties of a ReactComment.
+     * @exports IReactComment
+     * @interface IReactComment
+     * @property {string} commentId ReactComment commentId
+     * @property {number} reactionId ReactComment reactionId
+     */
+
+    /**
+     * Constructs a new ReactComment.
+     * @exports ReactComment
+     * @classdesc Represents a ReactComment.
+     * @implements IReactComment
+     * @constructor
+     * @param {IReactComment=} [properties] Properties to set
+     */
+    function ReactComment(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ReactComment commentId.
+     * @member {string} commentId
+     * @memberof ReactComment
+     * @instance
+     */
+    ReactComment.prototype.commentId = "";
+
+    /**
+     * ReactComment reactionId.
+     * @member {number} reactionId
+     * @memberof ReactComment
+     * @instance
+     */
+    ReactComment.prototype.reactionId = 0;
+
+    /**
+     * Creates a new ReactComment instance using the specified properties.
+     * @function create
+     * @memberof ReactComment
+     * @static
+     * @param {IReactComment=} [properties] Properties to set
+     * @returns {ReactComment} ReactComment instance
+     */
+    ReactComment.create = function create(properties) {
+        return new ReactComment(properties);
+    };
+
+    /**
+     * Encodes the specified ReactComment message. Does not implicitly {@link ReactComment.verify|verify} messages.
+     * @function encode
+     * @memberof ReactComment
+     * @static
+     * @param {IReactComment} message ReactComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ReactComment.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commentId);
+        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.reactionId);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ReactComment message, length delimited. Does not implicitly {@link ReactComment.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ReactComment
+     * @static
+     * @param {IReactComment} message ReactComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ReactComment.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ReactComment message from the specified reader or buffer.
+     * @function decode
+     * @memberof ReactComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ReactComment} ReactComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ReactComment.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReactComment();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.commentId = reader.string();
+                break;
+            case 2:
+                message.reactionId = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("commentId"))
+            throw $util.ProtocolError("missing required 'commentId'", { instance: message });
+        if (!message.hasOwnProperty("reactionId"))
+            throw $util.ProtocolError("missing required 'reactionId'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a ReactComment message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ReactComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ReactComment} ReactComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ReactComment.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ReactComment message.
+     * @function verify
+     * @memberof ReactComment
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ReactComment.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.commentId))
+            return "commentId: string expected";
+        if (!$util.isInteger(message.reactionId))
+            return "reactionId: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a ReactComment message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ReactComment
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ReactComment} ReactComment
+     */
+    ReactComment.fromObject = function fromObject(object) {
+        if (object instanceof $root.ReactComment)
+            return object;
+        var message = new $root.ReactComment();
+        if (object.commentId != null)
+            message.commentId = String(object.commentId);
+        if (object.reactionId != null)
+            message.reactionId = object.reactionId >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ReactComment message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ReactComment
+     * @static
+     * @param {ReactComment} message ReactComment
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ReactComment.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.commentId = "";
+            object.reactionId = 0;
+        }
+        if (message.commentId != null && message.hasOwnProperty("commentId"))
+            object.commentId = message.commentId;
+        if (message.reactionId != null && message.hasOwnProperty("reactionId"))
+            object.reactionId = message.reactionId;
+        return object;
+    };
+
+    /**
+     * Converts this ReactComment to JSON.
+     * @function toJSON
+     * @memberof ReactComment
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ReactComment.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ReactComment;
+})();
+
+$root.CreateComment = (function() {
+
+    /**
+     * Properties of a CreateComment.
+     * @exports ICreateComment
+     * @interface ICreateComment
+     * @property {Long} videoId CreateComment videoId
+     * @property {string|null} [parentCommentId] CreateComment parentCommentId
+     * @property {string} body CreateComment body
+     */
+
+    /**
+     * Constructs a new CreateComment.
+     * @exports CreateComment
+     * @classdesc Represents a CreateComment.
+     * @implements ICreateComment
+     * @constructor
+     * @param {ICreateComment=} [properties] Properties to set
+     */
+    function CreateComment(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * CreateComment videoId.
+     * @member {Long} videoId
+     * @memberof CreateComment
+     * @instance
+     */
+    CreateComment.prototype.videoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * CreateComment parentCommentId.
+     * @member {string} parentCommentId
+     * @memberof CreateComment
+     * @instance
+     */
+    CreateComment.prototype.parentCommentId = "";
+
+    /**
+     * CreateComment body.
+     * @member {string} body
+     * @memberof CreateComment
+     * @instance
+     */
+    CreateComment.prototype.body = "";
+
+    /**
+     * Creates a new CreateComment instance using the specified properties.
+     * @function create
+     * @memberof CreateComment
+     * @static
+     * @param {ICreateComment=} [properties] Properties to set
+     * @returns {CreateComment} CreateComment instance
+     */
+    CreateComment.create = function create(properties) {
+        return new CreateComment(properties);
+    };
+
+    /**
+     * Encodes the specified CreateComment message. Does not implicitly {@link CreateComment.verify|verify} messages.
+     * @function encode
+     * @memberof CreateComment
+     * @static
+     * @param {ICreateComment} message CreateComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreateComment.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.videoId);
+        if (message.parentCommentId != null && Object.hasOwnProperty.call(message, "parentCommentId"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.parentCommentId);
+        writer.uint32(/* id 3, wireType 2 =*/26).string(message.body);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified CreateComment message, length delimited. Does not implicitly {@link CreateComment.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof CreateComment
+     * @static
+     * @param {ICreateComment} message CreateComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreateComment.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a CreateComment message from the specified reader or buffer.
+     * @function decode
+     * @memberof CreateComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {CreateComment} CreateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreateComment.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateComment();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.videoId = reader.uint64();
+                break;
+            case 2:
+                message.parentCommentId = reader.string();
+                break;
+            case 3:
+                message.body = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("videoId"))
+            throw $util.ProtocolError("missing required 'videoId'", { instance: message });
+        if (!message.hasOwnProperty("body"))
+            throw $util.ProtocolError("missing required 'body'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a CreateComment message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof CreateComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {CreateComment} CreateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreateComment.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a CreateComment message.
+     * @function verify
+     * @memberof CreateComment
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    CreateComment.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isInteger(message.videoId) && !(message.videoId && $util.isInteger(message.videoId.low) && $util.isInteger(message.videoId.high)))
+            return "videoId: integer|Long expected";
+        if (message.parentCommentId != null && message.hasOwnProperty("parentCommentId"))
+            if (!$util.isString(message.parentCommentId))
+                return "parentCommentId: string expected";
+        if (!$util.isString(message.body))
+            return "body: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a CreateComment message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof CreateComment
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {CreateComment} CreateComment
+     */
+    CreateComment.fromObject = function fromObject(object) {
+        if (object instanceof $root.CreateComment)
+            return object;
+        var message = new $root.CreateComment();
+        if (object.videoId != null)
+            if ($util.Long)
+                (message.videoId = $util.Long.fromValue(object.videoId)).unsigned = true;
+            else if (typeof object.videoId === "string")
+                message.videoId = parseInt(object.videoId, 10);
+            else if (typeof object.videoId === "number")
+                message.videoId = object.videoId;
+            else if (typeof object.videoId === "object")
+                message.videoId = new $util.LongBits(object.videoId.low >>> 0, object.videoId.high >>> 0).toNumber(true);
+        if (object.parentCommentId != null)
+            message.parentCommentId = String(object.parentCommentId);
+        if (object.body != null)
+            message.body = String(object.body);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a CreateComment message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof CreateComment
+     * @static
+     * @param {CreateComment} message CreateComment
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    CreateComment.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.videoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.videoId = options.longs === String ? "0" : 0;
+            object.parentCommentId = "";
+            object.body = "";
+        }
+        if (message.videoId != null && message.hasOwnProperty("videoId"))
+            if (typeof message.videoId === "number")
+                object.videoId = options.longs === String ? String(message.videoId) : message.videoId;
+            else
+                object.videoId = options.longs === String ? $util.Long.prototype.toString.call(message.videoId) : options.longs === Number ? new $util.LongBits(message.videoId.low >>> 0, message.videoId.high >>> 0).toNumber(true) : message.videoId;
+        if (message.parentCommentId != null && message.hasOwnProperty("parentCommentId"))
+            object.parentCommentId = message.parentCommentId;
+        if (message.body != null && message.hasOwnProperty("body"))
+            object.body = message.body;
+        return object;
+    };
+
+    /**
+     * Converts this CreateComment to JSON.
+     * @function toJSON
+     * @memberof CreateComment
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    CreateComment.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return CreateComment;
+})();
+
+$root.EditComment = (function() {
+
+    /**
+     * Properties of an EditComment.
+     * @exports IEditComment
+     * @interface IEditComment
+     * @property {string} commentId EditComment commentId
+     * @property {string} newBody EditComment newBody
+     */
+
+    /**
+     * Constructs a new EditComment.
+     * @exports EditComment
+     * @classdesc Represents an EditComment.
+     * @implements IEditComment
+     * @constructor
+     * @param {IEditComment=} [properties] Properties to set
+     */
+    function EditComment(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * EditComment commentId.
+     * @member {string} commentId
+     * @memberof EditComment
+     * @instance
+     */
+    EditComment.prototype.commentId = "";
+
+    /**
+     * EditComment newBody.
+     * @member {string} newBody
+     * @memberof EditComment
+     * @instance
+     */
+    EditComment.prototype.newBody = "";
+
+    /**
+     * Creates a new EditComment instance using the specified properties.
+     * @function create
+     * @memberof EditComment
+     * @static
+     * @param {IEditComment=} [properties] Properties to set
+     * @returns {EditComment} EditComment instance
+     */
+    EditComment.create = function create(properties) {
+        return new EditComment(properties);
+    };
+
+    /**
+     * Encodes the specified EditComment message. Does not implicitly {@link EditComment.verify|verify} messages.
+     * @function encode
+     * @memberof EditComment
+     * @static
+     * @param {IEditComment} message EditComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    EditComment.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commentId);
+        writer.uint32(/* id 2, wireType 2 =*/18).string(message.newBody);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified EditComment message, length delimited. Does not implicitly {@link EditComment.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof EditComment
+     * @static
+     * @param {IEditComment} message EditComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    EditComment.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an EditComment message from the specified reader or buffer.
+     * @function decode
+     * @memberof EditComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {EditComment} EditComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    EditComment.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EditComment();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.commentId = reader.string();
+                break;
+            case 2:
+                message.newBody = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("commentId"))
+            throw $util.ProtocolError("missing required 'commentId'", { instance: message });
+        if (!message.hasOwnProperty("newBody"))
+            throw $util.ProtocolError("missing required 'newBody'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes an EditComment message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof EditComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {EditComment} EditComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    EditComment.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an EditComment message.
+     * @function verify
+     * @memberof EditComment
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    EditComment.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.commentId))
+            return "commentId: string expected";
+        if (!$util.isString(message.newBody))
+            return "newBody: string expected";
+        return null;
+    };
+
+    /**
+     * Creates an EditComment message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof EditComment
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {EditComment} EditComment
+     */
+    EditComment.fromObject = function fromObject(object) {
+        if (object instanceof $root.EditComment)
+            return object;
+        var message = new $root.EditComment();
+        if (object.commentId != null)
+            message.commentId = String(object.commentId);
+        if (object.newBody != null)
+            message.newBody = String(object.newBody);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an EditComment message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof EditComment
+     * @static
+     * @param {EditComment} message EditComment
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    EditComment.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.commentId = "";
+            object.newBody = "";
+        }
+        if (message.commentId != null && message.hasOwnProperty("commentId"))
+            object.commentId = message.commentId;
+        if (message.newBody != null && message.hasOwnProperty("newBody"))
+            object.newBody = message.newBody;
+        return object;
+    };
+
+    /**
+     * Converts this EditComment to JSON.
+     * @function toJSON
+     * @memberof EditComment
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    EditComment.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return EditComment;
+})();
+
+$root.DeleteComment = (function() {
+
+    /**
+     * Properties of a DeleteComment.
+     * @exports IDeleteComment
+     * @interface IDeleteComment
+     * @property {string} commentId DeleteComment commentId
+     */
+
+    /**
+     * Constructs a new DeleteComment.
+     * @exports DeleteComment
+     * @classdesc Represents a DeleteComment.
+     * @implements IDeleteComment
+     * @constructor
+     * @param {IDeleteComment=} [properties] Properties to set
+     */
+    function DeleteComment(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * DeleteComment commentId.
+     * @member {string} commentId
+     * @memberof DeleteComment
+     * @instance
+     */
+    DeleteComment.prototype.commentId = "";
+
+    /**
+     * Creates a new DeleteComment instance using the specified properties.
+     * @function create
+     * @memberof DeleteComment
+     * @static
+     * @param {IDeleteComment=} [properties] Properties to set
+     * @returns {DeleteComment} DeleteComment instance
+     */
+    DeleteComment.create = function create(properties) {
+        return new DeleteComment(properties);
+    };
+
+    /**
+     * Encodes the specified DeleteComment message. Does not implicitly {@link DeleteComment.verify|verify} messages.
+     * @function encode
+     * @memberof DeleteComment
+     * @static
+     * @param {IDeleteComment} message DeleteComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    DeleteComment.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commentId);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified DeleteComment message, length delimited. Does not implicitly {@link DeleteComment.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof DeleteComment
+     * @static
+     * @param {IDeleteComment} message DeleteComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    DeleteComment.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a DeleteComment message from the specified reader or buffer.
+     * @function decode
+     * @memberof DeleteComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {DeleteComment} DeleteComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    DeleteComment.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DeleteComment();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.commentId = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("commentId"))
+            throw $util.ProtocolError("missing required 'commentId'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a DeleteComment message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof DeleteComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {DeleteComment} DeleteComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    DeleteComment.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a DeleteComment message.
+     * @function verify
+     * @memberof DeleteComment
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    DeleteComment.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.commentId))
+            return "commentId: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a DeleteComment message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof DeleteComment
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {DeleteComment} DeleteComment
+     */
+    DeleteComment.fromObject = function fromObject(object) {
+        if (object instanceof $root.DeleteComment)
+            return object;
+        var message = new $root.DeleteComment();
+        if (object.commentId != null)
+            message.commentId = String(object.commentId);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a DeleteComment message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof DeleteComment
+     * @static
+     * @param {DeleteComment} message DeleteComment
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    DeleteComment.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.commentId = "";
+        if (message.commentId != null && message.hasOwnProperty("commentId"))
+            object.commentId = message.commentId;
+        return object;
+    };
+
+    /**
+     * Converts this DeleteComment to JSON.
+     * @function toJSON
+     * @memberof DeleteComment
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    DeleteComment.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return DeleteComment;
+})();
+
+$root.PinOrUnpinComment = (function() {
+
+    /**
+     * Properties of a PinOrUnpinComment.
+     * @exports IPinOrUnpinComment
+     * @interface IPinOrUnpinComment
+     * @property {Long} videoId PinOrUnpinComment videoId
+     * @property {string} commentId PinOrUnpinComment commentId
+     * @property {PinOrUnpinComment.Option} option PinOrUnpinComment option
+     */
+
+    /**
+     * Constructs a new PinOrUnpinComment.
+     * @exports PinOrUnpinComment
+     * @classdesc Represents a PinOrUnpinComment.
+     * @implements IPinOrUnpinComment
+     * @constructor
+     * @param {IPinOrUnpinComment=} [properties] Properties to set
+     */
+    function PinOrUnpinComment(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * PinOrUnpinComment videoId.
+     * @member {Long} videoId
+     * @memberof PinOrUnpinComment
+     * @instance
+     */
+    PinOrUnpinComment.prototype.videoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * PinOrUnpinComment commentId.
+     * @member {string} commentId
+     * @memberof PinOrUnpinComment
+     * @instance
+     */
+    PinOrUnpinComment.prototype.commentId = "";
+
+    /**
+     * PinOrUnpinComment option.
+     * @member {PinOrUnpinComment.Option} option
+     * @memberof PinOrUnpinComment
+     * @instance
+     */
+    PinOrUnpinComment.prototype.option = 0;
+
+    /**
+     * Creates a new PinOrUnpinComment instance using the specified properties.
+     * @function create
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {IPinOrUnpinComment=} [properties] Properties to set
+     * @returns {PinOrUnpinComment} PinOrUnpinComment instance
+     */
+    PinOrUnpinComment.create = function create(properties) {
+        return new PinOrUnpinComment(properties);
+    };
+
+    /**
+     * Encodes the specified PinOrUnpinComment message. Does not implicitly {@link PinOrUnpinComment.verify|verify} messages.
+     * @function encode
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {IPinOrUnpinComment} message PinOrUnpinComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    PinOrUnpinComment.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.videoId);
+        writer.uint32(/* id 2, wireType 2 =*/18).string(message.commentId);
+        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.option);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified PinOrUnpinComment message, length delimited. Does not implicitly {@link PinOrUnpinComment.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {IPinOrUnpinComment} message PinOrUnpinComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    PinOrUnpinComment.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a PinOrUnpinComment message from the specified reader or buffer.
+     * @function decode
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {PinOrUnpinComment} PinOrUnpinComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    PinOrUnpinComment.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PinOrUnpinComment();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.videoId = reader.uint64();
+                break;
+            case 2:
+                message.commentId = reader.string();
+                break;
+            case 3:
+                message.option = reader.int32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("videoId"))
+            throw $util.ProtocolError("missing required 'videoId'", { instance: message });
+        if (!message.hasOwnProperty("commentId"))
+            throw $util.ProtocolError("missing required 'commentId'", { instance: message });
+        if (!message.hasOwnProperty("option"))
+            throw $util.ProtocolError("missing required 'option'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a PinOrUnpinComment message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {PinOrUnpinComment} PinOrUnpinComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    PinOrUnpinComment.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a PinOrUnpinComment message.
+     * @function verify
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    PinOrUnpinComment.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isInteger(message.videoId) && !(message.videoId && $util.isInteger(message.videoId.low) && $util.isInteger(message.videoId.high)))
+            return "videoId: integer|Long expected";
+        if (!$util.isString(message.commentId))
+            return "commentId: string expected";
+        switch (message.option) {
+        default:
+            return "option: enum value expected";
+        case 0:
+        case 1:
+            break;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a PinOrUnpinComment message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {PinOrUnpinComment} PinOrUnpinComment
+     */
+    PinOrUnpinComment.fromObject = function fromObject(object) {
+        if (object instanceof $root.PinOrUnpinComment)
+            return object;
+        var message = new $root.PinOrUnpinComment();
+        if (object.videoId != null)
+            if ($util.Long)
+                (message.videoId = $util.Long.fromValue(object.videoId)).unsigned = true;
+            else if (typeof object.videoId === "string")
+                message.videoId = parseInt(object.videoId, 10);
+            else if (typeof object.videoId === "number")
+                message.videoId = object.videoId;
+            else if (typeof object.videoId === "object")
+                message.videoId = new $util.LongBits(object.videoId.low >>> 0, object.videoId.high >>> 0).toNumber(true);
+        if (object.commentId != null)
+            message.commentId = String(object.commentId);
+        switch (object.option) {
+        case "PIN":
+        case 0:
+            message.option = 0;
+            break;
+        case "UNPIN":
+        case 1:
+            message.option = 1;
+            break;
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a PinOrUnpinComment message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof PinOrUnpinComment
+     * @static
+     * @param {PinOrUnpinComment} message PinOrUnpinComment
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    PinOrUnpinComment.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.videoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.videoId = options.longs === String ? "0" : 0;
+            object.commentId = "";
+            object.option = options.enums === String ? "PIN" : 0;
+        }
+        if (message.videoId != null && message.hasOwnProperty("videoId"))
+            if (typeof message.videoId === "number")
+                object.videoId = options.longs === String ? String(message.videoId) : message.videoId;
+            else
+                object.videoId = options.longs === String ? $util.Long.prototype.toString.call(message.videoId) : options.longs === Number ? new $util.LongBits(message.videoId.low >>> 0, message.videoId.high >>> 0).toNumber(true) : message.videoId;
+        if (message.commentId != null && message.hasOwnProperty("commentId"))
+            object.commentId = message.commentId;
+        if (message.option != null && message.hasOwnProperty("option"))
+            object.option = options.enums === String ? $root.PinOrUnpinComment.Option[message.option] : message.option;
+        return object;
+    };
+
+    /**
+     * Converts this PinOrUnpinComment to JSON.
+     * @function toJSON
+     * @memberof PinOrUnpinComment
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    PinOrUnpinComment.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    /**
+     * Option enum.
+     * @name PinOrUnpinComment.Option
+     * @enum {number}
+     * @property {number} PIN=0 PIN value
+     * @property {number} UNPIN=1 UNPIN value
+     */
+    PinOrUnpinComment.Option = (function() {
+        var valuesById = {}, values = Object.create(valuesById);
+        values[valuesById[0] = "PIN"] = 0;
+        values[valuesById[1] = "UNPIN"] = 1;
+        return values;
+    })();
+
+    return PinOrUnpinComment;
+})();
+
+$root.ModerateComment = (function() {
+
+    /**
+     * Properties of a ModerateComment.
+     * @exports IModerateComment
+     * @interface IModerateComment
+     * @property {string} commentId ModerateComment commentId
+     * @property {string} rationale ModerateComment rationale
+     */
+
+    /**
+     * Constructs a new ModerateComment.
+     * @exports ModerateComment
+     * @classdesc Represents a ModerateComment.
+     * @implements IModerateComment
+     * @constructor
+     * @param {IModerateComment=} [properties] Properties to set
+     */
+    function ModerateComment(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ModerateComment commentId.
+     * @member {string} commentId
+     * @memberof ModerateComment
+     * @instance
+     */
+    ModerateComment.prototype.commentId = "";
+
+    /**
+     * ModerateComment rationale.
+     * @member {string} rationale
+     * @memberof ModerateComment
+     * @instance
+     */
+    ModerateComment.prototype.rationale = "";
+
+    /**
+     * Creates a new ModerateComment instance using the specified properties.
+     * @function create
+     * @memberof ModerateComment
+     * @static
+     * @param {IModerateComment=} [properties] Properties to set
+     * @returns {ModerateComment} ModerateComment instance
+     */
+    ModerateComment.create = function create(properties) {
+        return new ModerateComment(properties);
+    };
+
+    /**
+     * Encodes the specified ModerateComment message. Does not implicitly {@link ModerateComment.verify|verify} messages.
+     * @function encode
+     * @memberof ModerateComment
+     * @static
+     * @param {IModerateComment} message ModerateComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ModerateComment.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commentId);
+        writer.uint32(/* id 2, wireType 2 =*/18).string(message.rationale);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ModerateComment message, length delimited. Does not implicitly {@link ModerateComment.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ModerateComment
+     * @static
+     * @param {IModerateComment} message ModerateComment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ModerateComment.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ModerateComment message from the specified reader or buffer.
+     * @function decode
+     * @memberof ModerateComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ModerateComment} ModerateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ModerateComment.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModerateComment();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.commentId = reader.string();
+                break;
+            case 2:
+                message.rationale = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("commentId"))
+            throw $util.ProtocolError("missing required 'commentId'", { instance: message });
+        if (!message.hasOwnProperty("rationale"))
+            throw $util.ProtocolError("missing required 'rationale'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a ModerateComment message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ModerateComment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ModerateComment} ModerateComment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ModerateComment.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ModerateComment message.
+     * @function verify
+     * @memberof ModerateComment
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ModerateComment.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.commentId))
+            return "commentId: string expected";
+        if (!$util.isString(message.rationale))
+            return "rationale: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a ModerateComment message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ModerateComment
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ModerateComment} ModerateComment
+     */
+    ModerateComment.fromObject = function fromObject(object) {
+        if (object instanceof $root.ModerateComment)
+            return object;
+        var message = new $root.ModerateComment();
+        if (object.commentId != null)
+            message.commentId = String(object.commentId);
+        if (object.rationale != null)
+            message.rationale = String(object.rationale);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ModerateComment message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ModerateComment
+     * @static
+     * @param {ModerateComment} message ModerateComment
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ModerateComment.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.commentId = "";
+            object.rationale = "";
+        }
+        if (message.commentId != null && message.hasOwnProperty("commentId"))
+            object.commentId = message.commentId;
+        if (message.rationale != null && message.hasOwnProperty("rationale"))
+            object.rationale = message.rationale;
+        return object;
+    };
+
+    /**
+     * Converts this ModerateComment to JSON.
+     * @function toJSON
+     * @memberof ModerateComment
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ModerateComment.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ModerateComment;
+})();
+
+$root.BanOrUnbanMemberFromChannel = (function() {
+
+    /**
+     * Properties of a BanOrUnbanMemberFromChannel.
+     * @exports IBanOrUnbanMemberFromChannel
+     * @interface IBanOrUnbanMemberFromChannel
+     * @property {Long} memberId BanOrUnbanMemberFromChannel memberId
+     * @property {BanOrUnbanMemberFromChannel.Option} option BanOrUnbanMemberFromChannel option
+     */
+
+    /**
+     * Constructs a new BanOrUnbanMemberFromChannel.
+     * @exports BanOrUnbanMemberFromChannel
+     * @classdesc Represents a BanOrUnbanMemberFromChannel.
+     * @implements IBanOrUnbanMemberFromChannel
+     * @constructor
+     * @param {IBanOrUnbanMemberFromChannel=} [properties] Properties to set
+     */
+    function BanOrUnbanMemberFromChannel(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * BanOrUnbanMemberFromChannel memberId.
+     * @member {Long} memberId
+     * @memberof BanOrUnbanMemberFromChannel
+     * @instance
+     */
+    BanOrUnbanMemberFromChannel.prototype.memberId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * BanOrUnbanMemberFromChannel option.
+     * @member {BanOrUnbanMemberFromChannel.Option} option
+     * @memberof BanOrUnbanMemberFromChannel
+     * @instance
+     */
+    BanOrUnbanMemberFromChannel.prototype.option = 0;
+
+    /**
+     * Creates a new BanOrUnbanMemberFromChannel instance using the specified properties.
+     * @function create
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {IBanOrUnbanMemberFromChannel=} [properties] Properties to set
+     * @returns {BanOrUnbanMemberFromChannel} BanOrUnbanMemberFromChannel instance
+     */
+    BanOrUnbanMemberFromChannel.create = function create(properties) {
+        return new BanOrUnbanMemberFromChannel(properties);
+    };
+
+    /**
+     * Encodes the specified BanOrUnbanMemberFromChannel message. Does not implicitly {@link BanOrUnbanMemberFromChannel.verify|verify} messages.
+     * @function encode
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {IBanOrUnbanMemberFromChannel} message BanOrUnbanMemberFromChannel message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    BanOrUnbanMemberFromChannel.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.memberId);
+        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.option);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified BanOrUnbanMemberFromChannel message, length delimited. Does not implicitly {@link BanOrUnbanMemberFromChannel.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {IBanOrUnbanMemberFromChannel} message BanOrUnbanMemberFromChannel message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    BanOrUnbanMemberFromChannel.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a BanOrUnbanMemberFromChannel message from the specified reader or buffer.
+     * @function decode
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {BanOrUnbanMemberFromChannel} BanOrUnbanMemberFromChannel
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    BanOrUnbanMemberFromChannel.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.BanOrUnbanMemberFromChannel();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.memberId = reader.uint64();
+                break;
+            case 2:
+                message.option = reader.int32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("memberId"))
+            throw $util.ProtocolError("missing required 'memberId'", { instance: message });
+        if (!message.hasOwnProperty("option"))
+            throw $util.ProtocolError("missing required 'option'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a BanOrUnbanMemberFromChannel message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {BanOrUnbanMemberFromChannel} BanOrUnbanMemberFromChannel
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    BanOrUnbanMemberFromChannel.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a BanOrUnbanMemberFromChannel message.
+     * @function verify
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    BanOrUnbanMemberFromChannel.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high)))
+            return "memberId: integer|Long expected";
+        switch (message.option) {
+        default:
+            return "option: enum value expected";
+        case 0:
+        case 1:
+            break;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a BanOrUnbanMemberFromChannel message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {BanOrUnbanMemberFromChannel} BanOrUnbanMemberFromChannel
+     */
+    BanOrUnbanMemberFromChannel.fromObject = function fromObject(object) {
+        if (object instanceof $root.BanOrUnbanMemberFromChannel)
+            return object;
+        var message = new $root.BanOrUnbanMemberFromChannel();
+        if (object.memberId != null)
+            if ($util.Long)
+                (message.memberId = $util.Long.fromValue(object.memberId)).unsigned = true;
+            else if (typeof object.memberId === "string")
+                message.memberId = parseInt(object.memberId, 10);
+            else if (typeof object.memberId === "number")
+                message.memberId = object.memberId;
+            else if (typeof object.memberId === "object")
+                message.memberId = new $util.LongBits(object.memberId.low >>> 0, object.memberId.high >>> 0).toNumber(true);
+        switch (object.option) {
+        case "BAN":
+        case 0:
+            message.option = 0;
+            break;
+        case "UNBAN":
+        case 1:
+            message.option = 1;
+            break;
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a BanOrUnbanMemberFromChannel message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof BanOrUnbanMemberFromChannel
+     * @static
+     * @param {BanOrUnbanMemberFromChannel} message BanOrUnbanMemberFromChannel
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    BanOrUnbanMemberFromChannel.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.memberId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.memberId = options.longs === String ? "0" : 0;
+            object.option = options.enums === String ? "BAN" : 0;
+        }
+        if (message.memberId != null && message.hasOwnProperty("memberId"))
+            if (typeof message.memberId === "number")
+                object.memberId = options.longs === String ? String(message.memberId) : message.memberId;
+            else
+                object.memberId = options.longs === String ? $util.Long.prototype.toString.call(message.memberId) : options.longs === Number ? new $util.LongBits(message.memberId.low >>> 0, message.memberId.high >>> 0).toNumber(true) : message.memberId;
+        if (message.option != null && message.hasOwnProperty("option"))
+            object.option = options.enums === String ? $root.BanOrUnbanMemberFromChannel.Option[message.option] : message.option;
+        return object;
+    };
+
+    /**
+     * Converts this BanOrUnbanMemberFromChannel to JSON.
+     * @function toJSON
+     * @memberof BanOrUnbanMemberFromChannel
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    BanOrUnbanMemberFromChannel.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    /**
+     * Option enum.
+     * @name BanOrUnbanMemberFromChannel.Option
+     * @enum {number}
+     * @property {number} BAN=0 BAN value
+     * @property {number} UNBAN=1 UNBAN value
+     */
+    BanOrUnbanMemberFromChannel.Option = (function() {
+        var valuesById = {}, values = Object.create(valuesById);
+        values[valuesById[0] = "BAN"] = 0;
+        values[valuesById[1] = "UNBAN"] = 1;
+        return values;
+    })();
+
+    return BanOrUnbanMemberFromChannel;
+})();
+
+$root.VideoReactionsPreference = (function() {
+
+    /**
+     * Properties of a VideoReactionsPreference.
+     * @exports IVideoReactionsPreference
+     * @interface IVideoReactionsPreference
+     * @property {Long} videoId VideoReactionsPreference videoId
+     * @property {VideoReactionsPreference.Option} option VideoReactionsPreference option
+     */
+
+    /**
+     * Constructs a new VideoReactionsPreference.
+     * @exports VideoReactionsPreference
+     * @classdesc Represents a VideoReactionsPreference.
+     * @implements IVideoReactionsPreference
+     * @constructor
+     * @param {IVideoReactionsPreference=} [properties] Properties to set
+     */
+    function VideoReactionsPreference(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * VideoReactionsPreference videoId.
+     * @member {Long} videoId
+     * @memberof VideoReactionsPreference
+     * @instance
+     */
+    VideoReactionsPreference.prototype.videoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * VideoReactionsPreference option.
+     * @member {VideoReactionsPreference.Option} option
+     * @memberof VideoReactionsPreference
+     * @instance
+     */
+    VideoReactionsPreference.prototype.option = 0;
+
+    /**
+     * Creates a new VideoReactionsPreference instance using the specified properties.
+     * @function create
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {IVideoReactionsPreference=} [properties] Properties to set
+     * @returns {VideoReactionsPreference} VideoReactionsPreference instance
+     */
+    VideoReactionsPreference.create = function create(properties) {
+        return new VideoReactionsPreference(properties);
+    };
+
+    /**
+     * Encodes the specified VideoReactionsPreference message. Does not implicitly {@link VideoReactionsPreference.verify|verify} messages.
+     * @function encode
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {IVideoReactionsPreference} message VideoReactionsPreference message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    VideoReactionsPreference.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.videoId);
+        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.option);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified VideoReactionsPreference message, length delimited. Does not implicitly {@link VideoReactionsPreference.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {IVideoReactionsPreference} message VideoReactionsPreference message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    VideoReactionsPreference.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a VideoReactionsPreference message from the specified reader or buffer.
+     * @function decode
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {VideoReactionsPreference} VideoReactionsPreference
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    VideoReactionsPreference.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoReactionsPreference();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.videoId = reader.uint64();
+                break;
+            case 2:
+                message.option = reader.int32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("videoId"))
+            throw $util.ProtocolError("missing required 'videoId'", { instance: message });
+        if (!message.hasOwnProperty("option"))
+            throw $util.ProtocolError("missing required 'option'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a VideoReactionsPreference message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {VideoReactionsPreference} VideoReactionsPreference
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    VideoReactionsPreference.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a VideoReactionsPreference message.
+     * @function verify
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    VideoReactionsPreference.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isInteger(message.videoId) && !(message.videoId && $util.isInteger(message.videoId.low) && $util.isInteger(message.videoId.high)))
+            return "videoId: integer|Long expected";
+        switch (message.option) {
+        default:
+            return "option: enum value expected";
+        case 0:
+        case 1:
+            break;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a VideoReactionsPreference message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {VideoReactionsPreference} VideoReactionsPreference
+     */
+    VideoReactionsPreference.fromObject = function fromObject(object) {
+        if (object instanceof $root.VideoReactionsPreference)
+            return object;
+        var message = new $root.VideoReactionsPreference();
+        if (object.videoId != null)
+            if ($util.Long)
+                (message.videoId = $util.Long.fromValue(object.videoId)).unsigned = true;
+            else if (typeof object.videoId === "string")
+                message.videoId = parseInt(object.videoId, 10);
+            else if (typeof object.videoId === "number")
+                message.videoId = object.videoId;
+            else if (typeof object.videoId === "object")
+                message.videoId = new $util.LongBits(object.videoId.low >>> 0, object.videoId.high >>> 0).toNumber(true);
+        switch (object.option) {
+        case "ENABLE":
+        case 0:
+            message.option = 0;
+            break;
+        case "DISABLE":
+        case 1:
+            message.option = 1;
+            break;
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a VideoReactionsPreference message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof VideoReactionsPreference
+     * @static
+     * @param {VideoReactionsPreference} message VideoReactionsPreference
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    VideoReactionsPreference.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.videoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.videoId = options.longs === String ? "0" : 0;
+            object.option = options.enums === String ? "ENABLE" : 0;
+        }
+        if (message.videoId != null && message.hasOwnProperty("videoId"))
+            if (typeof message.videoId === "number")
+                object.videoId = options.longs === String ? String(message.videoId) : message.videoId;
+            else
+                object.videoId = options.longs === String ? $util.Long.prototype.toString.call(message.videoId) : options.longs === Number ? new $util.LongBits(message.videoId.low >>> 0, message.videoId.high >>> 0).toNumber(true) : message.videoId;
+        if (message.option != null && message.hasOwnProperty("option"))
+            object.option = options.enums === String ? $root.VideoReactionsPreference.Option[message.option] : message.option;
+        return object;
+    };
+
+    /**
+     * Converts this VideoReactionsPreference to JSON.
+     * @function toJSON
+     * @memberof VideoReactionsPreference
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    VideoReactionsPreference.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    /**
+     * Option enum.
+     * @name VideoReactionsPreference.Option
+     * @enum {number}
+     * @property {number} ENABLE=0 ENABLE value
+     * @property {number} DISABLE=1 DISABLE value
+     */
+    VideoReactionsPreference.Option = (function() {
+        var valuesById = {}, values = Object.create(valuesById);
+        values[valuesById[0] = "ENABLE"] = 0;
+        values[valuesById[1] = "DISABLE"] = 1;
+        return values;
+    })();
+
+    return VideoReactionsPreference;
+})();
+
+$root.CreateVideoCategory = (function() {
+
+    /**
+     * Properties of a CreateVideoCategory.
+     * @exports ICreateVideoCategory
+     * @interface ICreateVideoCategory
+     * @property {string} name CreateVideoCategory name
+     * @property {string|null} [description] CreateVideoCategory description
+     * @property {string|null} [parentCategoryId] CreateVideoCategory parentCategoryId
+     */
+
+    /**
+     * Constructs a new CreateVideoCategory.
+     * @exports CreateVideoCategory
+     * @classdesc Represents a CreateVideoCategory.
+     * @implements ICreateVideoCategory
+     * @constructor
+     * @param {ICreateVideoCategory=} [properties] Properties to set
+     */
+    function CreateVideoCategory(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * CreateVideoCategory name.
+     * @member {string} name
+     * @memberof CreateVideoCategory
+     * @instance
+     */
+    CreateVideoCategory.prototype.name = "";
+
+    /**
+     * CreateVideoCategory description.
+     * @member {string} description
+     * @memberof CreateVideoCategory
+     * @instance
+     */
+    CreateVideoCategory.prototype.description = "";
+
+    /**
+     * CreateVideoCategory parentCategoryId.
+     * @member {string} parentCategoryId
+     * @memberof CreateVideoCategory
+     * @instance
+     */
+    CreateVideoCategory.prototype.parentCategoryId = "";
+
+    /**
+     * Creates a new CreateVideoCategory instance using the specified properties.
+     * @function create
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {ICreateVideoCategory=} [properties] Properties to set
+     * @returns {CreateVideoCategory} CreateVideoCategory instance
+     */
+    CreateVideoCategory.create = function create(properties) {
+        return new CreateVideoCategory(properties);
+    };
+
+    /**
+     * Encodes the specified CreateVideoCategory message. Does not implicitly {@link CreateVideoCategory.verify|verify} messages.
+     * @function encode
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {ICreateVideoCategory} message CreateVideoCategory message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreateVideoCategory.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.parentCategoryId != null && Object.hasOwnProperty.call(message, "parentCategoryId"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.parentCategoryId);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified CreateVideoCategory message, length delimited. Does not implicitly {@link CreateVideoCategory.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {ICreateVideoCategory} message CreateVideoCategory message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreateVideoCategory.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a CreateVideoCategory message from the specified reader or buffer.
+     * @function decode
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {CreateVideoCategory} CreateVideoCategory
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreateVideoCategory.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateVideoCategory();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.name = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.parentCategoryId = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("name"))
+            throw $util.ProtocolError("missing required 'name'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a CreateVideoCategory message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {CreateVideoCategory} CreateVideoCategory
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreateVideoCategory.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a CreateVideoCategory message.
+     * @function verify
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    CreateVideoCategory.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.name))
+            return "name: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.parentCategoryId != null && message.hasOwnProperty("parentCategoryId"))
+            if (!$util.isString(message.parentCategoryId))
+                return "parentCategoryId: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a CreateVideoCategory message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {CreateVideoCategory} CreateVideoCategory
+     */
+    CreateVideoCategory.fromObject = function fromObject(object) {
+        if (object instanceof $root.CreateVideoCategory)
+            return object;
+        var message = new $root.CreateVideoCategory();
+        if (object.name != null)
+            message.name = String(object.name);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.parentCategoryId != null)
+            message.parentCategoryId = String(object.parentCategoryId);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a CreateVideoCategory message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof CreateVideoCategory
+     * @static
+     * @param {CreateVideoCategory} message CreateVideoCategory
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    CreateVideoCategory.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.name = "";
+            object.description = "";
+            object.parentCategoryId = "";
+        }
+        if (message.name != null && message.hasOwnProperty("name"))
+            object.name = message.name;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.parentCategoryId != null && message.hasOwnProperty("parentCategoryId"))
+            object.parentCategoryId = message.parentCategoryId;
+        return object;
+    };
+
+    /**
+     * Converts this CreateVideoCategory to JSON.
+     * @function toJSON
+     * @memberof CreateVideoCategory
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    CreateVideoCategory.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return CreateVideoCategory;
+})();
+
+$root.MakeChannelPayment = (function() {
+
+    /**
+     * Properties of a MakeChannelPayment.
+     * @exports IMakeChannelPayment
+     * @interface IMakeChannelPayment
+     * @property {string|null} [rationale] MakeChannelPayment rationale
+     * @property {Long|null} [videoId] MakeChannelPayment videoId
+     */
+
+    /**
+     * Constructs a new MakeChannelPayment.
+     * @exports MakeChannelPayment
+     * @classdesc Represents a MakeChannelPayment.
+     * @implements IMakeChannelPayment
+     * @constructor
+     * @param {IMakeChannelPayment=} [properties] Properties to set
+     */
+    function MakeChannelPayment(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * MakeChannelPayment rationale.
+     * @member {string} rationale
+     * @memberof MakeChannelPayment
+     * @instance
+     */
+    MakeChannelPayment.prototype.rationale = "";
+
+    /**
+     * MakeChannelPayment videoId.
+     * @member {Long|null|undefined} videoId
+     * @memberof MakeChannelPayment
+     * @instance
+     */
+    MakeChannelPayment.prototype.videoId = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * MakeChannelPayment paymentContext.
+     * @member {"videoId"|undefined} paymentContext
+     * @memberof MakeChannelPayment
+     * @instance
+     */
+    Object.defineProperty(MakeChannelPayment.prototype, "paymentContext", {
+        get: $util.oneOfGetter($oneOfFields = ["videoId"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new MakeChannelPayment instance using the specified properties.
+     * @function create
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {IMakeChannelPayment=} [properties] Properties to set
+     * @returns {MakeChannelPayment} MakeChannelPayment instance
+     */
+    MakeChannelPayment.create = function create(properties) {
+        return new MakeChannelPayment(properties);
+    };
+
+    /**
+     * Encodes the specified MakeChannelPayment message. Does not implicitly {@link MakeChannelPayment.verify|verify} messages.
+     * @function encode
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {IMakeChannelPayment} message MakeChannelPayment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MakeChannelPayment.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.rationale != null && Object.hasOwnProperty.call(message, "rationale"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.rationale);
+        if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
+            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.videoId);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified MakeChannelPayment message, length delimited. Does not implicitly {@link MakeChannelPayment.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {IMakeChannelPayment} message MakeChannelPayment message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MakeChannelPayment.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a MakeChannelPayment message from the specified reader or buffer.
+     * @function decode
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {MakeChannelPayment} MakeChannelPayment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MakeChannelPayment.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MakeChannelPayment();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.rationale = reader.string();
+                break;
+            case 2:
+                message.videoId = reader.uint64();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a MakeChannelPayment message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {MakeChannelPayment} MakeChannelPayment
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MakeChannelPayment.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a MakeChannelPayment message.
+     * @function verify
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    MakeChannelPayment.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.rationale != null && message.hasOwnProperty("rationale"))
+            if (!$util.isString(message.rationale))
+                return "rationale: string expected";
+        if (message.videoId != null && message.hasOwnProperty("videoId")) {
+            properties.paymentContext = 1;
+            if (!$util.isInteger(message.videoId) && !(message.videoId && $util.isInteger(message.videoId.low) && $util.isInteger(message.videoId.high)))
+                return "videoId: integer|Long expected";
+        }
+        return null;
+    };
+
+    /**
+     * Creates a MakeChannelPayment message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {MakeChannelPayment} MakeChannelPayment
+     */
+    MakeChannelPayment.fromObject = function fromObject(object) {
+        if (object instanceof $root.MakeChannelPayment)
+            return object;
+        var message = new $root.MakeChannelPayment();
+        if (object.rationale != null)
+            message.rationale = String(object.rationale);
+        if (object.videoId != null)
+            if ($util.Long)
+                (message.videoId = $util.Long.fromValue(object.videoId)).unsigned = true;
+            else if (typeof object.videoId === "string")
+                message.videoId = parseInt(object.videoId, 10);
+            else if (typeof object.videoId === "number")
+                message.videoId = object.videoId;
+            else if (typeof object.videoId === "object")
+                message.videoId = new $util.LongBits(object.videoId.low >>> 0, object.videoId.high >>> 0).toNumber(true);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a MakeChannelPayment message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof MakeChannelPayment
+     * @static
+     * @param {MakeChannelPayment} message MakeChannelPayment
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    MakeChannelPayment.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.rationale = "";
+        if (message.rationale != null && message.hasOwnProperty("rationale"))
+            object.rationale = message.rationale;
+        if (message.videoId != null && message.hasOwnProperty("videoId")) {
+            if (typeof message.videoId === "number")
+                object.videoId = options.longs === String ? String(message.videoId) : message.videoId;
+            else
+                object.videoId = options.longs === String ? $util.Long.prototype.toString.call(message.videoId) : options.longs === Number ? new $util.LongBits(message.videoId.low >>> 0, message.videoId.high >>> 0).toNumber(true) : message.videoId;
+            if (options.oneofs)
+                object.paymentContext = "videoId";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this MakeChannelPayment to JSON.
+     * @function toJSON
+     * @memberof MakeChannelPayment
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    MakeChannelPayment.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return MakeChannelPayment;
+})();
+
+$root.AppMetadata = (function() {
+
+    /**
+     * Properties of an AppMetadata.
+     * @exports IAppMetadata
+     * @interface IAppMetadata
+     * @property {string|null} [websiteUrl] AppMetadata websiteUrl
+     * @property {string|null} [useUri] AppMetadata useUri
+     * @property {string|null} [smallIcon] AppMetadata smallIcon
+     * @property {string|null} [mediumIcon] AppMetadata mediumIcon
+     * @property {string|null} [bigIcon] AppMetadata bigIcon
+     * @property {string|null} [oneLiner] AppMetadata oneLiner
+     * @property {string|null} [description] AppMetadata description
+     * @property {string|null} [termsOfService] AppMetadata termsOfService
+     * @property {string|null} [authKey] AppMetadata authKey
+     * @property {Array.<string>|null} [platforms] AppMetadata platforms
+     * @property {string|null} [category] AppMetadata category
+     */
+
+    /**
+     * Constructs a new AppMetadata.
+     * @exports AppMetadata
+     * @classdesc Represents an AppMetadata.
+     * @implements IAppMetadata
+     * @constructor
+     * @param {IAppMetadata=} [properties] Properties to set
+     */
+    function AppMetadata(properties) {
+        this.platforms = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * AppMetadata websiteUrl.
+     * @member {string} websiteUrl
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.websiteUrl = "";
+
+    /**
+     * AppMetadata useUri.
+     * @member {string} useUri
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.useUri = "";
+
+    /**
+     * AppMetadata smallIcon.
+     * @member {string} smallIcon
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.smallIcon = "";
+
+    /**
+     * AppMetadata mediumIcon.
+     * @member {string} mediumIcon
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.mediumIcon = "";
+
+    /**
+     * AppMetadata bigIcon.
+     * @member {string} bigIcon
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.bigIcon = "";
+
+    /**
+     * AppMetadata oneLiner.
+     * @member {string} oneLiner
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.oneLiner = "";
+
+    /**
+     * AppMetadata description.
+     * @member {string} description
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.description = "";
+
+    /**
+     * AppMetadata termsOfService.
+     * @member {string} termsOfService
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.termsOfService = "";
+
+    /**
+     * AppMetadata authKey.
+     * @member {string} authKey
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.authKey = "";
+
+    /**
+     * AppMetadata platforms.
+     * @member {Array.<string>} platforms
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.platforms = $util.emptyArray;
+
+    /**
+     * AppMetadata category.
+     * @member {string} category
+     * @memberof AppMetadata
+     * @instance
+     */
+    AppMetadata.prototype.category = "";
+
+    /**
+     * Creates a new AppMetadata instance using the specified properties.
+     * @function create
+     * @memberof AppMetadata
+     * @static
+     * @param {IAppMetadata=} [properties] Properties to set
+     * @returns {AppMetadata} AppMetadata instance
+     */
+    AppMetadata.create = function create(properties) {
+        return new AppMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified AppMetadata message. Does not implicitly {@link AppMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof AppMetadata
+     * @static
+     * @param {IAppMetadata} message AppMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AppMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.websiteUrl != null && Object.hasOwnProperty.call(message, "websiteUrl"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.websiteUrl);
+        if (message.useUri != null && Object.hasOwnProperty.call(message, "useUri"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.useUri);
+        if (message.smallIcon != null && Object.hasOwnProperty.call(message, "smallIcon"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.smallIcon);
+        if (message.mediumIcon != null && Object.hasOwnProperty.call(message, "mediumIcon"))
+            writer.uint32(/* id 5, wireType 2 =*/42).string(message.mediumIcon);
+        if (message.bigIcon != null && Object.hasOwnProperty.call(message, "bigIcon"))
+            writer.uint32(/* id 6, wireType 2 =*/50).string(message.bigIcon);
+        if (message.oneLiner != null && Object.hasOwnProperty.call(message, "oneLiner"))
+            writer.uint32(/* id 7, wireType 2 =*/58).string(message.oneLiner);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 8, wireType 2 =*/66).string(message.description);
+        if (message.termsOfService != null && Object.hasOwnProperty.call(message, "termsOfService"))
+            writer.uint32(/* id 9, wireType 2 =*/74).string(message.termsOfService);
+        if (message.authKey != null && Object.hasOwnProperty.call(message, "authKey"))
+            writer.uint32(/* id 10, wireType 2 =*/82).string(message.authKey);
+        if (message.platforms != null && message.platforms.length)
+            for (var i = 0; i < message.platforms.length; ++i)
+                writer.uint32(/* id 11, wireType 2 =*/90).string(message.platforms[i]);
+        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
+            writer.uint32(/* id 12, wireType 2 =*/98).string(message.category);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified AppMetadata message, length delimited. Does not implicitly {@link AppMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof AppMetadata
+     * @static
+     * @param {IAppMetadata} message AppMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AppMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an AppMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof AppMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {AppMetadata} AppMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AppMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AppMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 2:
+                message.websiteUrl = reader.string();
+                break;
+            case 3:
+                message.useUri = reader.string();
+                break;
+            case 4:
+                message.smallIcon = reader.string();
+                break;
+            case 5:
+                message.mediumIcon = reader.string();
+                break;
+            case 6:
+                message.bigIcon = reader.string();
+                break;
+            case 7:
+                message.oneLiner = reader.string();
+                break;
+            case 8:
+                message.description = reader.string();
+                break;
+            case 9:
+                message.termsOfService = reader.string();
+                break;
+            case 10:
+                message.authKey = reader.string();
+                break;
+            case 11:
+                if (!(message.platforms && message.platforms.length))
+                    message.platforms = [];
+                message.platforms.push(reader.string());
+                break;
+            case 12:
+                message.category = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes an AppMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof AppMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {AppMetadata} AppMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AppMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an AppMetadata message.
+     * @function verify
+     * @memberof AppMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    AppMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.websiteUrl != null && message.hasOwnProperty("websiteUrl"))
+            if (!$util.isString(message.websiteUrl))
+                return "websiteUrl: string expected";
+        if (message.useUri != null && message.hasOwnProperty("useUri"))
+            if (!$util.isString(message.useUri))
+                return "useUri: string expected";
+        if (message.smallIcon != null && message.hasOwnProperty("smallIcon"))
+            if (!$util.isString(message.smallIcon))
+                return "smallIcon: string expected";
+        if (message.mediumIcon != null && message.hasOwnProperty("mediumIcon"))
+            if (!$util.isString(message.mediumIcon))
+                return "mediumIcon: string expected";
+        if (message.bigIcon != null && message.hasOwnProperty("bigIcon"))
+            if (!$util.isString(message.bigIcon))
+                return "bigIcon: string expected";
+        if (message.oneLiner != null && message.hasOwnProperty("oneLiner"))
+            if (!$util.isString(message.oneLiner))
+                return "oneLiner: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.termsOfService != null && message.hasOwnProperty("termsOfService"))
+            if (!$util.isString(message.termsOfService))
+                return "termsOfService: string expected";
+        if (message.authKey != null && message.hasOwnProperty("authKey"))
+            if (!$util.isString(message.authKey))
+                return "authKey: string expected";
+        if (message.platforms != null && message.hasOwnProperty("platforms")) {
+            if (!Array.isArray(message.platforms))
+                return "platforms: array expected";
+            for (var i = 0; i < message.platforms.length; ++i)
+                if (!$util.isString(message.platforms[i]))
+                    return "platforms: string[] expected";
+        }
+        if (message.category != null && message.hasOwnProperty("category"))
+            if (!$util.isString(message.category))
+                return "category: string expected";
+        return null;
+    };
+
+    /**
+     * Creates an AppMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof AppMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {AppMetadata} AppMetadata
+     */
+    AppMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.AppMetadata)
+            return object;
+        var message = new $root.AppMetadata();
+        if (object.websiteUrl != null)
+            message.websiteUrl = String(object.websiteUrl);
+        if (object.useUri != null)
+            message.useUri = String(object.useUri);
+        if (object.smallIcon != null)
+            message.smallIcon = String(object.smallIcon);
+        if (object.mediumIcon != null)
+            message.mediumIcon = String(object.mediumIcon);
+        if (object.bigIcon != null)
+            message.bigIcon = String(object.bigIcon);
+        if (object.oneLiner != null)
+            message.oneLiner = String(object.oneLiner);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.termsOfService != null)
+            message.termsOfService = String(object.termsOfService);
+        if (object.authKey != null)
+            message.authKey = String(object.authKey);
+        if (object.platforms) {
+            if (!Array.isArray(object.platforms))
+                throw TypeError(".AppMetadata.platforms: array expected");
+            message.platforms = [];
+            for (var i = 0; i < object.platforms.length; ++i)
+                message.platforms[i] = String(object.platforms[i]);
+        }
+        if (object.category != null)
+            message.category = String(object.category);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an AppMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof AppMetadata
+     * @static
+     * @param {AppMetadata} message AppMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    AppMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.platforms = [];
+        if (options.defaults) {
+            object.websiteUrl = "";
+            object.useUri = "";
+            object.smallIcon = "";
+            object.mediumIcon = "";
+            object.bigIcon = "";
+            object.oneLiner = "";
+            object.description = "";
+            object.termsOfService = "";
+            object.authKey = "";
+            object.category = "";
+        }
+        if (message.websiteUrl != null && message.hasOwnProperty("websiteUrl"))
+            object.websiteUrl = message.websiteUrl;
+        if (message.useUri != null && message.hasOwnProperty("useUri"))
+            object.useUri = message.useUri;
+        if (message.smallIcon != null && message.hasOwnProperty("smallIcon"))
+            object.smallIcon = message.smallIcon;
+        if (message.mediumIcon != null && message.hasOwnProperty("mediumIcon"))
+            object.mediumIcon = message.mediumIcon;
+        if (message.bigIcon != null && message.hasOwnProperty("bigIcon"))
+            object.bigIcon = message.bigIcon;
+        if (message.oneLiner != null && message.hasOwnProperty("oneLiner"))
+            object.oneLiner = message.oneLiner;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.termsOfService != null && message.hasOwnProperty("termsOfService"))
+            object.termsOfService = message.termsOfService;
+        if (message.authKey != null && message.hasOwnProperty("authKey"))
+            object.authKey = message.authKey;
+        if (message.platforms && message.platforms.length) {
+            object.platforms = [];
+            for (var j = 0; j < message.platforms.length; ++j)
+                object.platforms[j] = message.platforms[j];
+        }
+        if (message.category != null && message.hasOwnProperty("category"))
+            object.category = message.category;
+        return object;
+    };
+
+    /**
+     * Converts this AppMetadata to JSON.
+     * @function toJSON
+     * @memberof AppMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    AppMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return AppMetadata;
+})();
+
+$root.CreateApp = (function() {
+
+    /**
+     * Properties of a CreateApp.
+     * @exports ICreateApp
+     * @interface ICreateApp
+     * @property {string} name CreateApp name
+     * @property {IAppMetadata|null} [appMetadata] CreateApp appMetadata
+     */
+
+    /**
+     * Constructs a new CreateApp.
+     * @exports CreateApp
+     * @classdesc Represents a CreateApp.
+     * @implements ICreateApp
+     * @constructor
+     * @param {ICreateApp=} [properties] Properties to set
+     */
+    function CreateApp(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * CreateApp name.
+     * @member {string} name
+     * @memberof CreateApp
+     * @instance
+     */
+    CreateApp.prototype.name = "";
+
+    /**
+     * CreateApp appMetadata.
+     * @member {IAppMetadata|null|undefined} appMetadata
+     * @memberof CreateApp
+     * @instance
+     */
+    CreateApp.prototype.appMetadata = null;
+
+    /**
+     * Creates a new CreateApp instance using the specified properties.
+     * @function create
+     * @memberof CreateApp
+     * @static
+     * @param {ICreateApp=} [properties] Properties to set
+     * @returns {CreateApp} CreateApp instance
+     */
+    CreateApp.create = function create(properties) {
+        return new CreateApp(properties);
+    };
+
+    /**
+     * Encodes the specified CreateApp message. Does not implicitly {@link CreateApp.verify|verify} messages.
+     * @function encode
+     * @memberof CreateApp
+     * @static
+     * @param {ICreateApp} message CreateApp message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreateApp.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
+        if (message.appMetadata != null && Object.hasOwnProperty.call(message, "appMetadata"))
+            $root.AppMetadata.encode(message.appMetadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified CreateApp message, length delimited. Does not implicitly {@link CreateApp.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof CreateApp
+     * @static
+     * @param {ICreateApp} message CreateApp message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreateApp.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a CreateApp message from the specified reader or buffer.
+     * @function decode
+     * @memberof CreateApp
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {CreateApp} CreateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreateApp.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreateApp();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.name = reader.string();
+                break;
+            case 2:
+                message.appMetadata = $root.AppMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("name"))
+            throw $util.ProtocolError("missing required 'name'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a CreateApp message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof CreateApp
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {CreateApp} CreateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreateApp.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a CreateApp message.
+     * @function verify
+     * @memberof CreateApp
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    CreateApp.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.name))
+            return "name: string expected";
+        if (message.appMetadata != null && message.hasOwnProperty("appMetadata")) {
+            var error = $root.AppMetadata.verify(message.appMetadata);
+            if (error)
+                return "appMetadata." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a CreateApp message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof CreateApp
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {CreateApp} CreateApp
+     */
+    CreateApp.fromObject = function fromObject(object) {
+        if (object instanceof $root.CreateApp)
+            return object;
+        var message = new $root.CreateApp();
+        if (object.name != null)
+            message.name = String(object.name);
+        if (object.appMetadata != null) {
+            if (typeof object.appMetadata !== "object")
+                throw TypeError(".CreateApp.appMetadata: object expected");
+            message.appMetadata = $root.AppMetadata.fromObject(object.appMetadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a CreateApp message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof CreateApp
+     * @static
+     * @param {CreateApp} message CreateApp
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    CreateApp.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.name = "";
+            object.appMetadata = null;
+        }
+        if (message.name != null && message.hasOwnProperty("name"))
+            object.name = message.name;
+        if (message.appMetadata != null && message.hasOwnProperty("appMetadata"))
+            object.appMetadata = $root.AppMetadata.toObject(message.appMetadata, options);
+        return object;
+    };
+
+    /**
+     * Converts this CreateApp to JSON.
+     * @function toJSON
+     * @memberof CreateApp
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    CreateApp.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return CreateApp;
+})();
+
+$root.UpdateApp = (function() {
+
+    /**
+     * Properties of an UpdateApp.
+     * @exports IUpdateApp
+     * @interface IUpdateApp
+     * @property {string} appId UpdateApp appId
+     * @property {IAppMetadata|null} [appMetadata] UpdateApp appMetadata
+     */
+
+    /**
+     * Constructs a new UpdateApp.
+     * @exports UpdateApp
+     * @classdesc Represents an UpdateApp.
+     * @implements IUpdateApp
+     * @constructor
+     * @param {IUpdateApp=} [properties] Properties to set
+     */
+    function UpdateApp(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * UpdateApp appId.
+     * @member {string} appId
+     * @memberof UpdateApp
+     * @instance
+     */
+    UpdateApp.prototype.appId = "";
+
+    /**
+     * UpdateApp appMetadata.
+     * @member {IAppMetadata|null|undefined} appMetadata
+     * @memberof UpdateApp
+     * @instance
+     */
+    UpdateApp.prototype.appMetadata = null;
+
+    /**
+     * Creates a new UpdateApp instance using the specified properties.
+     * @function create
+     * @memberof UpdateApp
+     * @static
+     * @param {IUpdateApp=} [properties] Properties to set
+     * @returns {UpdateApp} UpdateApp instance
+     */
+    UpdateApp.create = function create(properties) {
+        return new UpdateApp(properties);
+    };
+
+    /**
+     * Encodes the specified UpdateApp message. Does not implicitly {@link UpdateApp.verify|verify} messages.
+     * @function encode
+     * @memberof UpdateApp
+     * @static
+     * @param {IUpdateApp} message UpdateApp message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    UpdateApp.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.appId);
+        if (message.appMetadata != null && Object.hasOwnProperty.call(message, "appMetadata"))
+            $root.AppMetadata.encode(message.appMetadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified UpdateApp message, length delimited. Does not implicitly {@link UpdateApp.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof UpdateApp
+     * @static
+     * @param {IUpdateApp} message UpdateApp message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    UpdateApp.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an UpdateApp message from the specified reader or buffer.
+     * @function decode
+     * @memberof UpdateApp
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {UpdateApp} UpdateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    UpdateApp.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateApp();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.appId = reader.string();
+                break;
+            case 2:
+                message.appMetadata = $root.AppMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("appId"))
+            throw $util.ProtocolError("missing required 'appId'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes an UpdateApp message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof UpdateApp
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {UpdateApp} UpdateApp
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    UpdateApp.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an UpdateApp message.
+     * @function verify
+     * @memberof UpdateApp
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    UpdateApp.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.appId))
+            return "appId: string expected";
+        if (message.appMetadata != null && message.hasOwnProperty("appMetadata")) {
+            var error = $root.AppMetadata.verify(message.appMetadata);
+            if (error)
+                return "appMetadata." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates an UpdateApp message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof UpdateApp
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {UpdateApp} UpdateApp
+     */
+    UpdateApp.fromObject = function fromObject(object) {
+        if (object instanceof $root.UpdateApp)
+            return object;
+        var message = new $root.UpdateApp();
+        if (object.appId != null)
+            message.appId = String(object.appId);
+        if (object.appMetadata != null) {
+            if (typeof object.appMetadata !== "object")
+                throw TypeError(".UpdateApp.appMetadata: object expected");
+            message.appMetadata = $root.AppMetadata.fromObject(object.appMetadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an UpdateApp message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof UpdateApp
+     * @static
+     * @param {UpdateApp} message UpdateApp
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    UpdateApp.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.appId = "";
+            object.appMetadata = null;
+        }
+        if (message.appId != null && message.hasOwnProperty("appId"))
+            object.appId = message.appId;
+        if (message.appMetadata != null && message.hasOwnProperty("appMetadata"))
+            object.appMetadata = $root.AppMetadata.toObject(message.appMetadata, options);
+        return object;
+    };
+
+    /**
+     * Converts this UpdateApp to JSON.
+     * @function toJSON
+     * @memberof UpdateApp
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    UpdateApp.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return UpdateApp;
+})();
+
+$root.MemberRemarked = (function() {
+
+    /**
+     * Properties of a MemberRemarked.
+     * @exports IMemberRemarked
+     * @interface IMemberRemarked
+     * @property {IReactVideo|null} [reactVideo] MemberRemarked reactVideo
+     * @property {IReactComment|null} [reactComment] MemberRemarked reactComment
+     * @property {ICreateComment|null} [createComment] MemberRemarked createComment
+     * @property {IEditComment|null} [editComment] MemberRemarked editComment
+     * @property {IDeleteComment|null} [deleteComment] MemberRemarked deleteComment
+     * @property {ICreateVideoCategory|null} [createVideoCategory] MemberRemarked createVideoCategory
+     * @property {ICreateApp|null} [createApp] MemberRemarked createApp
+     * @property {IUpdateApp|null} [updateApp] MemberRemarked updateApp
+     * @property {IMakeChannelPayment|null} [makeChannelPayment] MemberRemarked makeChannelPayment
+     */
+
+    /**
+     * Constructs a new MemberRemarked.
+     * @exports MemberRemarked
+     * @classdesc Represents a MemberRemarked.
+     * @implements IMemberRemarked
+     * @constructor
+     * @param {IMemberRemarked=} [properties] Properties to set
+     */
+    function MemberRemarked(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * MemberRemarked reactVideo.
+     * @member {IReactVideo|null|undefined} reactVideo
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.reactVideo = null;
+
+    /**
+     * MemberRemarked reactComment.
+     * @member {IReactComment|null|undefined} reactComment
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.reactComment = null;
+
+    /**
+     * MemberRemarked createComment.
+     * @member {ICreateComment|null|undefined} createComment
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.createComment = null;
+
+    /**
+     * MemberRemarked editComment.
+     * @member {IEditComment|null|undefined} editComment
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.editComment = null;
+
+    /**
+     * MemberRemarked deleteComment.
+     * @member {IDeleteComment|null|undefined} deleteComment
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.deleteComment = null;
+
+    /**
+     * MemberRemarked createVideoCategory.
+     * @member {ICreateVideoCategory|null|undefined} createVideoCategory
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.createVideoCategory = null;
+
+    /**
+     * MemberRemarked createApp.
+     * @member {ICreateApp|null|undefined} createApp
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.createApp = null;
+
+    /**
+     * MemberRemarked updateApp.
+     * @member {IUpdateApp|null|undefined} updateApp
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.updateApp = null;
+
+    /**
+     * MemberRemarked makeChannelPayment.
+     * @member {IMakeChannelPayment|null|undefined} makeChannelPayment
+     * @memberof MemberRemarked
+     * @instance
+     */
+    MemberRemarked.prototype.makeChannelPayment = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * MemberRemarked memberRemarked.
+     * @member {"reactVideo"|"reactComment"|"createComment"|"editComment"|"deleteComment"|"createVideoCategory"|"createApp"|"updateApp"|"makeChannelPayment"|undefined} memberRemarked
+     * @memberof MemberRemarked
+     * @instance
+     */
+    Object.defineProperty(MemberRemarked.prototype, "memberRemarked", {
+        get: $util.oneOfGetter($oneOfFields = ["reactVideo", "reactComment", "createComment", "editComment", "deleteComment", "createVideoCategory", "createApp", "updateApp", "makeChannelPayment"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new MemberRemarked instance using the specified properties.
+     * @function create
+     * @memberof MemberRemarked
+     * @static
+     * @param {IMemberRemarked=} [properties] Properties to set
+     * @returns {MemberRemarked} MemberRemarked instance
+     */
+    MemberRemarked.create = function create(properties) {
+        return new MemberRemarked(properties);
+    };
+
+    /**
+     * Encodes the specified MemberRemarked message. Does not implicitly {@link MemberRemarked.verify|verify} messages.
+     * @function encode
+     * @memberof MemberRemarked
+     * @static
+     * @param {IMemberRemarked} message MemberRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MemberRemarked.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.reactVideo != null && Object.hasOwnProperty.call(message, "reactVideo"))
+            $root.ReactVideo.encode(message.reactVideo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        if (message.reactComment != null && Object.hasOwnProperty.call(message, "reactComment"))
+            $root.ReactComment.encode(message.reactComment, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        if (message.createComment != null && Object.hasOwnProperty.call(message, "createComment"))
+            $root.CreateComment.encode(message.createComment, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
+        if (message.editComment != null && Object.hasOwnProperty.call(message, "editComment"))
+            $root.EditComment.encode(message.editComment, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
+        if (message.deleteComment != null && Object.hasOwnProperty.call(message, "deleteComment"))
+            $root.DeleteComment.encode(message.deleteComment, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
+        if (message.createVideoCategory != null && Object.hasOwnProperty.call(message, "createVideoCategory"))
+            $root.CreateVideoCategory.encode(message.createVideoCategory, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
+        if (message.createApp != null && Object.hasOwnProperty.call(message, "createApp"))
+            $root.CreateApp.encode(message.createApp, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
+        if (message.updateApp != null && Object.hasOwnProperty.call(message, "updateApp"))
+            $root.UpdateApp.encode(message.updateApp, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
+        if (message.makeChannelPayment != null && Object.hasOwnProperty.call(message, "makeChannelPayment"))
+            $root.MakeChannelPayment.encode(message.makeChannelPayment, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified MemberRemarked message, length delimited. Does not implicitly {@link MemberRemarked.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof MemberRemarked
+     * @static
+     * @param {IMemberRemarked} message MemberRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MemberRemarked.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a MemberRemarked message from the specified reader or buffer.
+     * @function decode
+     * @memberof MemberRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {MemberRemarked} MemberRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MemberRemarked.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MemberRemarked();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.reactVideo = $root.ReactVideo.decode(reader, reader.uint32());
+                break;
+            case 2:
+                message.reactComment = $root.ReactComment.decode(reader, reader.uint32());
+                break;
+            case 3:
+                message.createComment = $root.CreateComment.decode(reader, reader.uint32());
+                break;
+            case 4:
+                message.editComment = $root.EditComment.decode(reader, reader.uint32());
+                break;
+            case 5:
+                message.deleteComment = $root.DeleteComment.decode(reader, reader.uint32());
+                break;
+            case 6:
+                message.createVideoCategory = $root.CreateVideoCategory.decode(reader, reader.uint32());
+                break;
+            case 7:
+                message.createApp = $root.CreateApp.decode(reader, reader.uint32());
+                break;
+            case 8:
+                message.updateApp = $root.UpdateApp.decode(reader, reader.uint32());
+                break;
+            case 10:
+                message.makeChannelPayment = $root.MakeChannelPayment.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a MemberRemarked message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof MemberRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {MemberRemarked} MemberRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MemberRemarked.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a MemberRemarked message.
+     * @function verify
+     * @memberof MemberRemarked
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    MemberRemarked.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.reactVideo != null && message.hasOwnProperty("reactVideo")) {
+            properties.memberRemarked = 1;
+            {
+                var error = $root.ReactVideo.verify(message.reactVideo);
+                if (error)
+                    return "reactVideo." + error;
+            }
+        }
+        if (message.reactComment != null && message.hasOwnProperty("reactComment")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.ReactComment.verify(message.reactComment);
+                if (error)
+                    return "reactComment." + error;
+            }
+        }
+        if (message.createComment != null && message.hasOwnProperty("createComment")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.CreateComment.verify(message.createComment);
+                if (error)
+                    return "createComment." + error;
+            }
+        }
+        if (message.editComment != null && message.hasOwnProperty("editComment")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.EditComment.verify(message.editComment);
+                if (error)
+                    return "editComment." + error;
+            }
+        }
+        if (message.deleteComment != null && message.hasOwnProperty("deleteComment")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.DeleteComment.verify(message.deleteComment);
+                if (error)
+                    return "deleteComment." + error;
+            }
+        }
+        if (message.createVideoCategory != null && message.hasOwnProperty("createVideoCategory")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.CreateVideoCategory.verify(message.createVideoCategory);
+                if (error)
+                    return "createVideoCategory." + error;
+            }
+        }
+        if (message.createApp != null && message.hasOwnProperty("createApp")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.CreateApp.verify(message.createApp);
+                if (error)
+                    return "createApp." + error;
+            }
+        }
+        if (message.updateApp != null && message.hasOwnProperty("updateApp")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.UpdateApp.verify(message.updateApp);
+                if (error)
+                    return "updateApp." + error;
+            }
+        }
+        if (message.makeChannelPayment != null && message.hasOwnProperty("makeChannelPayment")) {
+            if (properties.memberRemarked === 1)
+                return "memberRemarked: multiple values";
+            properties.memberRemarked = 1;
+            {
+                var error = $root.MakeChannelPayment.verify(message.makeChannelPayment);
+                if (error)
+                    return "makeChannelPayment." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a MemberRemarked message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof MemberRemarked
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {MemberRemarked} MemberRemarked
+     */
+    MemberRemarked.fromObject = function fromObject(object) {
+        if (object instanceof $root.MemberRemarked)
+            return object;
+        var message = new $root.MemberRemarked();
+        if (object.reactVideo != null) {
+            if (typeof object.reactVideo !== "object")
+                throw TypeError(".MemberRemarked.reactVideo: object expected");
+            message.reactVideo = $root.ReactVideo.fromObject(object.reactVideo);
+        }
+        if (object.reactComment != null) {
+            if (typeof object.reactComment !== "object")
+                throw TypeError(".MemberRemarked.reactComment: object expected");
+            message.reactComment = $root.ReactComment.fromObject(object.reactComment);
+        }
+        if (object.createComment != null) {
+            if (typeof object.createComment !== "object")
+                throw TypeError(".MemberRemarked.createComment: object expected");
+            message.createComment = $root.CreateComment.fromObject(object.createComment);
+        }
+        if (object.editComment != null) {
+            if (typeof object.editComment !== "object")
+                throw TypeError(".MemberRemarked.editComment: object expected");
+            message.editComment = $root.EditComment.fromObject(object.editComment);
+        }
+        if (object.deleteComment != null) {
+            if (typeof object.deleteComment !== "object")
+                throw TypeError(".MemberRemarked.deleteComment: object expected");
+            message.deleteComment = $root.DeleteComment.fromObject(object.deleteComment);
+        }
+        if (object.createVideoCategory != null) {
+            if (typeof object.createVideoCategory !== "object")
+                throw TypeError(".MemberRemarked.createVideoCategory: object expected");
+            message.createVideoCategory = $root.CreateVideoCategory.fromObject(object.createVideoCategory);
+        }
+        if (object.createApp != null) {
+            if (typeof object.createApp !== "object")
+                throw TypeError(".MemberRemarked.createApp: object expected");
+            message.createApp = $root.CreateApp.fromObject(object.createApp);
+        }
+        if (object.updateApp != null) {
+            if (typeof object.updateApp !== "object")
+                throw TypeError(".MemberRemarked.updateApp: object expected");
+            message.updateApp = $root.UpdateApp.fromObject(object.updateApp);
+        }
+        if (object.makeChannelPayment != null) {
+            if (typeof object.makeChannelPayment !== "object")
+                throw TypeError(".MemberRemarked.makeChannelPayment: object expected");
+            message.makeChannelPayment = $root.MakeChannelPayment.fromObject(object.makeChannelPayment);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a MemberRemarked message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof MemberRemarked
+     * @static
+     * @param {MemberRemarked} message MemberRemarked
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    MemberRemarked.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.reactVideo != null && message.hasOwnProperty("reactVideo")) {
+            object.reactVideo = $root.ReactVideo.toObject(message.reactVideo, options);
+            if (options.oneofs)
+                object.memberRemarked = "reactVideo";
+        }
+        if (message.reactComment != null && message.hasOwnProperty("reactComment")) {
+            object.reactComment = $root.ReactComment.toObject(message.reactComment, options);
+            if (options.oneofs)
+                object.memberRemarked = "reactComment";
+        }
+        if (message.createComment != null && message.hasOwnProperty("createComment")) {
+            object.createComment = $root.CreateComment.toObject(message.createComment, options);
+            if (options.oneofs)
+                object.memberRemarked = "createComment";
+        }
+        if (message.editComment != null && message.hasOwnProperty("editComment")) {
+            object.editComment = $root.EditComment.toObject(message.editComment, options);
+            if (options.oneofs)
+                object.memberRemarked = "editComment";
+        }
+        if (message.deleteComment != null && message.hasOwnProperty("deleteComment")) {
+            object.deleteComment = $root.DeleteComment.toObject(message.deleteComment, options);
+            if (options.oneofs)
+                object.memberRemarked = "deleteComment";
+        }
+        if (message.createVideoCategory != null && message.hasOwnProperty("createVideoCategory")) {
+            object.createVideoCategory = $root.CreateVideoCategory.toObject(message.createVideoCategory, options);
+            if (options.oneofs)
+                object.memberRemarked = "createVideoCategory";
+        }
+        if (message.createApp != null && message.hasOwnProperty("createApp")) {
+            object.createApp = $root.CreateApp.toObject(message.createApp, options);
+            if (options.oneofs)
+                object.memberRemarked = "createApp";
+        }
+        if (message.updateApp != null && message.hasOwnProperty("updateApp")) {
+            object.updateApp = $root.UpdateApp.toObject(message.updateApp, options);
+            if (options.oneofs)
+                object.memberRemarked = "updateApp";
+        }
+        if (message.makeChannelPayment != null && message.hasOwnProperty("makeChannelPayment")) {
+            object.makeChannelPayment = $root.MakeChannelPayment.toObject(message.makeChannelPayment, options);
+            if (options.oneofs)
+                object.memberRemarked = "makeChannelPayment";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this MemberRemarked to JSON.
+     * @function toJSON
+     * @memberof MemberRemarked
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    MemberRemarked.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return MemberRemarked;
+})();
+
+$root.ChannelModeratorRemarked = (function() {
+
+    /**
+     * Properties of a ChannelModeratorRemarked.
+     * @exports IChannelModeratorRemarked
+     * @interface IChannelModeratorRemarked
+     * @property {IModerateComment|null} [moderateComment] ChannelModeratorRemarked moderateComment
+     */
+
+    /**
+     * Constructs a new ChannelModeratorRemarked.
+     * @exports ChannelModeratorRemarked
+     * @classdesc Represents a ChannelModeratorRemarked.
+     * @implements IChannelModeratorRemarked
+     * @constructor
+     * @param {IChannelModeratorRemarked=} [properties] Properties to set
+     */
+    function ChannelModeratorRemarked(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ChannelModeratorRemarked moderateComment.
+     * @member {IModerateComment|null|undefined} moderateComment
+     * @memberof ChannelModeratorRemarked
+     * @instance
+     */
+    ChannelModeratorRemarked.prototype.moderateComment = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * ChannelModeratorRemarked channelModeratorRemarked.
+     * @member {"moderateComment"|undefined} channelModeratorRemarked
+     * @memberof ChannelModeratorRemarked
+     * @instance
+     */
+    Object.defineProperty(ChannelModeratorRemarked.prototype, "channelModeratorRemarked", {
+        get: $util.oneOfGetter($oneOfFields = ["moderateComment"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new ChannelModeratorRemarked instance using the specified properties.
+     * @function create
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {IChannelModeratorRemarked=} [properties] Properties to set
+     * @returns {ChannelModeratorRemarked} ChannelModeratorRemarked instance
+     */
+    ChannelModeratorRemarked.create = function create(properties) {
+        return new ChannelModeratorRemarked(properties);
+    };
+
+    /**
+     * Encodes the specified ChannelModeratorRemarked message. Does not implicitly {@link ChannelModeratorRemarked.verify|verify} messages.
+     * @function encode
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {IChannelModeratorRemarked} message ChannelModeratorRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelModeratorRemarked.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.moderateComment != null && Object.hasOwnProperty.call(message, "moderateComment"))
+            $root.ModerateComment.encode(message.moderateComment, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ChannelModeratorRemarked message, length delimited. Does not implicitly {@link ChannelModeratorRemarked.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {IChannelModeratorRemarked} message ChannelModeratorRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelModeratorRemarked.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ChannelModeratorRemarked message from the specified reader or buffer.
+     * @function decode
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ChannelModeratorRemarked} ChannelModeratorRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelModeratorRemarked.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelModeratorRemarked();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.moderateComment = $root.ModerateComment.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a ChannelModeratorRemarked message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ChannelModeratorRemarked} ChannelModeratorRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelModeratorRemarked.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ChannelModeratorRemarked message.
+     * @function verify
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ChannelModeratorRemarked.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.moderateComment != null && message.hasOwnProperty("moderateComment")) {
+            properties.channelModeratorRemarked = 1;
+            {
+                var error = $root.ModerateComment.verify(message.moderateComment);
+                if (error)
+                    return "moderateComment." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a ChannelModeratorRemarked message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ChannelModeratorRemarked} ChannelModeratorRemarked
+     */
+    ChannelModeratorRemarked.fromObject = function fromObject(object) {
+        if (object instanceof $root.ChannelModeratorRemarked)
+            return object;
+        var message = new $root.ChannelModeratorRemarked();
+        if (object.moderateComment != null) {
+            if (typeof object.moderateComment !== "object")
+                throw TypeError(".ChannelModeratorRemarked.moderateComment: object expected");
+            message.moderateComment = $root.ModerateComment.fromObject(object.moderateComment);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ChannelModeratorRemarked message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ChannelModeratorRemarked
+     * @static
+     * @param {ChannelModeratorRemarked} message ChannelModeratorRemarked
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ChannelModeratorRemarked.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.moderateComment != null && message.hasOwnProperty("moderateComment")) {
+            object.moderateComment = $root.ModerateComment.toObject(message.moderateComment, options);
+            if (options.oneofs)
+                object.channelModeratorRemarked = "moderateComment";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this ChannelModeratorRemarked to JSON.
+     * @function toJSON
+     * @memberof ChannelModeratorRemarked
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ChannelModeratorRemarked.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ChannelModeratorRemarked;
+})();
+
+$root.ChannelOwnerRemarked = (function() {
+
+    /**
+     * Properties of a ChannelOwnerRemarked.
+     * @exports IChannelOwnerRemarked
+     * @interface IChannelOwnerRemarked
+     * @property {IPinOrUnpinComment|null} [pinOrUnpinComment] ChannelOwnerRemarked pinOrUnpinComment
+     * @property {IBanOrUnbanMemberFromChannel|null} [banOrUnbanMemberFromChannel] ChannelOwnerRemarked banOrUnbanMemberFromChannel
+     * @property {IVideoReactionsPreference|null} [videoReactionsPreference] ChannelOwnerRemarked videoReactionsPreference
+     * @property {IModerateComment|null} [moderateComment] ChannelOwnerRemarked moderateComment
+     */
+
+    /**
+     * Constructs a new ChannelOwnerRemarked.
+     * @exports ChannelOwnerRemarked
+     * @classdesc Represents a ChannelOwnerRemarked.
+     * @implements IChannelOwnerRemarked
+     * @constructor
+     * @param {IChannelOwnerRemarked=} [properties] Properties to set
+     */
+    function ChannelOwnerRemarked(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ChannelOwnerRemarked pinOrUnpinComment.
+     * @member {IPinOrUnpinComment|null|undefined} pinOrUnpinComment
+     * @memberof ChannelOwnerRemarked
+     * @instance
+     */
+    ChannelOwnerRemarked.prototype.pinOrUnpinComment = null;
+
+    /**
+     * ChannelOwnerRemarked banOrUnbanMemberFromChannel.
+     * @member {IBanOrUnbanMemberFromChannel|null|undefined} banOrUnbanMemberFromChannel
+     * @memberof ChannelOwnerRemarked
+     * @instance
+     */
+    ChannelOwnerRemarked.prototype.banOrUnbanMemberFromChannel = null;
+
+    /**
+     * ChannelOwnerRemarked videoReactionsPreference.
+     * @member {IVideoReactionsPreference|null|undefined} videoReactionsPreference
+     * @memberof ChannelOwnerRemarked
+     * @instance
+     */
+    ChannelOwnerRemarked.prototype.videoReactionsPreference = null;
+
+    /**
+     * ChannelOwnerRemarked moderateComment.
+     * @member {IModerateComment|null|undefined} moderateComment
+     * @memberof ChannelOwnerRemarked
+     * @instance
+     */
+    ChannelOwnerRemarked.prototype.moderateComment = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * ChannelOwnerRemarked channelOwnerRemarked.
+     * @member {"pinOrUnpinComment"|"banOrUnbanMemberFromChannel"|"videoReactionsPreference"|"moderateComment"|undefined} channelOwnerRemarked
+     * @memberof ChannelOwnerRemarked
+     * @instance
+     */
+    Object.defineProperty(ChannelOwnerRemarked.prototype, "channelOwnerRemarked", {
+        get: $util.oneOfGetter($oneOfFields = ["pinOrUnpinComment", "banOrUnbanMemberFromChannel", "videoReactionsPreference", "moderateComment"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new ChannelOwnerRemarked instance using the specified properties.
+     * @function create
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {IChannelOwnerRemarked=} [properties] Properties to set
+     * @returns {ChannelOwnerRemarked} ChannelOwnerRemarked instance
+     */
+    ChannelOwnerRemarked.create = function create(properties) {
+        return new ChannelOwnerRemarked(properties);
+    };
+
+    /**
+     * Encodes the specified ChannelOwnerRemarked message. Does not implicitly {@link ChannelOwnerRemarked.verify|verify} messages.
+     * @function encode
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {IChannelOwnerRemarked} message ChannelOwnerRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelOwnerRemarked.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.pinOrUnpinComment != null && Object.hasOwnProperty.call(message, "pinOrUnpinComment"))
+            $root.PinOrUnpinComment.encode(message.pinOrUnpinComment, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        if (message.banOrUnbanMemberFromChannel != null && Object.hasOwnProperty.call(message, "banOrUnbanMemberFromChannel"))
+            $root.BanOrUnbanMemberFromChannel.encode(message.banOrUnbanMemberFromChannel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        if (message.videoReactionsPreference != null && Object.hasOwnProperty.call(message, "videoReactionsPreference"))
+            $root.VideoReactionsPreference.encode(message.videoReactionsPreference, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
+        if (message.moderateComment != null && Object.hasOwnProperty.call(message, "moderateComment"))
+            $root.ModerateComment.encode(message.moderateComment, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ChannelOwnerRemarked message, length delimited. Does not implicitly {@link ChannelOwnerRemarked.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {IChannelOwnerRemarked} message ChannelOwnerRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ChannelOwnerRemarked.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ChannelOwnerRemarked message from the specified reader or buffer.
+     * @function decode
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ChannelOwnerRemarked} ChannelOwnerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelOwnerRemarked.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelOwnerRemarked();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.pinOrUnpinComment = $root.PinOrUnpinComment.decode(reader, reader.uint32());
+                break;
+            case 2:
+                message.banOrUnbanMemberFromChannel = $root.BanOrUnbanMemberFromChannel.decode(reader, reader.uint32());
+                break;
+            case 3:
+                message.videoReactionsPreference = $root.VideoReactionsPreference.decode(reader, reader.uint32());
+                break;
+            case 5:
+                message.moderateComment = $root.ModerateComment.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a ChannelOwnerRemarked message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ChannelOwnerRemarked} ChannelOwnerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ChannelOwnerRemarked.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ChannelOwnerRemarked message.
+     * @function verify
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ChannelOwnerRemarked.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.pinOrUnpinComment != null && message.hasOwnProperty("pinOrUnpinComment")) {
+            properties.channelOwnerRemarked = 1;
+            {
+                var error = $root.PinOrUnpinComment.verify(message.pinOrUnpinComment);
+                if (error)
+                    return "pinOrUnpinComment." + error;
+            }
+        }
+        if (message.banOrUnbanMemberFromChannel != null && message.hasOwnProperty("banOrUnbanMemberFromChannel")) {
+            if (properties.channelOwnerRemarked === 1)
+                return "channelOwnerRemarked: multiple values";
+            properties.channelOwnerRemarked = 1;
+            {
+                var error = $root.BanOrUnbanMemberFromChannel.verify(message.banOrUnbanMemberFromChannel);
+                if (error)
+                    return "banOrUnbanMemberFromChannel." + error;
+            }
+        }
+        if (message.videoReactionsPreference != null && message.hasOwnProperty("videoReactionsPreference")) {
+            if (properties.channelOwnerRemarked === 1)
+                return "channelOwnerRemarked: multiple values";
+            properties.channelOwnerRemarked = 1;
+            {
+                var error = $root.VideoReactionsPreference.verify(message.videoReactionsPreference);
+                if (error)
+                    return "videoReactionsPreference." + error;
+            }
+        }
+        if (message.moderateComment != null && message.hasOwnProperty("moderateComment")) {
+            if (properties.channelOwnerRemarked === 1)
+                return "channelOwnerRemarked: multiple values";
+            properties.channelOwnerRemarked = 1;
+            {
+                var error = $root.ModerateComment.verify(message.moderateComment);
+                if (error)
+                    return "moderateComment." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a ChannelOwnerRemarked message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ChannelOwnerRemarked} ChannelOwnerRemarked
+     */
+    ChannelOwnerRemarked.fromObject = function fromObject(object) {
+        if (object instanceof $root.ChannelOwnerRemarked)
+            return object;
+        var message = new $root.ChannelOwnerRemarked();
+        if (object.pinOrUnpinComment != null) {
+            if (typeof object.pinOrUnpinComment !== "object")
+                throw TypeError(".ChannelOwnerRemarked.pinOrUnpinComment: object expected");
+            message.pinOrUnpinComment = $root.PinOrUnpinComment.fromObject(object.pinOrUnpinComment);
+        }
+        if (object.banOrUnbanMemberFromChannel != null) {
+            if (typeof object.banOrUnbanMemberFromChannel !== "object")
+                throw TypeError(".ChannelOwnerRemarked.banOrUnbanMemberFromChannel: object expected");
+            message.banOrUnbanMemberFromChannel = $root.BanOrUnbanMemberFromChannel.fromObject(object.banOrUnbanMemberFromChannel);
+        }
+        if (object.videoReactionsPreference != null) {
+            if (typeof object.videoReactionsPreference !== "object")
+                throw TypeError(".ChannelOwnerRemarked.videoReactionsPreference: object expected");
+            message.videoReactionsPreference = $root.VideoReactionsPreference.fromObject(object.videoReactionsPreference);
+        }
+        if (object.moderateComment != null) {
+            if (typeof object.moderateComment !== "object")
+                throw TypeError(".ChannelOwnerRemarked.moderateComment: object expected");
+            message.moderateComment = $root.ModerateComment.fromObject(object.moderateComment);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ChannelOwnerRemarked message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ChannelOwnerRemarked
+     * @static
+     * @param {ChannelOwnerRemarked} message ChannelOwnerRemarked
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ChannelOwnerRemarked.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.pinOrUnpinComment != null && message.hasOwnProperty("pinOrUnpinComment")) {
+            object.pinOrUnpinComment = $root.PinOrUnpinComment.toObject(message.pinOrUnpinComment, options);
+            if (options.oneofs)
+                object.channelOwnerRemarked = "pinOrUnpinComment";
+        }
+        if (message.banOrUnbanMemberFromChannel != null && message.hasOwnProperty("banOrUnbanMemberFromChannel")) {
+            object.banOrUnbanMemberFromChannel = $root.BanOrUnbanMemberFromChannel.toObject(message.banOrUnbanMemberFromChannel, options);
+            if (options.oneofs)
+                object.channelOwnerRemarked = "banOrUnbanMemberFromChannel";
+        }
+        if (message.videoReactionsPreference != null && message.hasOwnProperty("videoReactionsPreference")) {
+            object.videoReactionsPreference = $root.VideoReactionsPreference.toObject(message.videoReactionsPreference, options);
+            if (options.oneofs)
+                object.channelOwnerRemarked = "videoReactionsPreference";
+        }
+        if (message.moderateComment != null && message.hasOwnProperty("moderateComment")) {
+            object.moderateComment = $root.ModerateComment.toObject(message.moderateComment, options);
+            if (options.oneofs)
+                object.channelOwnerRemarked = "moderateComment";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this ChannelOwnerRemarked to JSON.
+     * @function toJSON
+     * @memberof ChannelOwnerRemarked
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ChannelOwnerRemarked.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ChannelOwnerRemarked;
+})();
+
+$root.PersonMetadata = (function() {
+
+    /**
+     * Properties of a PersonMetadata.
+     * @exports IPersonMetadata
+     * @interface IPersonMetadata
+     * @property {string|null} [firstName] PersonMetadata firstName
+     * @property {string|null} [middleName] PersonMetadata middleName
+     * @property {string|null} [lastName] PersonMetadata lastName
+     * @property {string|null} [about] PersonMetadata about
+     * @property {number|null} [coverPhoto] PersonMetadata coverPhoto
+     * @property {number|null} [avatarPhoto] PersonMetadata avatarPhoto
+     */
+
+    /**
+     * Constructs a new PersonMetadata.
+     * @exports PersonMetadata
+     * @classdesc Represents a PersonMetadata.
+     * @implements IPersonMetadata
+     * @constructor
+     * @param {IPersonMetadata=} [properties] Properties to set
+     */
+    function PersonMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * PersonMetadata firstName.
+     * @member {string} firstName
+     * @memberof PersonMetadata
+     * @instance
+     */
+    PersonMetadata.prototype.firstName = "";
+
+    /**
+     * PersonMetadata middleName.
+     * @member {string} middleName
+     * @memberof PersonMetadata
+     * @instance
+     */
+    PersonMetadata.prototype.middleName = "";
+
+    /**
+     * PersonMetadata lastName.
+     * @member {string} lastName
+     * @memberof PersonMetadata
+     * @instance
+     */
+    PersonMetadata.prototype.lastName = "";
+
+    /**
+     * PersonMetadata about.
+     * @member {string} about
+     * @memberof PersonMetadata
+     * @instance
+     */
+    PersonMetadata.prototype.about = "";
+
+    /**
+     * PersonMetadata coverPhoto.
+     * @member {number} coverPhoto
+     * @memberof PersonMetadata
+     * @instance
+     */
+    PersonMetadata.prototype.coverPhoto = 0;
+
+    /**
+     * PersonMetadata avatarPhoto.
+     * @member {number} avatarPhoto
+     * @memberof PersonMetadata
+     * @instance
+     */
+    PersonMetadata.prototype.avatarPhoto = 0;
+
+    /**
+     * Creates a new PersonMetadata instance using the specified properties.
+     * @function create
+     * @memberof PersonMetadata
+     * @static
+     * @param {IPersonMetadata=} [properties] Properties to set
+     * @returns {PersonMetadata} PersonMetadata instance
+     */
+    PersonMetadata.create = function create(properties) {
+        return new PersonMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified PersonMetadata message. Does not implicitly {@link PersonMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof PersonMetadata
+     * @static
+     * @param {IPersonMetadata} message PersonMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    PersonMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.firstName != null && Object.hasOwnProperty.call(message, "firstName"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.firstName);
+        if (message.middleName != null && Object.hasOwnProperty.call(message, "middleName"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.middleName);
+        if (message.lastName != null && Object.hasOwnProperty.call(message, "lastName"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.lastName);
+        if (message.about != null && Object.hasOwnProperty.call(message, "about"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.about);
+        if (message.coverPhoto != null && Object.hasOwnProperty.call(message, "coverPhoto"))
+            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.coverPhoto);
+        if (message.avatarPhoto != null && Object.hasOwnProperty.call(message, "avatarPhoto"))
+            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.avatarPhoto);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified PersonMetadata message, length delimited. Does not implicitly {@link PersonMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof PersonMetadata
+     * @static
+     * @param {IPersonMetadata} message PersonMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    PersonMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a PersonMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof PersonMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {PersonMetadata} PersonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    PersonMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PersonMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.firstName = reader.string();
+                break;
+            case 2:
+                message.middleName = reader.string();
+                break;
+            case 3:
+                message.lastName = reader.string();
+                break;
+            case 4:
+                message.about = reader.string();
+                break;
+            case 5:
+                message.coverPhoto = reader.uint32();
+                break;
+            case 6:
+                message.avatarPhoto = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a PersonMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof PersonMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {PersonMetadata} PersonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    PersonMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a PersonMetadata message.
+     * @function verify
+     * @memberof PersonMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    PersonMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.firstName != null && message.hasOwnProperty("firstName"))
+            if (!$util.isString(message.firstName))
+                return "firstName: string expected";
+        if (message.middleName != null && message.hasOwnProperty("middleName"))
+            if (!$util.isString(message.middleName))
+                return "middleName: string expected";
+        if (message.lastName != null && message.hasOwnProperty("lastName"))
+            if (!$util.isString(message.lastName))
+                return "lastName: string expected";
+        if (message.about != null && message.hasOwnProperty("about"))
+            if (!$util.isString(message.about))
+                return "about: string expected";
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            if (!$util.isInteger(message.coverPhoto))
+                return "coverPhoto: integer expected";
+        if (message.avatarPhoto != null && message.hasOwnProperty("avatarPhoto"))
+            if (!$util.isInteger(message.avatarPhoto))
+                return "avatarPhoto: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a PersonMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof PersonMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {PersonMetadata} PersonMetadata
+     */
+    PersonMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.PersonMetadata)
+            return object;
+        var message = new $root.PersonMetadata();
+        if (object.firstName != null)
+            message.firstName = String(object.firstName);
+        if (object.middleName != null)
+            message.middleName = String(object.middleName);
+        if (object.lastName != null)
+            message.lastName = String(object.lastName);
+        if (object.about != null)
+            message.about = String(object.about);
+        if (object.coverPhoto != null)
+            message.coverPhoto = object.coverPhoto >>> 0;
+        if (object.avatarPhoto != null)
+            message.avatarPhoto = object.avatarPhoto >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a PersonMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof PersonMetadata
+     * @static
+     * @param {PersonMetadata} message PersonMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    PersonMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.firstName = "";
+            object.middleName = "";
+            object.lastName = "";
+            object.about = "";
+            object.coverPhoto = 0;
+            object.avatarPhoto = 0;
+        }
+        if (message.firstName != null && message.hasOwnProperty("firstName"))
+            object.firstName = message.firstName;
+        if (message.middleName != null && message.hasOwnProperty("middleName"))
+            object.middleName = message.middleName;
+        if (message.lastName != null && message.hasOwnProperty("lastName"))
+            object.lastName = message.lastName;
+        if (message.about != null && message.hasOwnProperty("about"))
+            object.about = message.about;
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            object.coverPhoto = message.coverPhoto;
+        if (message.avatarPhoto != null && message.hasOwnProperty("avatarPhoto"))
+            object.avatarPhoto = message.avatarPhoto;
+        return object;
+    };
+
+    /**
+     * Converts this PersonMetadata to JSON.
+     * @function toJSON
+     * @memberof PersonMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    PersonMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return PersonMetadata;
+})();
+
+$root.ProposalsDiscussionPostMetadata = (function() {
+
+    /**
+     * Properties of a ProposalsDiscussionPostMetadata.
+     * @exports IProposalsDiscussionPostMetadata
+     * @interface IProposalsDiscussionPostMetadata
+     * @property {string|null} [text] ProposalsDiscussionPostMetadata text
+     * @property {number|null} [repliesTo] ProposalsDiscussionPostMetadata repliesTo
+     */
+
+    /**
+     * Constructs a new ProposalsDiscussionPostMetadata.
+     * @exports ProposalsDiscussionPostMetadata
+     * @classdesc Represents a ProposalsDiscussionPostMetadata.
+     * @implements IProposalsDiscussionPostMetadata
+     * @constructor
+     * @param {IProposalsDiscussionPostMetadata=} [properties] Properties to set
+     */
+    function ProposalsDiscussionPostMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ProposalsDiscussionPostMetadata text.
+     * @member {string} text
+     * @memberof ProposalsDiscussionPostMetadata
+     * @instance
+     */
+    ProposalsDiscussionPostMetadata.prototype.text = "";
+
+    /**
+     * ProposalsDiscussionPostMetadata repliesTo.
+     * @member {number} repliesTo
+     * @memberof ProposalsDiscussionPostMetadata
+     * @instance
+     */
+    ProposalsDiscussionPostMetadata.prototype.repliesTo = 0;
+
+    /**
+     * Creates a new ProposalsDiscussionPostMetadata instance using the specified properties.
+     * @function create
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {IProposalsDiscussionPostMetadata=} [properties] Properties to set
+     * @returns {ProposalsDiscussionPostMetadata} ProposalsDiscussionPostMetadata instance
+     */
+    ProposalsDiscussionPostMetadata.create = function create(properties) {
+        return new ProposalsDiscussionPostMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified ProposalsDiscussionPostMetadata message. Does not implicitly {@link ProposalsDiscussionPostMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {IProposalsDiscussionPostMetadata} message ProposalsDiscussionPostMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ProposalsDiscussionPostMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.text != null && Object.hasOwnProperty.call(message, "text"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
+        if (message.repliesTo != null && Object.hasOwnProperty.call(message, "repliesTo"))
+            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.repliesTo);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ProposalsDiscussionPostMetadata message, length delimited. Does not implicitly {@link ProposalsDiscussionPostMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {IProposalsDiscussionPostMetadata} message ProposalsDiscussionPostMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ProposalsDiscussionPostMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ProposalsDiscussionPostMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ProposalsDiscussionPostMetadata} ProposalsDiscussionPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ProposalsDiscussionPostMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ProposalsDiscussionPostMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.text = reader.string();
+                break;
+            case 2:
+                message.repliesTo = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a ProposalsDiscussionPostMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ProposalsDiscussionPostMetadata} ProposalsDiscussionPostMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ProposalsDiscussionPostMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ProposalsDiscussionPostMetadata message.
+     * @function verify
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ProposalsDiscussionPostMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.text != null && message.hasOwnProperty("text"))
+            if (!$util.isString(message.text))
+                return "text: string expected";
+        if (message.repliesTo != null && message.hasOwnProperty("repliesTo"))
+            if (!$util.isInteger(message.repliesTo))
+                return "repliesTo: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a ProposalsDiscussionPostMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ProposalsDiscussionPostMetadata} ProposalsDiscussionPostMetadata
+     */
+    ProposalsDiscussionPostMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.ProposalsDiscussionPostMetadata)
+            return object;
+        var message = new $root.ProposalsDiscussionPostMetadata();
+        if (object.text != null)
+            message.text = String(object.text);
+        if (object.repliesTo != null)
+            message.repliesTo = object.repliesTo >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ProposalsDiscussionPostMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ProposalsDiscussionPostMetadata
+     * @static
+     * @param {ProposalsDiscussionPostMetadata} message ProposalsDiscussionPostMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ProposalsDiscussionPostMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.text = "";
+            object.repliesTo = 0;
+        }
+        if (message.text != null && message.hasOwnProperty("text"))
+            object.text = message.text;
+        if (message.repliesTo != null && message.hasOwnProperty("repliesTo"))
+            object.repliesTo = message.repliesTo;
+        return object;
+    };
+
+    /**
+     * Converts this ProposalsDiscussionPostMetadata to JSON.
+     * @function toJSON
+     * @memberof ProposalsDiscussionPostMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ProposalsDiscussionPostMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ProposalsDiscussionPostMetadata;
+})();
+
+$root.SeriesMetadata = (function() {
+
+    /**
+     * Properties of a SeriesMetadata.
+     * @exports ISeriesMetadata
+     * @interface ISeriesMetadata
+     * @property {string|null} [title] SeriesMetadata title
+     * @property {string|null} [description] SeriesMetadata description
+     * @property {number|null} [coverPhoto] SeriesMetadata coverPhoto
+     * @property {Array.<Long>|null} [persons] SeriesMetadata persons
+     */
+
+    /**
+     * Constructs a new SeriesMetadata.
+     * @exports SeriesMetadata
+     * @classdesc Represents a SeriesMetadata.
+     * @implements ISeriesMetadata
+     * @constructor
+     * @param {ISeriesMetadata=} [properties] Properties to set
+     */
+    function SeriesMetadata(properties) {
+        this.persons = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * SeriesMetadata title.
+     * @member {string} title
+     * @memberof SeriesMetadata
+     * @instance
+     */
+    SeriesMetadata.prototype.title = "";
+
+    /**
+     * SeriesMetadata description.
+     * @member {string} description
+     * @memberof SeriesMetadata
+     * @instance
+     */
+    SeriesMetadata.prototype.description = "";
+
+    /**
+     * SeriesMetadata coverPhoto.
+     * @member {number} coverPhoto
+     * @memberof SeriesMetadata
+     * @instance
+     */
+    SeriesMetadata.prototype.coverPhoto = 0;
+
+    /**
+     * SeriesMetadata persons.
+     * @member {Array.<Long>} persons
+     * @memberof SeriesMetadata
+     * @instance
+     */
+    SeriesMetadata.prototype.persons = $util.emptyArray;
+
+    /**
+     * Creates a new SeriesMetadata instance using the specified properties.
+     * @function create
+     * @memberof SeriesMetadata
+     * @static
+     * @param {ISeriesMetadata=} [properties] Properties to set
+     * @returns {SeriesMetadata} SeriesMetadata instance
+     */
+    SeriesMetadata.create = function create(properties) {
+        return new SeriesMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified SeriesMetadata message. Does not implicitly {@link SeriesMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof SeriesMetadata
+     * @static
+     * @param {ISeriesMetadata} message SeriesMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SeriesMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.coverPhoto != null && Object.hasOwnProperty.call(message, "coverPhoto"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.coverPhoto);
+        if (message.persons != null && message.persons.length) {
+            writer.uint32(/* id 4, wireType 2 =*/34).fork();
+            for (var i = 0; i < message.persons.length; ++i)
+                writer.uint64(message.persons[i]);
+            writer.ldelim();
+        }
+        return writer;
+    };
+
+    /**
+     * Encodes the specified SeriesMetadata message, length delimited. Does not implicitly {@link SeriesMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof SeriesMetadata
+     * @static
+     * @param {ISeriesMetadata} message SeriesMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SeriesMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a SeriesMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof SeriesMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {SeriesMetadata} SeriesMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SeriesMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SeriesMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.coverPhoto = reader.uint32();
+                break;
+            case 4:
+                if (!(message.persons && message.persons.length))
+                    message.persons = [];
+                if ((tag & 7) === 2) {
+                    var end2 = reader.uint32() + reader.pos;
+                    while (reader.pos < end2)
+                        message.persons.push(reader.uint64());
+                } else
+                    message.persons.push(reader.uint64());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a SeriesMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof SeriesMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {SeriesMetadata} SeriesMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SeriesMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a SeriesMetadata message.
+     * @function verify
+     * @memberof SeriesMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    SeriesMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            if (!$util.isInteger(message.coverPhoto))
+                return "coverPhoto: integer expected";
+        if (message.persons != null && message.hasOwnProperty("persons")) {
+            if (!Array.isArray(message.persons))
+                return "persons: array expected";
+            for (var i = 0; i < message.persons.length; ++i)
+                if (!$util.isInteger(message.persons[i]) && !(message.persons[i] && $util.isInteger(message.persons[i].low) && $util.isInteger(message.persons[i].high)))
+                    return "persons: integer|Long[] expected";
+        }
+        return null;
+    };
+
+    /**
+     * Creates a SeriesMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof SeriesMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {SeriesMetadata} SeriesMetadata
+     */
+    SeriesMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.SeriesMetadata)
+            return object;
+        var message = new $root.SeriesMetadata();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.coverPhoto != null)
+            message.coverPhoto = object.coverPhoto >>> 0;
+        if (object.persons) {
+            if (!Array.isArray(object.persons))
+                throw TypeError(".SeriesMetadata.persons: array expected");
+            message.persons = [];
+            for (var i = 0; i < object.persons.length; ++i)
+                if ($util.Long)
+                    (message.persons[i] = $util.Long.fromValue(object.persons[i])).unsigned = true;
+                else if (typeof object.persons[i] === "string")
+                    message.persons[i] = parseInt(object.persons[i], 10);
+                else if (typeof object.persons[i] === "number")
+                    message.persons[i] = object.persons[i];
+                else if (typeof object.persons[i] === "object")
+                    message.persons[i] = new $util.LongBits(object.persons[i].low >>> 0, object.persons[i].high >>> 0).toNumber(true);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a SeriesMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof SeriesMetadata
+     * @static
+     * @param {SeriesMetadata} message SeriesMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    SeriesMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.persons = [];
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            object.coverPhoto = 0;
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            object.coverPhoto = message.coverPhoto;
+        if (message.persons && message.persons.length) {
+            object.persons = [];
+            for (var j = 0; j < message.persons.length; ++j)
+                if (typeof message.persons[j] === "number")
+                    object.persons[j] = options.longs === String ? String(message.persons[j]) : message.persons[j];
+                else
+                    object.persons[j] = options.longs === String ? $util.Long.prototype.toString.call(message.persons[j]) : options.longs === Number ? new $util.LongBits(message.persons[j].low >>> 0, message.persons[j].high >>> 0).toNumber(true) : message.persons[j];
+        }
+        return object;
+    };
+
+    /**
+     * Converts this SeriesMetadata to JSON.
+     * @function toJSON
+     * @memberof SeriesMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    SeriesMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return SeriesMetadata;
+})();
+
+$root.SeasonMetadata = (function() {
+
+    /**
+     * Properties of a SeasonMetadata.
+     * @exports ISeasonMetadata
+     * @interface ISeasonMetadata
+     * @property {string|null} [title] SeasonMetadata title
+     * @property {string|null} [description] SeasonMetadata description
+     * @property {number|null} [coverPhoto] SeasonMetadata coverPhoto
+     * @property {Array.<Long>|null} [persons] SeasonMetadata persons
+     */
+
+    /**
+     * Constructs a new SeasonMetadata.
+     * @exports SeasonMetadata
+     * @classdesc Represents a SeasonMetadata.
+     * @implements ISeasonMetadata
+     * @constructor
+     * @param {ISeasonMetadata=} [properties] Properties to set
+     */
+    function SeasonMetadata(properties) {
+        this.persons = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * SeasonMetadata title.
+     * @member {string} title
+     * @memberof SeasonMetadata
+     * @instance
+     */
+    SeasonMetadata.prototype.title = "";
+
+    /**
+     * SeasonMetadata description.
+     * @member {string} description
+     * @memberof SeasonMetadata
+     * @instance
+     */
+    SeasonMetadata.prototype.description = "";
+
+    /**
+     * SeasonMetadata coverPhoto.
+     * @member {number} coverPhoto
+     * @memberof SeasonMetadata
+     * @instance
+     */
+    SeasonMetadata.prototype.coverPhoto = 0;
+
+    /**
+     * SeasonMetadata persons.
+     * @member {Array.<Long>} persons
+     * @memberof SeasonMetadata
+     * @instance
+     */
+    SeasonMetadata.prototype.persons = $util.emptyArray;
+
+    /**
+     * Creates a new SeasonMetadata instance using the specified properties.
+     * @function create
+     * @memberof SeasonMetadata
+     * @static
+     * @param {ISeasonMetadata=} [properties] Properties to set
+     * @returns {SeasonMetadata} SeasonMetadata instance
+     */
+    SeasonMetadata.create = function create(properties) {
+        return new SeasonMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified SeasonMetadata message. Does not implicitly {@link SeasonMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof SeasonMetadata
+     * @static
+     * @param {ISeasonMetadata} message SeasonMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SeasonMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.coverPhoto != null && Object.hasOwnProperty.call(message, "coverPhoto"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.coverPhoto);
+        if (message.persons != null && message.persons.length) {
+            writer.uint32(/* id 4, wireType 2 =*/34).fork();
+            for (var i = 0; i < message.persons.length; ++i)
+                writer.uint64(message.persons[i]);
+            writer.ldelim();
+        }
+        return writer;
+    };
+
+    /**
+     * Encodes the specified SeasonMetadata message, length delimited. Does not implicitly {@link SeasonMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof SeasonMetadata
+     * @static
+     * @param {ISeasonMetadata} message SeasonMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SeasonMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a SeasonMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof SeasonMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {SeasonMetadata} SeasonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SeasonMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SeasonMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.coverPhoto = reader.uint32();
+                break;
+            case 4:
+                if (!(message.persons && message.persons.length))
+                    message.persons = [];
+                if ((tag & 7) === 2) {
+                    var end2 = reader.uint32() + reader.pos;
+                    while (reader.pos < end2)
+                        message.persons.push(reader.uint64());
+                } else
+                    message.persons.push(reader.uint64());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a SeasonMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof SeasonMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {SeasonMetadata} SeasonMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SeasonMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a SeasonMetadata message.
+     * @function verify
+     * @memberof SeasonMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    SeasonMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            if (!$util.isInteger(message.coverPhoto))
+                return "coverPhoto: integer expected";
+        if (message.persons != null && message.hasOwnProperty("persons")) {
+            if (!Array.isArray(message.persons))
+                return "persons: array expected";
+            for (var i = 0; i < message.persons.length; ++i)
+                if (!$util.isInteger(message.persons[i]) && !(message.persons[i] && $util.isInteger(message.persons[i].low) && $util.isInteger(message.persons[i].high)))
+                    return "persons: integer|Long[] expected";
+        }
+        return null;
+    };
+
+    /**
+     * Creates a SeasonMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof SeasonMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {SeasonMetadata} SeasonMetadata
+     */
+    SeasonMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.SeasonMetadata)
+            return object;
+        var message = new $root.SeasonMetadata();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.coverPhoto != null)
+            message.coverPhoto = object.coverPhoto >>> 0;
+        if (object.persons) {
+            if (!Array.isArray(object.persons))
+                throw TypeError(".SeasonMetadata.persons: array expected");
+            message.persons = [];
+            for (var i = 0; i < object.persons.length; ++i)
+                if ($util.Long)
+                    (message.persons[i] = $util.Long.fromValue(object.persons[i])).unsigned = true;
+                else if (typeof object.persons[i] === "string")
+                    message.persons[i] = parseInt(object.persons[i], 10);
+                else if (typeof object.persons[i] === "number")
+                    message.persons[i] = object.persons[i];
+                else if (typeof object.persons[i] === "object")
+                    message.persons[i] = new $util.LongBits(object.persons[i].low >>> 0, object.persons[i].high >>> 0).toNumber(true);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a SeasonMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof SeasonMetadata
+     * @static
+     * @param {SeasonMetadata} message SeasonMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    SeasonMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.persons = [];
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            object.coverPhoto = 0;
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.coverPhoto != null && message.hasOwnProperty("coverPhoto"))
+            object.coverPhoto = message.coverPhoto;
+        if (message.persons && message.persons.length) {
+            object.persons = [];
+            for (var j = 0; j < message.persons.length; ++j)
+                if (typeof message.persons[j] === "number")
+                    object.persons[j] = options.longs === String ? String(message.persons[j]) : message.persons[j];
+                else
+                    object.persons[j] = options.longs === String ? $util.Long.prototype.toString.call(message.persons[j]) : options.longs === Number ? new $util.LongBits(message.persons[j].low >>> 0, message.persons[j].high >>> 0).toNumber(true) : message.persons[j];
+        }
+        return object;
+    };
+
+    /**
+     * Converts this SeasonMetadata to JSON.
+     * @function toJSON
+     * @memberof SeasonMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    SeasonMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return SeasonMetadata;
+})();
+
+$root.GeoCoordiantes = (function() {
+
+    /**
+     * Properties of a GeoCoordiantes.
+     * @exports IGeoCoordiantes
+     * @interface IGeoCoordiantes
+     * @property {number|null} [latitude] GeoCoordiantes latitude
+     * @property {number|null} [longitude] GeoCoordiantes longitude
+     */
+
+    /**
+     * Constructs a new GeoCoordiantes.
+     * @exports GeoCoordiantes
+     * @classdesc Represents a GeoCoordiantes.
+     * @implements IGeoCoordiantes
+     * @constructor
+     * @param {IGeoCoordiantes=} [properties] Properties to set
+     */
+    function GeoCoordiantes(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * GeoCoordiantes latitude.
+     * @member {number} latitude
+     * @memberof GeoCoordiantes
+     * @instance
+     */
+    GeoCoordiantes.prototype.latitude = 0;
+
+    /**
+     * GeoCoordiantes longitude.
+     * @member {number} longitude
+     * @memberof GeoCoordiantes
+     * @instance
+     */
+    GeoCoordiantes.prototype.longitude = 0;
+
+    /**
+     * Creates a new GeoCoordiantes instance using the specified properties.
+     * @function create
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {IGeoCoordiantes=} [properties] Properties to set
+     * @returns {GeoCoordiantes} GeoCoordiantes instance
+     */
+    GeoCoordiantes.create = function create(properties) {
+        return new GeoCoordiantes(properties);
+    };
+
+    /**
+     * Encodes the specified GeoCoordiantes message. Does not implicitly {@link GeoCoordiantes.verify|verify} messages.
+     * @function encode
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {IGeoCoordiantes} message GeoCoordiantes message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    GeoCoordiantes.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude"))
+            writer.uint32(/* id 3, wireType 5 =*/29).float(message.latitude);
+        if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude"))
+            writer.uint32(/* id 4, wireType 5 =*/37).float(message.longitude);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified GeoCoordiantes message, length delimited. Does not implicitly {@link GeoCoordiantes.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {IGeoCoordiantes} message GeoCoordiantes message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    GeoCoordiantes.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a GeoCoordiantes message from the specified reader or buffer.
+     * @function decode
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {GeoCoordiantes} GeoCoordiantes
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    GeoCoordiantes.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GeoCoordiantes();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 3:
+                message.latitude = reader.float();
+                break;
+            case 4:
+                message.longitude = reader.float();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a GeoCoordiantes message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {GeoCoordiantes} GeoCoordiantes
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    GeoCoordiantes.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a GeoCoordiantes message.
+     * @function verify
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    GeoCoordiantes.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.latitude != null && message.hasOwnProperty("latitude"))
+            if (typeof message.latitude !== "number")
+                return "latitude: number expected";
+        if (message.longitude != null && message.hasOwnProperty("longitude"))
+            if (typeof message.longitude !== "number")
+                return "longitude: number expected";
+        return null;
+    };
+
+    /**
+     * Creates a GeoCoordiantes message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {GeoCoordiantes} GeoCoordiantes
+     */
+    GeoCoordiantes.fromObject = function fromObject(object) {
+        if (object instanceof $root.GeoCoordiantes)
+            return object;
+        var message = new $root.GeoCoordiantes();
+        if (object.latitude != null)
+            message.latitude = Number(object.latitude);
+        if (object.longitude != null)
+            message.longitude = Number(object.longitude);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a GeoCoordiantes message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof GeoCoordiantes
+     * @static
+     * @param {GeoCoordiantes} message GeoCoordiantes
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    GeoCoordiantes.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.latitude = 0;
+            object.longitude = 0;
+        }
+        if (message.latitude != null && message.hasOwnProperty("latitude"))
+            object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
+        if (message.longitude != null && message.hasOwnProperty("longitude"))
+            object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
+        return object;
+    };
+
+    /**
+     * Converts this GeoCoordiantes to JSON.
+     * @function toJSON
+     * @memberof GeoCoordiantes
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    GeoCoordiantes.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return GeoCoordiantes;
+})();
+
+$root.NodeLocationMetadata = (function() {
+
+    /**
+     * Properties of a NodeLocationMetadata.
+     * @exports INodeLocationMetadata
+     * @interface INodeLocationMetadata
+     * @property {string|null} [countryCode] NodeLocationMetadata countryCode
+     * @property {string|null} [city] NodeLocationMetadata city
+     * @property {IGeoCoordiantes|null} [coordinates] NodeLocationMetadata coordinates
+     */
+
+    /**
+     * Constructs a new NodeLocationMetadata.
+     * @exports NodeLocationMetadata
+     * @classdesc Represents a NodeLocationMetadata.
+     * @implements INodeLocationMetadata
+     * @constructor
+     * @param {INodeLocationMetadata=} [properties] Properties to set
+     */
+    function NodeLocationMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * NodeLocationMetadata countryCode.
+     * @member {string} countryCode
+     * @memberof NodeLocationMetadata
+     * @instance
+     */
+    NodeLocationMetadata.prototype.countryCode = "";
+
+    /**
+     * NodeLocationMetadata city.
+     * @member {string} city
+     * @memberof NodeLocationMetadata
+     * @instance
+     */
+    NodeLocationMetadata.prototype.city = "";
+
+    /**
+     * NodeLocationMetadata coordinates.
+     * @member {IGeoCoordiantes|null|undefined} coordinates
+     * @memberof NodeLocationMetadata
+     * @instance
+     */
+    NodeLocationMetadata.prototype.coordinates = null;
+
+    /**
+     * Creates a new NodeLocationMetadata instance using the specified properties.
+     * @function create
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {INodeLocationMetadata=} [properties] Properties to set
+     * @returns {NodeLocationMetadata} NodeLocationMetadata instance
+     */
+    NodeLocationMetadata.create = function create(properties) {
+        return new NodeLocationMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified NodeLocationMetadata message. Does not implicitly {@link NodeLocationMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {INodeLocationMetadata} message NodeLocationMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    NodeLocationMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.countryCode != null && Object.hasOwnProperty.call(message, "countryCode"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.countryCode);
+        if (message.city != null && Object.hasOwnProperty.call(message, "city"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.city);
+        if (message.coordinates != null && Object.hasOwnProperty.call(message, "coordinates"))
+            $root.GeoCoordiantes.encode(message.coordinates, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified NodeLocationMetadata message, length delimited. Does not implicitly {@link NodeLocationMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {INodeLocationMetadata} message NodeLocationMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    NodeLocationMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a NodeLocationMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {NodeLocationMetadata} NodeLocationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    NodeLocationMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.NodeLocationMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.countryCode = reader.string();
+                break;
+            case 2:
+                message.city = reader.string();
+                break;
+            case 3:
+                message.coordinates = $root.GeoCoordiantes.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a NodeLocationMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {NodeLocationMetadata} NodeLocationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    NodeLocationMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a NodeLocationMetadata message.
+     * @function verify
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    NodeLocationMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
+            if (!$util.isString(message.countryCode))
+                return "countryCode: string expected";
+        if (message.city != null && message.hasOwnProperty("city"))
+            if (!$util.isString(message.city))
+                return "city: string expected";
+        if (message.coordinates != null && message.hasOwnProperty("coordinates")) {
+            var error = $root.GeoCoordiantes.verify(message.coordinates);
+            if (error)
+                return "coordinates." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a NodeLocationMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {NodeLocationMetadata} NodeLocationMetadata
+     */
+    NodeLocationMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.NodeLocationMetadata)
+            return object;
+        var message = new $root.NodeLocationMetadata();
+        if (object.countryCode != null)
+            message.countryCode = String(object.countryCode);
+        if (object.city != null)
+            message.city = String(object.city);
+        if (object.coordinates != null) {
+            if (typeof object.coordinates !== "object")
+                throw TypeError(".NodeLocationMetadata.coordinates: object expected");
+            message.coordinates = $root.GeoCoordiantes.fromObject(object.coordinates);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a NodeLocationMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof NodeLocationMetadata
+     * @static
+     * @param {NodeLocationMetadata} message NodeLocationMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    NodeLocationMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.countryCode = "";
+            object.city = "";
+            object.coordinates = null;
+        }
+        if (message.countryCode != null && message.hasOwnProperty("countryCode"))
+            object.countryCode = message.countryCode;
+        if (message.city != null && message.hasOwnProperty("city"))
+            object.city = message.city;
+        if (message.coordinates != null && message.hasOwnProperty("coordinates"))
+            object.coordinates = $root.GeoCoordiantes.toObject(message.coordinates, options);
+        return object;
+    };
+
+    /**
+     * Converts this NodeLocationMetadata to JSON.
+     * @function toJSON
+     * @memberof NodeLocationMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    NodeLocationMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return NodeLocationMetadata;
+})();
+
+$root.StorageBucketOperatorMetadata = (function() {
+
+    /**
+     * Properties of a StorageBucketOperatorMetadata.
+     * @exports IStorageBucketOperatorMetadata
+     * @interface IStorageBucketOperatorMetadata
+     * @property {string|null} [endpoint] StorageBucketOperatorMetadata endpoint
+     * @property {INodeLocationMetadata|null} [location] StorageBucketOperatorMetadata location
+     * @property {string|null} [extra] StorageBucketOperatorMetadata extra
+     */
+
+    /**
+     * Constructs a new StorageBucketOperatorMetadata.
+     * @exports StorageBucketOperatorMetadata
+     * @classdesc Represents a StorageBucketOperatorMetadata.
+     * @implements IStorageBucketOperatorMetadata
+     * @constructor
+     * @param {IStorageBucketOperatorMetadata=} [properties] Properties to set
+     */
+    function StorageBucketOperatorMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * StorageBucketOperatorMetadata endpoint.
+     * @member {string} endpoint
+     * @memberof StorageBucketOperatorMetadata
+     * @instance
+     */
+    StorageBucketOperatorMetadata.prototype.endpoint = "";
+
+    /**
+     * StorageBucketOperatorMetadata location.
+     * @member {INodeLocationMetadata|null|undefined} location
+     * @memberof StorageBucketOperatorMetadata
+     * @instance
+     */
+    StorageBucketOperatorMetadata.prototype.location = null;
+
+    /**
+     * StorageBucketOperatorMetadata extra.
+     * @member {string} extra
+     * @memberof StorageBucketOperatorMetadata
+     * @instance
+     */
+    StorageBucketOperatorMetadata.prototype.extra = "";
+
+    /**
+     * Creates a new StorageBucketOperatorMetadata instance using the specified properties.
+     * @function create
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {IStorageBucketOperatorMetadata=} [properties] Properties to set
+     * @returns {StorageBucketOperatorMetadata} StorageBucketOperatorMetadata instance
+     */
+    StorageBucketOperatorMetadata.create = function create(properties) {
+        return new StorageBucketOperatorMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified StorageBucketOperatorMetadata message. Does not implicitly {@link StorageBucketOperatorMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {IStorageBucketOperatorMetadata} message StorageBucketOperatorMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    StorageBucketOperatorMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.endpoint != null && Object.hasOwnProperty.call(message, "endpoint"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.endpoint);
+        if (message.location != null && Object.hasOwnProperty.call(message, "location"))
+            $root.NodeLocationMetadata.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.extra);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified StorageBucketOperatorMetadata message, length delimited. Does not implicitly {@link StorageBucketOperatorMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {IStorageBucketOperatorMetadata} message StorageBucketOperatorMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    StorageBucketOperatorMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a StorageBucketOperatorMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {StorageBucketOperatorMetadata} StorageBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    StorageBucketOperatorMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StorageBucketOperatorMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.endpoint = reader.string();
+                break;
+            case 2:
+                message.location = $root.NodeLocationMetadata.decode(reader, reader.uint32());
+                break;
+            case 3:
+                message.extra = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a StorageBucketOperatorMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {StorageBucketOperatorMetadata} StorageBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    StorageBucketOperatorMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a StorageBucketOperatorMetadata message.
+     * @function verify
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    StorageBucketOperatorMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.endpoint != null && message.hasOwnProperty("endpoint"))
+            if (!$util.isString(message.endpoint))
+                return "endpoint: string expected";
+        if (message.location != null && message.hasOwnProperty("location")) {
+            var error = $root.NodeLocationMetadata.verify(message.location);
+            if (error)
+                return "location." + error;
+        }
+        if (message.extra != null && message.hasOwnProperty("extra"))
+            if (!$util.isString(message.extra))
+                return "extra: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a StorageBucketOperatorMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {StorageBucketOperatorMetadata} StorageBucketOperatorMetadata
+     */
+    StorageBucketOperatorMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.StorageBucketOperatorMetadata)
+            return object;
+        var message = new $root.StorageBucketOperatorMetadata();
+        if (object.endpoint != null)
+            message.endpoint = String(object.endpoint);
+        if (object.location != null) {
+            if (typeof object.location !== "object")
+                throw TypeError(".StorageBucketOperatorMetadata.location: object expected");
+            message.location = $root.NodeLocationMetadata.fromObject(object.location);
+        }
+        if (object.extra != null)
+            message.extra = String(object.extra);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a StorageBucketOperatorMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof StorageBucketOperatorMetadata
+     * @static
+     * @param {StorageBucketOperatorMetadata} message StorageBucketOperatorMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    StorageBucketOperatorMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.endpoint = "";
+            object.location = null;
+            object.extra = "";
+        }
+        if (message.endpoint != null && message.hasOwnProperty("endpoint"))
+            object.endpoint = message.endpoint;
+        if (message.location != null && message.hasOwnProperty("location"))
+            object.location = $root.NodeLocationMetadata.toObject(message.location, options);
+        if (message.extra != null && message.hasOwnProperty("extra"))
+            object.extra = message.extra;
+        return object;
+    };
+
+    /**
+     * Converts this StorageBucketOperatorMetadata to JSON.
+     * @function toJSON
+     * @memberof StorageBucketOperatorMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    StorageBucketOperatorMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return StorageBucketOperatorMetadata;
+})();
+
+$root.DistributionBucketOperatorMetadata = (function() {
+
+    /**
+     * Properties of a DistributionBucketOperatorMetadata.
+     * @exports IDistributionBucketOperatorMetadata
+     * @interface IDistributionBucketOperatorMetadata
+     * @property {string|null} [endpoint] DistributionBucketOperatorMetadata endpoint
+     * @property {INodeLocationMetadata|null} [location] DistributionBucketOperatorMetadata location
+     * @property {string|null} [extra] DistributionBucketOperatorMetadata extra
+     */
+
+    /**
+     * Constructs a new DistributionBucketOperatorMetadata.
+     * @exports DistributionBucketOperatorMetadata
+     * @classdesc Represents a DistributionBucketOperatorMetadata.
+     * @implements IDistributionBucketOperatorMetadata
+     * @constructor
+     * @param {IDistributionBucketOperatorMetadata=} [properties] Properties to set
+     */
+    function DistributionBucketOperatorMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * DistributionBucketOperatorMetadata endpoint.
+     * @member {string} endpoint
+     * @memberof DistributionBucketOperatorMetadata
+     * @instance
+     */
+    DistributionBucketOperatorMetadata.prototype.endpoint = "";
+
+    /**
+     * DistributionBucketOperatorMetadata location.
+     * @member {INodeLocationMetadata|null|undefined} location
+     * @memberof DistributionBucketOperatorMetadata
+     * @instance
+     */
+    DistributionBucketOperatorMetadata.prototype.location = null;
+
+    /**
+     * DistributionBucketOperatorMetadata extra.
+     * @member {string} extra
+     * @memberof DistributionBucketOperatorMetadata
+     * @instance
+     */
+    DistributionBucketOperatorMetadata.prototype.extra = "";
+
+    /**
+     * Creates a new DistributionBucketOperatorMetadata instance using the specified properties.
+     * @function create
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {IDistributionBucketOperatorMetadata=} [properties] Properties to set
+     * @returns {DistributionBucketOperatorMetadata} DistributionBucketOperatorMetadata instance
+     */
+    DistributionBucketOperatorMetadata.create = function create(properties) {
+        return new DistributionBucketOperatorMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified DistributionBucketOperatorMetadata message. Does not implicitly {@link DistributionBucketOperatorMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {IDistributionBucketOperatorMetadata} message DistributionBucketOperatorMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    DistributionBucketOperatorMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.endpoint != null && Object.hasOwnProperty.call(message, "endpoint"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.endpoint);
+        if (message.location != null && Object.hasOwnProperty.call(message, "location"))
+            $root.NodeLocationMetadata.encode(message.location, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.extra);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified DistributionBucketOperatorMetadata message, length delimited. Does not implicitly {@link DistributionBucketOperatorMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {IDistributionBucketOperatorMetadata} message DistributionBucketOperatorMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    DistributionBucketOperatorMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a DistributionBucketOperatorMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {DistributionBucketOperatorMetadata} DistributionBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    DistributionBucketOperatorMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DistributionBucketOperatorMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.endpoint = reader.string();
+                break;
+            case 2:
+                message.location = $root.NodeLocationMetadata.decode(reader, reader.uint32());
+                break;
+            case 3:
+                message.extra = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a DistributionBucketOperatorMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {DistributionBucketOperatorMetadata} DistributionBucketOperatorMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    DistributionBucketOperatorMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a DistributionBucketOperatorMetadata message.
+     * @function verify
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    DistributionBucketOperatorMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.endpoint != null && message.hasOwnProperty("endpoint"))
+            if (!$util.isString(message.endpoint))
+                return "endpoint: string expected";
+        if (message.location != null && message.hasOwnProperty("location")) {
+            var error = $root.NodeLocationMetadata.verify(message.location);
+            if (error)
+                return "location." + error;
+        }
+        if (message.extra != null && message.hasOwnProperty("extra"))
+            if (!$util.isString(message.extra))
+                return "extra: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a DistributionBucketOperatorMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {DistributionBucketOperatorMetadata} DistributionBucketOperatorMetadata
+     */
+    DistributionBucketOperatorMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.DistributionBucketOperatorMetadata)
+            return object;
+        var message = new $root.DistributionBucketOperatorMetadata();
+        if (object.endpoint != null)
+            message.endpoint = String(object.endpoint);
+        if (object.location != null) {
+            if (typeof object.location !== "object")
+                throw TypeError(".DistributionBucketOperatorMetadata.location: object expected");
+            message.location = $root.NodeLocationMetadata.fromObject(object.location);
+        }
+        if (object.extra != null)
+            message.extra = String(object.extra);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a DistributionBucketOperatorMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof DistributionBucketOperatorMetadata
+     * @static
+     * @param {DistributionBucketOperatorMetadata} message DistributionBucketOperatorMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    DistributionBucketOperatorMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.endpoint = "";
+            object.location = null;
+            object.extra = "";
+        }
+        if (message.endpoint != null && message.hasOwnProperty("endpoint"))
+            object.endpoint = message.endpoint;
+        if (message.location != null && message.hasOwnProperty("location"))
+            object.location = $root.NodeLocationMetadata.toObject(message.location, options);
+        if (message.extra != null && message.hasOwnProperty("extra"))
+            object.extra = message.extra;
+        return object;
+    };
+
+    /**
+     * Converts this DistributionBucketOperatorMetadata to JSON.
+     * @function toJSON
+     * @memberof DistributionBucketOperatorMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    DistributionBucketOperatorMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return DistributionBucketOperatorMetadata;
+})();
+
+$root.GeographicalArea = (function() {
+
+    /**
+     * Properties of a GeographicalArea.
+     * @exports IGeographicalArea
+     * @interface IGeographicalArea
+     * @property {GeographicalArea.Continent|null} [continent] GeographicalArea continent
+     * @property {string|null} [countryCode] GeographicalArea countryCode
+     * @property {string|null} [subdivisionCode] GeographicalArea subdivisionCode
+     */
+
+    /**
+     * Constructs a new GeographicalArea.
+     * @exports GeographicalArea
+     * @classdesc Represents a GeographicalArea.
+     * @implements IGeographicalArea
+     * @constructor
+     * @param {IGeographicalArea=} [properties] Properties to set
+     */
+    function GeographicalArea(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * GeographicalArea continent.
+     * @member {GeographicalArea.Continent|null|undefined} continent
+     * @memberof GeographicalArea
+     * @instance
+     */
+    GeographicalArea.prototype.continent = null;
+
+    /**
+     * GeographicalArea countryCode.
+     * @member {string|null|undefined} countryCode
+     * @memberof GeographicalArea
+     * @instance
+     */
+    GeographicalArea.prototype.countryCode = null;
+
+    /**
+     * GeographicalArea subdivisionCode.
+     * @member {string|null|undefined} subdivisionCode
+     * @memberof GeographicalArea
+     * @instance
+     */
+    GeographicalArea.prototype.subdivisionCode = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * GeographicalArea code.
+     * @member {"continent"|"countryCode"|"subdivisionCode"|undefined} code
+     * @memberof GeographicalArea
+     * @instance
+     */
+    Object.defineProperty(GeographicalArea.prototype, "code", {
+        get: $util.oneOfGetter($oneOfFields = ["continent", "countryCode", "subdivisionCode"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new GeographicalArea instance using the specified properties.
+     * @function create
+     * @memberof GeographicalArea
+     * @static
+     * @param {IGeographicalArea=} [properties] Properties to set
+     * @returns {GeographicalArea} GeographicalArea instance
+     */
+    GeographicalArea.create = function create(properties) {
+        return new GeographicalArea(properties);
+    };
+
+    /**
+     * Encodes the specified GeographicalArea message. Does not implicitly {@link GeographicalArea.verify|verify} messages.
+     * @function encode
+     * @memberof GeographicalArea
+     * @static
+     * @param {IGeographicalArea} message GeographicalArea message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    GeographicalArea.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.continent != null && Object.hasOwnProperty.call(message, "continent"))
+            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.continent);
+        if (message.countryCode != null && Object.hasOwnProperty.call(message, "countryCode"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.countryCode);
+        if (message.subdivisionCode != null && Object.hasOwnProperty.call(message, "subdivisionCode"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.subdivisionCode);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified GeographicalArea message, length delimited. Does not implicitly {@link GeographicalArea.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof GeographicalArea
+     * @static
+     * @param {IGeographicalArea} message GeographicalArea message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    GeographicalArea.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a GeographicalArea message from the specified reader or buffer.
+     * @function decode
+     * @memberof GeographicalArea
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {GeographicalArea} GeographicalArea
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    GeographicalArea.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.GeographicalArea();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.continent = reader.int32();
+                break;
+            case 2:
+                message.countryCode = reader.string();
+                break;
+            case 3:
+                message.subdivisionCode = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a GeographicalArea message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof GeographicalArea
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {GeographicalArea} GeographicalArea
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    GeographicalArea.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a GeographicalArea message.
+     * @function verify
+     * @memberof GeographicalArea
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    GeographicalArea.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.continent != null && message.hasOwnProperty("continent")) {
+            properties.code = 1;
+            switch (message.continent) {
+            default:
+                return "continent: enum value expected";
+            case 1:
+            case 2:
+            case 3:
+            case 4:
+            case 5:
+            case 6:
+            case 7:
+                break;
+            }
+        }
+        if (message.countryCode != null && message.hasOwnProperty("countryCode")) {
+            if (properties.code === 1)
+                return "code: multiple values";
+            properties.code = 1;
+            if (!$util.isString(message.countryCode))
+                return "countryCode: string expected";
+        }
+        if (message.subdivisionCode != null && message.hasOwnProperty("subdivisionCode")) {
+            if (properties.code === 1)
+                return "code: multiple values";
+            properties.code = 1;
+            if (!$util.isString(message.subdivisionCode))
+                return "subdivisionCode: string expected";
+        }
+        return null;
+    };
+
+    /**
+     * Creates a GeographicalArea message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof GeographicalArea
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {GeographicalArea} GeographicalArea
+     */
+    GeographicalArea.fromObject = function fromObject(object) {
+        if (object instanceof $root.GeographicalArea)
+            return object;
+        var message = new $root.GeographicalArea();
+        switch (object.continent) {
+        case "AF":
+        case 1:
+            message.continent = 1;
+            break;
+        case "NA":
+        case 2:
+            message.continent = 2;
+            break;
+        case "OC":
+        case 3:
+            message.continent = 3;
+            break;
+        case "AN":
+        case 4:
+            message.continent = 4;
+            break;
+        case "AS":
+        case 5:
+            message.continent = 5;
+            break;
+        case "EU":
+        case 6:
+            message.continent = 6;
+            break;
+        case "SA":
+        case 7:
+            message.continent = 7;
+            break;
+        }
+        if (object.countryCode != null)
+            message.countryCode = String(object.countryCode);
+        if (object.subdivisionCode != null)
+            message.subdivisionCode = String(object.subdivisionCode);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a GeographicalArea message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof GeographicalArea
+     * @static
+     * @param {GeographicalArea} message GeographicalArea
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    GeographicalArea.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.continent != null && message.hasOwnProperty("continent")) {
+            object.continent = options.enums === String ? $root.GeographicalArea.Continent[message.continent] : message.continent;
+            if (options.oneofs)
+                object.code = "continent";
+        }
+        if (message.countryCode != null && message.hasOwnProperty("countryCode")) {
+            object.countryCode = message.countryCode;
+            if (options.oneofs)
+                object.code = "countryCode";
+        }
+        if (message.subdivisionCode != null && message.hasOwnProperty("subdivisionCode")) {
+            object.subdivisionCode = message.subdivisionCode;
+            if (options.oneofs)
+                object.code = "subdivisionCode";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this GeographicalArea to JSON.
+     * @function toJSON
+     * @memberof GeographicalArea
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    GeographicalArea.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    /**
+     * Continent enum.
+     * @name GeographicalArea.Continent
+     * @enum {number}
+     * @property {number} AF=1 AF value
+     * @property {number} NA=2 NA value
+     * @property {number} OC=3 OC value
+     * @property {number} AN=4 AN value
+     * @property {number} AS=5 AS value
+     * @property {number} EU=6 EU value
+     * @property {number} SA=7 SA value
+     */
+    GeographicalArea.Continent = (function() {
+        var valuesById = {}, values = Object.create(valuesById);
+        values[valuesById[1] = "AF"] = 1;
+        values[valuesById[2] = "NA"] = 2;
+        values[valuesById[3] = "OC"] = 3;
+        values[valuesById[4] = "AN"] = 4;
+        values[valuesById[5] = "AS"] = 5;
+        values[valuesById[6] = "EU"] = 6;
+        values[valuesById[7] = "SA"] = 7;
+        return values;
+    })();
+
+    return GeographicalArea;
+})();
+
+$root.DistributionBucketFamilyMetadata = (function() {
+
+    /**
+     * Properties of a DistributionBucketFamilyMetadata.
+     * @exports IDistributionBucketFamilyMetadata
+     * @interface IDistributionBucketFamilyMetadata
+     * @property {string|null} [region] DistributionBucketFamilyMetadata region
+     * @property {string|null} [description] DistributionBucketFamilyMetadata description
+     * @property {Array.<IGeographicalArea>|null} [areas] DistributionBucketFamilyMetadata areas
+     * @property {Array.<string>|null} [latencyTestTargets] DistributionBucketFamilyMetadata latencyTestTargets
+     */
+
+    /**
+     * Constructs a new DistributionBucketFamilyMetadata.
+     * @exports DistributionBucketFamilyMetadata
+     * @classdesc Represents a DistributionBucketFamilyMetadata.
+     * @implements IDistributionBucketFamilyMetadata
+     * @constructor
+     * @param {IDistributionBucketFamilyMetadata=} [properties] Properties to set
+     */
+    function DistributionBucketFamilyMetadata(properties) {
+        this.areas = [];
+        this.latencyTestTargets = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * DistributionBucketFamilyMetadata region.
+     * @member {string} region
+     * @memberof DistributionBucketFamilyMetadata
+     * @instance
+     */
+    DistributionBucketFamilyMetadata.prototype.region = "";
+
+    /**
+     * DistributionBucketFamilyMetadata description.
+     * @member {string} description
+     * @memberof DistributionBucketFamilyMetadata
+     * @instance
+     */
+    DistributionBucketFamilyMetadata.prototype.description = "";
+
+    /**
+     * DistributionBucketFamilyMetadata areas.
+     * @member {Array.<IGeographicalArea>} areas
+     * @memberof DistributionBucketFamilyMetadata
+     * @instance
+     */
+    DistributionBucketFamilyMetadata.prototype.areas = $util.emptyArray;
+
+    /**
+     * DistributionBucketFamilyMetadata latencyTestTargets.
+     * @member {Array.<string>} latencyTestTargets
+     * @memberof DistributionBucketFamilyMetadata
+     * @instance
+     */
+    DistributionBucketFamilyMetadata.prototype.latencyTestTargets = $util.emptyArray;
+
+    /**
+     * Creates a new DistributionBucketFamilyMetadata instance using the specified properties.
+     * @function create
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {IDistributionBucketFamilyMetadata=} [properties] Properties to set
+     * @returns {DistributionBucketFamilyMetadata} DistributionBucketFamilyMetadata instance
+     */
+    DistributionBucketFamilyMetadata.create = function create(properties) {
+        return new DistributionBucketFamilyMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified DistributionBucketFamilyMetadata message. Does not implicitly {@link DistributionBucketFamilyMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {IDistributionBucketFamilyMetadata} message DistributionBucketFamilyMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    DistributionBucketFamilyMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.region != null && Object.hasOwnProperty.call(message, "region"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.region);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.areas != null && message.areas.length)
+            for (var i = 0; i < message.areas.length; ++i)
+                $root.GeographicalArea.encode(message.areas[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
+        if (message.latencyTestTargets != null && message.latencyTestTargets.length)
+            for (var i = 0; i < message.latencyTestTargets.length; ++i)
+                writer.uint32(/* id 4, wireType 2 =*/34).string(message.latencyTestTargets[i]);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified DistributionBucketFamilyMetadata message, length delimited. Does not implicitly {@link DistributionBucketFamilyMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {IDistributionBucketFamilyMetadata} message DistributionBucketFamilyMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    DistributionBucketFamilyMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a DistributionBucketFamilyMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {DistributionBucketFamilyMetadata} DistributionBucketFamilyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    DistributionBucketFamilyMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DistributionBucketFamilyMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.region = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                if (!(message.areas && message.areas.length))
+                    message.areas = [];
+                message.areas.push($root.GeographicalArea.decode(reader, reader.uint32()));
+                break;
+            case 4:
+                if (!(message.latencyTestTargets && message.latencyTestTargets.length))
+                    message.latencyTestTargets = [];
+                message.latencyTestTargets.push(reader.string());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a DistributionBucketFamilyMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {DistributionBucketFamilyMetadata} DistributionBucketFamilyMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    DistributionBucketFamilyMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a DistributionBucketFamilyMetadata message.
+     * @function verify
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    DistributionBucketFamilyMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.region != null && message.hasOwnProperty("region"))
+            if (!$util.isString(message.region))
+                return "region: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.areas != null && message.hasOwnProperty("areas")) {
+            if (!Array.isArray(message.areas))
+                return "areas: array expected";
+            for (var i = 0; i < message.areas.length; ++i) {
+                var error = $root.GeographicalArea.verify(message.areas[i]);
+                if (error)
+                    return "areas." + error;
+            }
+        }
+        if (message.latencyTestTargets != null && message.hasOwnProperty("latencyTestTargets")) {
+            if (!Array.isArray(message.latencyTestTargets))
+                return "latencyTestTargets: array expected";
+            for (var i = 0; i < message.latencyTestTargets.length; ++i)
+                if (!$util.isString(message.latencyTestTargets[i]))
+                    return "latencyTestTargets: string[] expected";
+        }
+        return null;
+    };
+
+    /**
+     * Creates a DistributionBucketFamilyMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {DistributionBucketFamilyMetadata} DistributionBucketFamilyMetadata
+     */
+    DistributionBucketFamilyMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.DistributionBucketFamilyMetadata)
+            return object;
+        var message = new $root.DistributionBucketFamilyMetadata();
+        if (object.region != null)
+            message.region = String(object.region);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.areas) {
+            if (!Array.isArray(object.areas))
+                throw TypeError(".DistributionBucketFamilyMetadata.areas: array expected");
+            message.areas = [];
+            for (var i = 0; i < object.areas.length; ++i) {
+                if (typeof object.areas[i] !== "object")
+                    throw TypeError(".DistributionBucketFamilyMetadata.areas: object expected");
+                message.areas[i] = $root.GeographicalArea.fromObject(object.areas[i]);
+            }
+        }
+        if (object.latencyTestTargets) {
+            if (!Array.isArray(object.latencyTestTargets))
+                throw TypeError(".DistributionBucketFamilyMetadata.latencyTestTargets: array expected");
+            message.latencyTestTargets = [];
+            for (var i = 0; i < object.latencyTestTargets.length; ++i)
+                message.latencyTestTargets[i] = String(object.latencyTestTargets[i]);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a DistributionBucketFamilyMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof DistributionBucketFamilyMetadata
+     * @static
+     * @param {DistributionBucketFamilyMetadata} message DistributionBucketFamilyMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    DistributionBucketFamilyMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults) {
+            object.areas = [];
+            object.latencyTestTargets = [];
+        }
+        if (options.defaults) {
+            object.region = "";
+            object.description = "";
+        }
+        if (message.region != null && message.hasOwnProperty("region"))
+            object.region = message.region;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.areas && message.areas.length) {
+            object.areas = [];
+            for (var j = 0; j < message.areas.length; ++j)
+                object.areas[j] = $root.GeographicalArea.toObject(message.areas[j], options);
+        }
+        if (message.latencyTestTargets && message.latencyTestTargets.length) {
+            object.latencyTestTargets = [];
+            for (var j = 0; j < message.latencyTestTargets.length; ++j)
+                object.latencyTestTargets[j] = message.latencyTestTargets[j];
+        }
+        return object;
+    };
+
+    /**
+     * Converts this DistributionBucketFamilyMetadata to JSON.
+     * @function toJSON
+     * @memberof DistributionBucketFamilyMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    DistributionBucketFamilyMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return DistributionBucketFamilyMetadata;
+})();
+
+$root.TokenMetadata = (function() {
+
+    /**
+     * Properties of a TokenMetadata.
+     * @exports ITokenMetadata
+     * @interface ITokenMetadata
+     * @property {string|null} [name] TokenMetadata name
+     * @property {string|null} [description] TokenMetadata description
+     * @property {number|null} [avatarObject] TokenMetadata avatarObject
+     * @property {string|null} [avatarUri] TokenMetadata avatarUri
+     * @property {Array.<IBenefit>|null} [benefits] TokenMetadata benefits
+     * @property {string|null} [whitelistApplicationNote] TokenMetadata whitelistApplicationNote
+     * @property {string|null} [whitelistApplicationApplyLink] TokenMetadata whitelistApplicationApplyLink
+     */
+
+    /**
+     * Constructs a new TokenMetadata.
+     * @exports TokenMetadata
+     * @classdesc Represents a TokenMetadata.
+     * @implements ITokenMetadata
+     * @constructor
+     * @param {ITokenMetadata=} [properties] Properties to set
+     */
+    function TokenMetadata(properties) {
+        this.benefits = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * TokenMetadata name.
+     * @member {string} name
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.name = "";
+
+    /**
+     * TokenMetadata description.
+     * @member {string} description
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.description = "";
+
+    /**
+     * TokenMetadata avatarObject.
+     * @member {number|null|undefined} avatarObject
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.avatarObject = null;
+
+    /**
+     * TokenMetadata avatarUri.
+     * @member {string|null|undefined} avatarUri
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.avatarUri = null;
+
+    /**
+     * TokenMetadata benefits.
+     * @member {Array.<IBenefit>} benefits
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.benefits = $util.emptyArray;
+
+    /**
+     * TokenMetadata whitelistApplicationNote.
+     * @member {string} whitelistApplicationNote
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.whitelistApplicationNote = "";
+
+    /**
+     * TokenMetadata whitelistApplicationApplyLink.
+     * @member {string} whitelistApplicationApplyLink
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.whitelistApplicationApplyLink = "";
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * TokenMetadata avatar.
+     * @member {"avatarObject"|"avatarUri"|undefined} avatar
+     * @memberof TokenMetadata
+     * @instance
+     */
+    Object.defineProperty(TokenMetadata.prototype, "avatar", {
+        get: $util.oneOfGetter($oneOfFields = ["avatarObject", "avatarUri"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new TokenMetadata instance using the specified properties.
+     * @function create
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata=} [properties] Properties to set
+     * @returns {TokenMetadata} TokenMetadata instance
+     */
+    TokenMetadata.create = function create(properties) {
+        return new TokenMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified TokenMetadata message. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata} message TokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    TokenMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.avatarObject != null && Object.hasOwnProperty.call(message, "avatarObject"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.avatarObject);
+        if (message.avatarUri != null && Object.hasOwnProperty.call(message, "avatarUri"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarUri);
+        if (message.benefits != null && message.benefits.length)
+            for (var i = 0; i < message.benefits.length; ++i)
+                $root.Benefit.encode(message.benefits[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
+        if (message.whitelistApplicationNote != null && Object.hasOwnProperty.call(message, "whitelistApplicationNote"))
+            writer.uint32(/* id 6, wireType 2 =*/50).string(message.whitelistApplicationNote);
+        if (message.whitelistApplicationApplyLink != null && Object.hasOwnProperty.call(message, "whitelistApplicationApplyLink"))
+            writer.uint32(/* id 7, wireType 2 =*/58).string(message.whitelistApplicationApplyLink);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified TokenMetadata message, length delimited. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata} message TokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    TokenMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof TokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {TokenMetadata} TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    TokenMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TokenMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.name = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.avatarObject = reader.uint32();
+                break;
+            case 4:
+                message.avatarUri = reader.string();
+                break;
+            case 5:
+                if (!(message.benefits && message.benefits.length))
+                    message.benefits = [];
+                message.benefits.push($root.Benefit.decode(reader, reader.uint32()));
+                break;
+            case 6:
+                message.whitelistApplicationNote = reader.string();
+                break;
+            case 7:
+                message.whitelistApplicationApplyLink = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof TokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {TokenMetadata} TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    TokenMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a TokenMetadata message.
+     * @function verify
+     * @memberof TokenMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    TokenMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.name != null && message.hasOwnProperty("name"))
+            if (!$util.isString(message.name))
+                return "name: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            properties.avatar = 1;
+            if (!$util.isInteger(message.avatarObject))
+                return "avatarObject: integer expected";
+        }
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            if (properties.avatar === 1)
+                return "avatar: multiple values";
+            properties.avatar = 1;
+            if (!$util.isString(message.avatarUri))
+                return "avatarUri: string expected";
+        }
+        if (message.benefits != null && message.hasOwnProperty("benefits")) {
+            if (!Array.isArray(message.benefits))
+                return "benefits: array expected";
+            for (var i = 0; i < message.benefits.length; ++i) {
+                var error = $root.Benefit.verify(message.benefits[i]);
+                if (error)
+                    return "benefits." + error;
+            }
+        }
+        if (message.whitelistApplicationNote != null && message.hasOwnProperty("whitelistApplicationNote"))
+            if (!$util.isString(message.whitelistApplicationNote))
+                return "whitelistApplicationNote: string expected";
+        if (message.whitelistApplicationApplyLink != null && message.hasOwnProperty("whitelistApplicationApplyLink"))
+            if (!$util.isString(message.whitelistApplicationApplyLink))
+                return "whitelistApplicationApplyLink: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a TokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof TokenMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {TokenMetadata} TokenMetadata
+     */
+    TokenMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.TokenMetadata)
+            return object;
+        var message = new $root.TokenMetadata();
+        if (object.name != null)
+            message.name = String(object.name);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.avatarObject != null)
+            message.avatarObject = object.avatarObject >>> 0;
+        if (object.avatarUri != null)
+            message.avatarUri = String(object.avatarUri);
+        if (object.benefits) {
+            if (!Array.isArray(object.benefits))
+                throw TypeError(".TokenMetadata.benefits: array expected");
+            message.benefits = [];
+            for (var i = 0; i < object.benefits.length; ++i) {
+                if (typeof object.benefits[i] !== "object")
+                    throw TypeError(".TokenMetadata.benefits: object expected");
+                message.benefits[i] = $root.Benefit.fromObject(object.benefits[i]);
+            }
+        }
+        if (object.whitelistApplicationNote != null)
+            message.whitelistApplicationNote = String(object.whitelistApplicationNote);
+        if (object.whitelistApplicationApplyLink != null)
+            message.whitelistApplicationApplyLink = String(object.whitelistApplicationApplyLink);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a TokenMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof TokenMetadata
+     * @static
+     * @param {TokenMetadata} message TokenMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    TokenMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.benefits = [];
+        if (options.defaults) {
+            object.name = "";
+            object.description = "";
+            object.whitelistApplicationNote = "";
+            object.whitelistApplicationApplyLink = "";
+        }
+        if (message.name != null && message.hasOwnProperty("name"))
+            object.name = message.name;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            object.avatarObject = message.avatarObject;
+            if (options.oneofs)
+                object.avatar = "avatarObject";
+        }
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            object.avatarUri = message.avatarUri;
+            if (options.oneofs)
+                object.avatar = "avatarUri";
+        }
+        if (message.benefits && message.benefits.length) {
+            object.benefits = [];
+            for (var j = 0; j < message.benefits.length; ++j)
+                object.benefits[j] = $root.Benefit.toObject(message.benefits[j], options);
+        }
+        if (message.whitelistApplicationNote != null && message.hasOwnProperty("whitelistApplicationNote"))
+            object.whitelistApplicationNote = message.whitelistApplicationNote;
+        if (message.whitelistApplicationApplyLink != null && message.hasOwnProperty("whitelistApplicationApplyLink"))
+            object.whitelistApplicationApplyLink = message.whitelistApplicationApplyLink;
+        return object;
+    };
+
+    /**
+     * Converts this TokenMetadata to JSON.
+     * @function toJSON
+     * @memberof TokenMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    TokenMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return TokenMetadata;
+})();
+
+$root.Benefit = (function() {
+
+    /**
+     * Properties of a Benefit.
+     * @exports IBenefit
+     * @interface IBenefit
+     * @property {string|null} [title] Benefit title
+     * @property {string|null} [description] Benefit description
+     * @property {string|null} [emoji] Benefit emoji
+     * @property {number|null} [displayOrder] Benefit displayOrder
+     */
+
+    /**
+     * Constructs a new Benefit.
+     * @exports Benefit
+     * @classdesc Represents a Benefit.
+     * @implements IBenefit
+     * @constructor
+     * @param {IBenefit=} [properties] Properties to set
+     */
+    function Benefit(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * Benefit title.
+     * @member {string} title
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.title = "";
+
+    /**
+     * Benefit description.
+     * @member {string} description
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.description = "";
+
+    /**
+     * Benefit emoji.
+     * @member {string} emoji
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.emoji = "";
+
+    /**
+     * Benefit displayOrder.
+     * @member {number} displayOrder
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.displayOrder = 0;
+
+    /**
+     * Creates a new Benefit instance using the specified properties.
+     * @function create
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit=} [properties] Properties to set
+     * @returns {Benefit} Benefit instance
+     */
+    Benefit.create = function create(properties) {
+        return new Benefit(properties);
+    };
+
+    /**
+     * Encodes the specified Benefit message. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @function encode
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit} message Benefit message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Benefit.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.emoji);
+        if (message.displayOrder != null && Object.hasOwnProperty.call(message, "displayOrder"))
+            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.displayOrder);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified Benefit message, length delimited. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit} message Benefit message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Benefit.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer.
+     * @function decode
+     * @memberof Benefit
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {Benefit} Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Benefit.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Benefit();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.emoji = reader.string();
+                break;
+            case 4:
+                message.displayOrder = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof Benefit
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {Benefit} Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Benefit.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a Benefit message.
+     * @function verify
+     * @memberof Benefit
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    Benefit.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.emoji != null && message.hasOwnProperty("emoji"))
+            if (!$util.isString(message.emoji))
+                return "emoji: string expected";
+        if (message.displayOrder != null && message.hasOwnProperty("displayOrder"))
+            if (!$util.isInteger(message.displayOrder))
+                return "displayOrder: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a Benefit message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof Benefit
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {Benefit} Benefit
+     */
+    Benefit.fromObject = function fromObject(object) {
+        if (object instanceof $root.Benefit)
+            return object;
+        var message = new $root.Benefit();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.emoji != null)
+            message.emoji = String(object.emoji);
+        if (object.displayOrder != null)
+            message.displayOrder = object.displayOrder >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a Benefit message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof Benefit
+     * @static
+     * @param {Benefit} message Benefit
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    Benefit.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            object.emoji = "";
+            object.displayOrder = 0;
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.emoji != null && message.hasOwnProperty("emoji"))
+            object.emoji = message.emoji;
+        if (message.displayOrder != null && message.hasOwnProperty("displayOrder"))
+            object.displayOrder = message.displayOrder;
+        return object;
+    };
+
+    /**
+     * Converts this Benefit to JSON.
+     * @function toJSON
+     * @memberof Benefit
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    Benefit.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return Benefit;
+})();
+
+$root.Sale = (function() {
+
+    /**
+     * Properties of a Sale.
+     * @exports ISale
+     * @interface ISale
+     * @property {string|null} [termsAndConditions] Sale termsAndConditions
+     */
+
+    /**
+     * Constructs a new Sale.
+     * @exports Sale
+     * @classdesc Represents a Sale.
+     * @implements ISale
+     * @constructor
+     * @param {ISale=} [properties] Properties to set
+     */
+    function Sale(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * Sale termsAndConditions.
+     * @member {string} termsAndConditions
+     * @memberof Sale
+     * @instance
+     */
+    Sale.prototype.termsAndConditions = "";
+
+    /**
+     * Creates a new Sale instance using the specified properties.
+     * @function create
+     * @memberof Sale
+     * @static
+     * @param {ISale=} [properties] Properties to set
+     * @returns {Sale} Sale instance
+     */
+    Sale.create = function create(properties) {
+        return new Sale(properties);
+    };
+
+    /**
+     * Encodes the specified Sale message. Does not implicitly {@link Sale.verify|verify} messages.
+     * @function encode
+     * @memberof Sale
+     * @static
+     * @param {ISale} message Sale message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Sale.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.termsAndConditions != null && Object.hasOwnProperty.call(message, "termsAndConditions"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.termsAndConditions);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified Sale message, length delimited. Does not implicitly {@link Sale.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof Sale
+     * @static
+     * @param {ISale} message Sale message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Sale.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a Sale message from the specified reader or buffer.
+     * @function decode
+     * @memberof Sale
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {Sale} Sale
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Sale.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Sale();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.termsAndConditions = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a Sale message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof Sale
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {Sale} Sale
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Sale.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a Sale message.
+     * @function verify
+     * @memberof Sale
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    Sale.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
+            if (!$util.isString(message.termsAndConditions))
+                return "termsAndConditions: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a Sale message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof Sale
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {Sale} Sale
+     */
+    Sale.fromObject = function fromObject(object) {
+        if (object instanceof $root.Sale)
+            return object;
+        var message = new $root.Sale();
+        if (object.termsAndConditions != null)
+            message.termsAndConditions = String(object.termsAndConditions);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a Sale message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof Sale
+     * @static
+     * @param {Sale} message Sale
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    Sale.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.termsAndConditions = "";
+        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
+            object.termsAndConditions = message.termsAndConditions;
+        return object;
+    };
+
+    /**
+     * Converts this Sale to JSON.
+     * @function toJSON
+     * @memberof Sale
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    Sale.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return Sale;
+})();
+
+$root.PublishedBeforeJoystream = (function() {
+
+    /**
+     * Properties of a PublishedBeforeJoystream.
+     * @exports IPublishedBeforeJoystream
+     * @interface IPublishedBeforeJoystream
+     * @property {boolean|null} [isPublished] PublishedBeforeJoystream isPublished
+     * @property {string|null} [date] PublishedBeforeJoystream date
+     */
+
+    /**
+     * Constructs a new PublishedBeforeJoystream.
+     * @exports PublishedBeforeJoystream
+     * @classdesc Represents a PublishedBeforeJoystream.
+     * @implements IPublishedBeforeJoystream
+     * @constructor
+     * @param {IPublishedBeforeJoystream=} [properties] Properties to set
+     */
+    function PublishedBeforeJoystream(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * PublishedBeforeJoystream isPublished.
+     * @member {boolean} isPublished
+     * @memberof PublishedBeforeJoystream
+     * @instance
+     */
+    PublishedBeforeJoystream.prototype.isPublished = false;
+
+    /**
+     * PublishedBeforeJoystream date.
+     * @member {string} date
+     * @memberof PublishedBeforeJoystream
+     * @instance
+     */
+    PublishedBeforeJoystream.prototype.date = "";
+
+    /**
+     * Creates a new PublishedBeforeJoystream instance using the specified properties.
+     * @function create
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {IPublishedBeforeJoystream=} [properties] Properties to set
+     * @returns {PublishedBeforeJoystream} PublishedBeforeJoystream instance
+     */
+    PublishedBeforeJoystream.create = function create(properties) {
+        return new PublishedBeforeJoystream(properties);
+    };
+
+    /**
+     * Encodes the specified PublishedBeforeJoystream message. Does not implicitly {@link PublishedBeforeJoystream.verify|verify} messages.
+     * @function encode
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {IPublishedBeforeJoystream} message PublishedBeforeJoystream message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    PublishedBeforeJoystream.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.isPublished != null && Object.hasOwnProperty.call(message, "isPublished"))
+            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isPublished);
+        if (message.date != null && Object.hasOwnProperty.call(message, "date"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.date);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified PublishedBeforeJoystream message, length delimited. Does not implicitly {@link PublishedBeforeJoystream.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {IPublishedBeforeJoystream} message PublishedBeforeJoystream message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    PublishedBeforeJoystream.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a PublishedBeforeJoystream message from the specified reader or buffer.
+     * @function decode
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {PublishedBeforeJoystream} PublishedBeforeJoystream
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    PublishedBeforeJoystream.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PublishedBeforeJoystream();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.isPublished = reader.bool();
+                break;
+            case 2:
+                message.date = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a PublishedBeforeJoystream message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {PublishedBeforeJoystream} PublishedBeforeJoystream
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    PublishedBeforeJoystream.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a PublishedBeforeJoystream message.
+     * @function verify
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    PublishedBeforeJoystream.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.isPublished != null && message.hasOwnProperty("isPublished"))
+            if (typeof message.isPublished !== "boolean")
+                return "isPublished: boolean expected";
+        if (message.date != null && message.hasOwnProperty("date"))
+            if (!$util.isString(message.date))
+                return "date: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a PublishedBeforeJoystream message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {PublishedBeforeJoystream} PublishedBeforeJoystream
+     */
+    PublishedBeforeJoystream.fromObject = function fromObject(object) {
+        if (object instanceof $root.PublishedBeforeJoystream)
+            return object;
+        var message = new $root.PublishedBeforeJoystream();
+        if (object.isPublished != null)
+            message.isPublished = Boolean(object.isPublished);
+        if (object.date != null)
+            message.date = String(object.date);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a PublishedBeforeJoystream message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof PublishedBeforeJoystream
+     * @static
+     * @param {PublishedBeforeJoystream} message PublishedBeforeJoystream
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    PublishedBeforeJoystream.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.isPublished = false;
+            object.date = "";
+        }
+        if (message.isPublished != null && message.hasOwnProperty("isPublished"))
+            object.isPublished = message.isPublished;
+        if (message.date != null && message.hasOwnProperty("date"))
+            object.date = message.date;
+        return object;
+    };
+
+    /**
+     * Converts this PublishedBeforeJoystream to JSON.
+     * @function toJSON
+     * @memberof PublishedBeforeJoystream
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    PublishedBeforeJoystream.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return PublishedBeforeJoystream;
+})();
+
+$root.License = (function() {
+
+    /**
+     * Properties of a License.
+     * @exports ILicense
+     * @interface ILicense
+     * @property {number|null} [code] License code
+     * @property {string|null} [attribution] License attribution
+     * @property {string|null} [customText] License customText
+     */
+
+    /**
+     * Constructs a new License.
+     * @exports License
+     * @classdesc Represents a License.
+     * @implements ILicense
+     * @constructor
+     * @param {ILicense=} [properties] Properties to set
+     */
+    function License(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * License code.
+     * @member {number} code
+     * @memberof License
+     * @instance
+     */
+    License.prototype.code = 0;
+
+    /**
+     * License attribution.
+     * @member {string} attribution
+     * @memberof License
+     * @instance
+     */
+    License.prototype.attribution = "";
+
+    /**
+     * License customText.
+     * @member {string} customText
+     * @memberof License
+     * @instance
+     */
+    License.prototype.customText = "";
+
+    /**
+     * Creates a new License instance using the specified properties.
+     * @function create
+     * @memberof License
+     * @static
+     * @param {ILicense=} [properties] Properties to set
+     * @returns {License} License instance
+     */
+    License.create = function create(properties) {
+        return new License(properties);
+    };
+
+    /**
+     * Encodes the specified License message. Does not implicitly {@link License.verify|verify} messages.
+     * @function encode
+     * @memberof License
+     * @static
+     * @param {ILicense} message License message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    License.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.code != null && Object.hasOwnProperty.call(message, "code"))
+            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);
+        if (message.attribution != null && Object.hasOwnProperty.call(message, "attribution"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.attribution);
+        if (message.customText != null && Object.hasOwnProperty.call(message, "customText"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.customText);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified License message, length delimited. Does not implicitly {@link License.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof License
+     * @static
+     * @param {ILicense} message License message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    License.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a License message from the specified reader or buffer.
+     * @function decode
+     * @memberof License
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {License} License
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    License.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.License();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.code = reader.uint32();
+                break;
+            case 2:
+                message.attribution = reader.string();
+                break;
+            case 3:
+                message.customText = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a License message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof License
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {License} License
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    License.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a License message.
+     * @function verify
+     * @memberof License
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    License.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.code != null && message.hasOwnProperty("code"))
+            if (!$util.isInteger(message.code))
+                return "code: integer expected";
+        if (message.attribution != null && message.hasOwnProperty("attribution"))
+            if (!$util.isString(message.attribution))
+                return "attribution: string expected";
+        if (message.customText != null && message.hasOwnProperty("customText"))
+            if (!$util.isString(message.customText))
+                return "customText: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a License message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof License
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {License} License
+     */
+    License.fromObject = function fromObject(object) {
+        if (object instanceof $root.License)
+            return object;
+        var message = new $root.License();
+        if (object.code != null)
+            message.code = object.code >>> 0;
+        if (object.attribution != null)
+            message.attribution = String(object.attribution);
+        if (object.customText != null)
+            message.customText = String(object.customText);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a License message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof License
+     * @static
+     * @param {License} message License
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    License.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.code = 0;
+            object.attribution = "";
+            object.customText = "";
+        }
+        if (message.code != null && message.hasOwnProperty("code"))
+            object.code = message.code;
+        if (message.attribution != null && message.hasOwnProperty("attribution"))
+            object.attribution = message.attribution;
+        if (message.customText != null && message.hasOwnProperty("customText"))
+            object.customText = message.customText;
+        return object;
+    };
+
+    /**
+     * Converts this License to JSON.
+     * @function toJSON
+     * @memberof License
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    License.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return License;
+})();
+
+$root.MediaType = (function() {
+
+    /**
+     * Properties of a MediaType.
+     * @exports IMediaType
+     * @interface IMediaType
+     * @property {string|null} [codecName] MediaType codecName
+     * @property {string|null} [container] MediaType container
+     * @property {string|null} [mimeMediaType] MediaType mimeMediaType
+     */
+
+    /**
+     * Constructs a new MediaType.
+     * @exports MediaType
+     * @classdesc Represents a MediaType.
+     * @implements IMediaType
+     * @constructor
+     * @param {IMediaType=} [properties] Properties to set
+     */
+    function MediaType(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * MediaType codecName.
+     * @member {string} codecName
+     * @memberof MediaType
+     * @instance
+     */
+    MediaType.prototype.codecName = "";
+
+    /**
+     * MediaType container.
+     * @member {string} container
+     * @memberof MediaType
+     * @instance
+     */
+    MediaType.prototype.container = "";
+
+    /**
+     * MediaType mimeMediaType.
+     * @member {string} mimeMediaType
+     * @memberof MediaType
+     * @instance
+     */
+    MediaType.prototype.mimeMediaType = "";
+
+    /**
+     * Creates a new MediaType instance using the specified properties.
+     * @function create
+     * @memberof MediaType
+     * @static
+     * @param {IMediaType=} [properties] Properties to set
+     * @returns {MediaType} MediaType instance
+     */
+    MediaType.create = function create(properties) {
+        return new MediaType(properties);
+    };
+
+    /**
+     * Encodes the specified MediaType message. Does not implicitly {@link MediaType.verify|verify} messages.
+     * @function encode
+     * @memberof MediaType
+     * @static
+     * @param {IMediaType} message MediaType message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MediaType.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.codecName != null && Object.hasOwnProperty.call(message, "codecName"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.codecName);
+        if (message.container != null && Object.hasOwnProperty.call(message, "container"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.container);
+        if (message.mimeMediaType != null && Object.hasOwnProperty.call(message, "mimeMediaType"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.mimeMediaType);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified MediaType message, length delimited. Does not implicitly {@link MediaType.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof MediaType
+     * @static
+     * @param {IMediaType} message MediaType message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    MediaType.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a MediaType message from the specified reader or buffer.
+     * @function decode
+     * @memberof MediaType
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {MediaType} MediaType
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MediaType.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.MediaType();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.codecName = reader.string();
+                break;
+            case 2:
+                message.container = reader.string();
+                break;
+            case 3:
+                message.mimeMediaType = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a MediaType message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof MediaType
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {MediaType} MediaType
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    MediaType.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a MediaType message.
+     * @function verify
+     * @memberof MediaType
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    MediaType.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.codecName != null && message.hasOwnProperty("codecName"))
+            if (!$util.isString(message.codecName))
+                return "codecName: string expected";
+        if (message.container != null && message.hasOwnProperty("container"))
+            if (!$util.isString(message.container))
+                return "container: string expected";
+        if (message.mimeMediaType != null && message.hasOwnProperty("mimeMediaType"))
+            if (!$util.isString(message.mimeMediaType))
+                return "mimeMediaType: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a MediaType message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof MediaType
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {MediaType} MediaType
+     */
+    MediaType.fromObject = function fromObject(object) {
+        if (object instanceof $root.MediaType)
+            return object;
+        var message = new $root.MediaType();
+        if (object.codecName != null)
+            message.codecName = String(object.codecName);
+        if (object.container != null)
+            message.container = String(object.container);
+        if (object.mimeMediaType != null)
+            message.mimeMediaType = String(object.mimeMediaType);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a MediaType message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof MediaType
+     * @static
+     * @param {MediaType} message MediaType
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    MediaType.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.codecName = "";
+            object.container = "";
+            object.mimeMediaType = "";
+        }
+        if (message.codecName != null && message.hasOwnProperty("codecName"))
+            object.codecName = message.codecName;
+        if (message.container != null && message.hasOwnProperty("container"))
+            object.container = message.container;
+        if (message.mimeMediaType != null && message.hasOwnProperty("mimeMediaType"))
+            object.mimeMediaType = message.mimeMediaType;
+        return object;
+    };
+
+    /**
+     * Converts this MediaType to JSON.
+     * @function toJSON
+     * @memberof MediaType
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    MediaType.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return MediaType;
+})();
+
+$root.SubtitleMetadata = (function() {
+
+    /**
+     * Properties of a SubtitleMetadata.
+     * @exports ISubtitleMetadata
+     * @interface ISubtitleMetadata
+     * @property {string} type SubtitleMetadata type
+     * @property {number|null} [newAsset] SubtitleMetadata newAsset
+     * @property {string} language SubtitleMetadata language
+     * @property {string} mimeType SubtitleMetadata mimeType
+     */
+
+    /**
+     * Constructs a new SubtitleMetadata.
+     * @exports SubtitleMetadata
+     * @classdesc Represents a SubtitleMetadata.
+     * @implements ISubtitleMetadata
+     * @constructor
+     * @param {ISubtitleMetadata=} [properties] Properties to set
+     */
+    function SubtitleMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * SubtitleMetadata type.
+     * @member {string} type
+     * @memberof SubtitleMetadata
+     * @instance
+     */
+    SubtitleMetadata.prototype.type = "";
+
+    /**
+     * SubtitleMetadata newAsset.
+     * @member {number} newAsset
+     * @memberof SubtitleMetadata
+     * @instance
+     */
+    SubtitleMetadata.prototype.newAsset = 0;
+
+    /**
+     * SubtitleMetadata language.
+     * @member {string} language
+     * @memberof SubtitleMetadata
+     * @instance
+     */
+    SubtitleMetadata.prototype.language = "";
+
+    /**
+     * SubtitleMetadata mimeType.
+     * @member {string} mimeType
+     * @memberof SubtitleMetadata
+     * @instance
+     */
+    SubtitleMetadata.prototype.mimeType = "";
+
+    /**
+     * Creates a new SubtitleMetadata instance using the specified properties.
+     * @function create
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {ISubtitleMetadata=} [properties] Properties to set
+     * @returns {SubtitleMetadata} SubtitleMetadata instance
+     */
+    SubtitleMetadata.create = function create(properties) {
+        return new SubtitleMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified SubtitleMetadata message. Does not implicitly {@link SubtitleMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {ISubtitleMetadata} message SubtitleMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SubtitleMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
+        if (message.newAsset != null && Object.hasOwnProperty.call(message, "newAsset"))
+            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.newAsset);
+        writer.uint32(/* id 3, wireType 2 =*/26).string(message.language);
+        writer.uint32(/* id 4, wireType 2 =*/34).string(message.mimeType);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified SubtitleMetadata message, length delimited. Does not implicitly {@link SubtitleMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {ISubtitleMetadata} message SubtitleMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SubtitleMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a SubtitleMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {SubtitleMetadata} SubtitleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SubtitleMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SubtitleMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.type = reader.string();
+                break;
+            case 2:
+                message.newAsset = reader.uint32();
+                break;
+            case 3:
+                message.language = reader.string();
+                break;
+            case 4:
+                message.mimeType = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("type"))
+            throw $util.ProtocolError("missing required 'type'", { instance: message });
+        if (!message.hasOwnProperty("language"))
+            throw $util.ProtocolError("missing required 'language'", { instance: message });
+        if (!message.hasOwnProperty("mimeType"))
+            throw $util.ProtocolError("missing required 'mimeType'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a SubtitleMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {SubtitleMetadata} SubtitleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SubtitleMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a SubtitleMetadata message.
+     * @function verify
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    SubtitleMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isString(message.type))
+            return "type: string expected";
+        if (message.newAsset != null && message.hasOwnProperty("newAsset"))
+            if (!$util.isInteger(message.newAsset))
+                return "newAsset: integer expected";
+        if (!$util.isString(message.language))
+            return "language: string expected";
+        if (!$util.isString(message.mimeType))
+            return "mimeType: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a SubtitleMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {SubtitleMetadata} SubtitleMetadata
+     */
+    SubtitleMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.SubtitleMetadata)
+            return object;
+        var message = new $root.SubtitleMetadata();
+        if (object.type != null)
+            message.type = String(object.type);
+        if (object.newAsset != null)
+            message.newAsset = object.newAsset >>> 0;
+        if (object.language != null)
+            message.language = String(object.language);
+        if (object.mimeType != null)
+            message.mimeType = String(object.mimeType);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a SubtitleMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof SubtitleMetadata
+     * @static
+     * @param {SubtitleMetadata} message SubtitleMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    SubtitleMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.type = "";
+            object.newAsset = 0;
+            object.language = "";
+            object.mimeType = "";
+        }
+        if (message.type != null && message.hasOwnProperty("type"))
+            object.type = message.type;
+        if (message.newAsset != null && message.hasOwnProperty("newAsset"))
+            object.newAsset = message.newAsset;
+        if (message.language != null && message.hasOwnProperty("language"))
+            object.language = message.language;
+        if (message.mimeType != null && message.hasOwnProperty("mimeType"))
+            object.mimeType = message.mimeType;
+        return object;
+    };
+
+    /**
+     * Converts this SubtitleMetadata to JSON.
+     * @function toJSON
+     * @memberof SubtitleMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    SubtitleMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return SubtitleMetadata;
+})();
+
+$root.VideoMetadata = (function() {
+
+    /**
+     * Properties of a VideoMetadata.
+     * @exports IVideoMetadata
+     * @interface IVideoMetadata
+     * @property {string|null} [title] VideoMetadata title
+     * @property {string|null} [description] VideoMetadata description
+     * @property {number|null} [video] VideoMetadata video
+     * @property {number|null} [thumbnailPhoto] VideoMetadata thumbnailPhoto
+     * @property {number|null} [duration] VideoMetadata duration
+     * @property {number|null} [mediaPixelHeight] VideoMetadata mediaPixelHeight
+     * @property {number|null} [mediaPixelWidth] VideoMetadata mediaPixelWidth
+     * @property {IMediaType|null} [mediaType] VideoMetadata mediaType
+     * @property {string|null} [language] VideoMetadata language
+     * @property {ILicense|null} [license] VideoMetadata license
+     * @property {IPublishedBeforeJoystream|null} [publishedBeforeJoystream] VideoMetadata publishedBeforeJoystream
+     * @property {boolean|null} [hasMarketing] VideoMetadata hasMarketing
+     * @property {boolean|null} [isPublic] VideoMetadata isPublic
+     * @property {boolean|null} [isExplicit] VideoMetadata isExplicit
+     * @property {Array.<Long>|null} [persons] VideoMetadata persons
+     * @property {string|null} [category] VideoMetadata category
+     * @property {Array.<ISubtitleMetadata>|null} [subtitles] VideoMetadata subtitles
+     * @property {boolean|null} [enableComments] VideoMetadata enableComments
+     * @property {boolean|null} [clearSubtitles] VideoMetadata clearSubtitles
+     */
+
+    /**
+     * Constructs a new VideoMetadata.
+     * @exports VideoMetadata
+     * @classdesc Represents a VideoMetadata.
+     * @implements IVideoMetadata
+     * @constructor
+     * @param {IVideoMetadata=} [properties] Properties to set
+     */
+    function VideoMetadata(properties) {
+        this.persons = [];
+        this.subtitles = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * VideoMetadata title.
+     * @member {string} title
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.title = "";
+
+    /**
+     * VideoMetadata description.
+     * @member {string} description
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.description = "";
+
+    /**
+     * VideoMetadata video.
+     * @member {number} video
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.video = 0;
+
+    /**
+     * VideoMetadata thumbnailPhoto.
+     * @member {number} thumbnailPhoto
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.thumbnailPhoto = 0;
+
+    /**
+     * VideoMetadata duration.
+     * @member {number} duration
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.duration = 0;
+
+    /**
+     * VideoMetadata mediaPixelHeight.
+     * @member {number} mediaPixelHeight
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.mediaPixelHeight = 0;
+
+    /**
+     * VideoMetadata mediaPixelWidth.
+     * @member {number} mediaPixelWidth
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.mediaPixelWidth = 0;
+
+    /**
+     * VideoMetadata mediaType.
+     * @member {IMediaType|null|undefined} mediaType
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.mediaType = null;
+
+    /**
+     * VideoMetadata language.
+     * @member {string} language
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.language = "";
+
+    /**
+     * VideoMetadata license.
+     * @member {ILicense|null|undefined} license
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.license = null;
+
+    /**
+     * VideoMetadata publishedBeforeJoystream.
+     * @member {IPublishedBeforeJoystream|null|undefined} publishedBeforeJoystream
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.publishedBeforeJoystream = null;
+
+    /**
+     * VideoMetadata hasMarketing.
+     * @member {boolean} hasMarketing
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.hasMarketing = false;
+
+    /**
+     * VideoMetadata isPublic.
+     * @member {boolean} isPublic
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.isPublic = false;
+
+    /**
+     * VideoMetadata isExplicit.
+     * @member {boolean} isExplicit
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.isExplicit = false;
+
+    /**
+     * VideoMetadata persons.
+     * @member {Array.<Long>} persons
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.persons = $util.emptyArray;
+
+    /**
+     * VideoMetadata category.
+     * @member {string} category
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.category = "";
+
+    /**
+     * VideoMetadata subtitles.
+     * @member {Array.<ISubtitleMetadata>} subtitles
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.subtitles = $util.emptyArray;
+
+    /**
+     * VideoMetadata enableComments.
+     * @member {boolean} enableComments
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.enableComments = false;
+
+    /**
+     * VideoMetadata clearSubtitles.
+     * @member {boolean} clearSubtitles
+     * @memberof VideoMetadata
+     * @instance
+     */
+    VideoMetadata.prototype.clearSubtitles = false;
+
+    /**
+     * Creates a new VideoMetadata instance using the specified properties.
+     * @function create
+     * @memberof VideoMetadata
+     * @static
+     * @param {IVideoMetadata=} [properties] Properties to set
+     * @returns {VideoMetadata} VideoMetadata instance
+     */
+    VideoMetadata.create = function create(properties) {
+        return new VideoMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified VideoMetadata message. Does not implicitly {@link VideoMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof VideoMetadata
+     * @static
+     * @param {IVideoMetadata} message VideoMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    VideoMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.video != null && Object.hasOwnProperty.call(message, "video"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.video);
+        if (message.thumbnailPhoto != null && Object.hasOwnProperty.call(message, "thumbnailPhoto"))
+            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.thumbnailPhoto);
+        if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
+            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.duration);
+        if (message.mediaPixelHeight != null && Object.hasOwnProperty.call(message, "mediaPixelHeight"))
+            writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.mediaPixelHeight);
+        if (message.mediaPixelWidth != null && Object.hasOwnProperty.call(message, "mediaPixelWidth"))
+            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.mediaPixelWidth);
+        if (message.mediaType != null && Object.hasOwnProperty.call(message, "mediaType"))
+            $root.MediaType.encode(message.mediaType, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
+        if (message.language != null && Object.hasOwnProperty.call(message, "language"))
+            writer.uint32(/* id 9, wireType 2 =*/74).string(message.language);
+        if (message.license != null && Object.hasOwnProperty.call(message, "license"))
+            $root.License.encode(message.license, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
+        if (message.publishedBeforeJoystream != null && Object.hasOwnProperty.call(message, "publishedBeforeJoystream"))
+            $root.PublishedBeforeJoystream.encode(message.publishedBeforeJoystream, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
+        if (message.hasMarketing != null && Object.hasOwnProperty.call(message, "hasMarketing"))
+            writer.uint32(/* id 12, wireType 0 =*/96).bool(message.hasMarketing);
+        if (message.isPublic != null && Object.hasOwnProperty.call(message, "isPublic"))
+            writer.uint32(/* id 13, wireType 0 =*/104).bool(message.isPublic);
+        if (message.isExplicit != null && Object.hasOwnProperty.call(message, "isExplicit"))
+            writer.uint32(/* id 14, wireType 0 =*/112).bool(message.isExplicit);
+        if (message.persons != null && message.persons.length) {
+            writer.uint32(/* id 15, wireType 2 =*/122).fork();
+            for (var i = 0; i < message.persons.length; ++i)
+                writer.uint64(message.persons[i]);
+            writer.ldelim();
+        }
+        if (message.category != null && Object.hasOwnProperty.call(message, "category"))
+            writer.uint32(/* id 16, wireType 2 =*/130).string(message.category);
+        if (message.subtitles != null && message.subtitles.length)
+            for (var i = 0; i < message.subtitles.length; ++i)
+                $root.SubtitleMetadata.encode(message.subtitles[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
+        if (message.enableComments != null && Object.hasOwnProperty.call(message, "enableComments"))
+            writer.uint32(/* id 18, wireType 0 =*/144).bool(message.enableComments);
+        if (message.clearSubtitles != null && Object.hasOwnProperty.call(message, "clearSubtitles"))
+            writer.uint32(/* id 19, wireType 0 =*/152).bool(message.clearSubtitles);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified VideoMetadata message, length delimited. Does not implicitly {@link VideoMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof VideoMetadata
+     * @static
+     * @param {IVideoMetadata} message VideoMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    VideoMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a VideoMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof VideoMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {VideoMetadata} VideoMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    VideoMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.VideoMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.video = reader.uint32();
+                break;
+            case 4:
+                message.thumbnailPhoto = reader.uint32();
+                break;
+            case 5:
+                message.duration = reader.uint32();
+                break;
+            case 6:
+                message.mediaPixelHeight = reader.uint32();
+                break;
+            case 7:
+                message.mediaPixelWidth = reader.uint32();
+                break;
+            case 8:
+                message.mediaType = $root.MediaType.decode(reader, reader.uint32());
+                break;
+            case 9:
+                message.language = reader.string();
+                break;
+            case 10:
+                message.license = $root.License.decode(reader, reader.uint32());
+                break;
+            case 11:
+                message.publishedBeforeJoystream = $root.PublishedBeforeJoystream.decode(reader, reader.uint32());
+                break;
+            case 12:
+                message.hasMarketing = reader.bool();
+                break;
+            case 13:
+                message.isPublic = reader.bool();
+                break;
+            case 14:
+                message.isExplicit = reader.bool();
+                break;
+            case 15:
+                if (!(message.persons && message.persons.length))
+                    message.persons = [];
+                if ((tag & 7) === 2) {
+                    var end2 = reader.uint32() + reader.pos;
+                    while (reader.pos < end2)
+                        message.persons.push(reader.uint64());
+                } else
+                    message.persons.push(reader.uint64());
+                break;
+            case 16:
+                message.category = reader.string();
+                break;
+            case 17:
+                if (!(message.subtitles && message.subtitles.length))
+                    message.subtitles = [];
+                message.subtitles.push($root.SubtitleMetadata.decode(reader, reader.uint32()));
+                break;
+            case 18:
+                message.enableComments = reader.bool();
+                break;
+            case 19:
+                message.clearSubtitles = reader.bool();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a VideoMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof VideoMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {VideoMetadata} VideoMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    VideoMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a VideoMetadata message.
+     * @function verify
+     * @memberof VideoMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    VideoMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.video != null && message.hasOwnProperty("video"))
+            if (!$util.isInteger(message.video))
+                return "video: integer expected";
+        if (message.thumbnailPhoto != null && message.hasOwnProperty("thumbnailPhoto"))
+            if (!$util.isInteger(message.thumbnailPhoto))
+                return "thumbnailPhoto: integer expected";
+        if (message.duration != null && message.hasOwnProperty("duration"))
+            if (!$util.isInteger(message.duration))
+                return "duration: integer expected";
+        if (message.mediaPixelHeight != null && message.hasOwnProperty("mediaPixelHeight"))
+            if (!$util.isInteger(message.mediaPixelHeight))
+                return "mediaPixelHeight: integer expected";
+        if (message.mediaPixelWidth != null && message.hasOwnProperty("mediaPixelWidth"))
+            if (!$util.isInteger(message.mediaPixelWidth))
+                return "mediaPixelWidth: integer expected";
+        if (message.mediaType != null && message.hasOwnProperty("mediaType")) {
+            var error = $root.MediaType.verify(message.mediaType);
+            if (error)
+                return "mediaType." + error;
+        }
+        if (message.language != null && message.hasOwnProperty("language"))
+            if (!$util.isString(message.language))
+                return "language: string expected";
+        if (message.license != null && message.hasOwnProperty("license")) {
+            var error = $root.License.verify(message.license);
+            if (error)
+                return "license." + error;
+        }
+        if (message.publishedBeforeJoystream != null && message.hasOwnProperty("publishedBeforeJoystream")) {
+            var error = $root.PublishedBeforeJoystream.verify(message.publishedBeforeJoystream);
+            if (error)
+                return "publishedBeforeJoystream." + error;
+        }
+        if (message.hasMarketing != null && message.hasOwnProperty("hasMarketing"))
+            if (typeof message.hasMarketing !== "boolean")
+                return "hasMarketing: boolean expected";
+        if (message.isPublic != null && message.hasOwnProperty("isPublic"))
+            if (typeof message.isPublic !== "boolean")
+                return "isPublic: boolean expected";
+        if (message.isExplicit != null && message.hasOwnProperty("isExplicit"))
+            if (typeof message.isExplicit !== "boolean")
+                return "isExplicit: boolean expected";
+        if (message.persons != null && message.hasOwnProperty("persons")) {
+            if (!Array.isArray(message.persons))
+                return "persons: array expected";
+            for (var i = 0; i < message.persons.length; ++i)
+                if (!$util.isInteger(message.persons[i]) && !(message.persons[i] && $util.isInteger(message.persons[i].low) && $util.isInteger(message.persons[i].high)))
+                    return "persons: integer|Long[] expected";
+        }
+        if (message.category != null && message.hasOwnProperty("category"))
+            if (!$util.isString(message.category))
+                return "category: string expected";
+        if (message.subtitles != null && message.hasOwnProperty("subtitles")) {
+            if (!Array.isArray(message.subtitles))
+                return "subtitles: array expected";
+            for (var i = 0; i < message.subtitles.length; ++i) {
+                var error = $root.SubtitleMetadata.verify(message.subtitles[i]);
+                if (error)
+                    return "subtitles." + error;
+            }
+        }
+        if (message.enableComments != null && message.hasOwnProperty("enableComments"))
+            if (typeof message.enableComments !== "boolean")
+                return "enableComments: boolean expected";
+        if (message.clearSubtitles != null && message.hasOwnProperty("clearSubtitles"))
+            if (typeof message.clearSubtitles !== "boolean")
+                return "clearSubtitles: boolean expected";
+        return null;
+    };
+
+    /**
+     * Creates a VideoMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof VideoMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {VideoMetadata} VideoMetadata
+     */
+    VideoMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.VideoMetadata)
+            return object;
+        var message = new $root.VideoMetadata();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.video != null)
+            message.video = object.video >>> 0;
+        if (object.thumbnailPhoto != null)
+            message.thumbnailPhoto = object.thumbnailPhoto >>> 0;
+        if (object.duration != null)
+            message.duration = object.duration >>> 0;
+        if (object.mediaPixelHeight != null)
+            message.mediaPixelHeight = object.mediaPixelHeight >>> 0;
+        if (object.mediaPixelWidth != null)
+            message.mediaPixelWidth = object.mediaPixelWidth >>> 0;
+        if (object.mediaType != null) {
+            if (typeof object.mediaType !== "object")
+                throw TypeError(".VideoMetadata.mediaType: object expected");
+            message.mediaType = $root.MediaType.fromObject(object.mediaType);
+        }
+        if (object.language != null)
+            message.language = String(object.language);
+        if (object.license != null) {
+            if (typeof object.license !== "object")
+                throw TypeError(".VideoMetadata.license: object expected");
+            message.license = $root.License.fromObject(object.license);
+        }
+        if (object.publishedBeforeJoystream != null) {
+            if (typeof object.publishedBeforeJoystream !== "object")
+                throw TypeError(".VideoMetadata.publishedBeforeJoystream: object expected");
+            message.publishedBeforeJoystream = $root.PublishedBeforeJoystream.fromObject(object.publishedBeforeJoystream);
+        }
+        if (object.hasMarketing != null)
+            message.hasMarketing = Boolean(object.hasMarketing);
+        if (object.isPublic != null)
+            message.isPublic = Boolean(object.isPublic);
+        if (object.isExplicit != null)
+            message.isExplicit = Boolean(object.isExplicit);
+        if (object.persons) {
+            if (!Array.isArray(object.persons))
+                throw TypeError(".VideoMetadata.persons: array expected");
+            message.persons = [];
+            for (var i = 0; i < object.persons.length; ++i)
+                if ($util.Long)
+                    (message.persons[i] = $util.Long.fromValue(object.persons[i])).unsigned = true;
+                else if (typeof object.persons[i] === "string")
+                    message.persons[i] = parseInt(object.persons[i], 10);
+                else if (typeof object.persons[i] === "number")
+                    message.persons[i] = object.persons[i];
+                else if (typeof object.persons[i] === "object")
+                    message.persons[i] = new $util.LongBits(object.persons[i].low >>> 0, object.persons[i].high >>> 0).toNumber(true);
+        }
+        if (object.category != null)
+            message.category = String(object.category);
+        if (object.subtitles) {
+            if (!Array.isArray(object.subtitles))
+                throw TypeError(".VideoMetadata.subtitles: array expected");
+            message.subtitles = [];
+            for (var i = 0; i < object.subtitles.length; ++i) {
+                if (typeof object.subtitles[i] !== "object")
+                    throw TypeError(".VideoMetadata.subtitles: object expected");
+                message.subtitles[i] = $root.SubtitleMetadata.fromObject(object.subtitles[i]);
+            }
+        }
+        if (object.enableComments != null)
+            message.enableComments = Boolean(object.enableComments);
+        if (object.clearSubtitles != null)
+            message.clearSubtitles = Boolean(object.clearSubtitles);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a VideoMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof VideoMetadata
+     * @static
+     * @param {VideoMetadata} message VideoMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    VideoMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults) {
+            object.persons = [];
+            object.subtitles = [];
+        }
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            object.video = 0;
+            object.thumbnailPhoto = 0;
+            object.duration = 0;
+            object.mediaPixelHeight = 0;
+            object.mediaPixelWidth = 0;
+            object.mediaType = null;
+            object.language = "";
+            object.license = null;
+            object.publishedBeforeJoystream = null;
+            object.hasMarketing = false;
+            object.isPublic = false;
+            object.isExplicit = false;
+            object.category = "";
+            object.enableComments = false;
+            object.clearSubtitles = false;
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.video != null && message.hasOwnProperty("video"))
+            object.video = message.video;
+        if (message.thumbnailPhoto != null && message.hasOwnProperty("thumbnailPhoto"))
+            object.thumbnailPhoto = message.thumbnailPhoto;
+        if (message.duration != null && message.hasOwnProperty("duration"))
+            object.duration = message.duration;
+        if (message.mediaPixelHeight != null && message.hasOwnProperty("mediaPixelHeight"))
+            object.mediaPixelHeight = message.mediaPixelHeight;
+        if (message.mediaPixelWidth != null && message.hasOwnProperty("mediaPixelWidth"))
+            object.mediaPixelWidth = message.mediaPixelWidth;
+        if (message.mediaType != null && message.hasOwnProperty("mediaType"))
+            object.mediaType = $root.MediaType.toObject(message.mediaType, options);
+        if (message.language != null && message.hasOwnProperty("language"))
+            object.language = message.language;
+        if (message.license != null && message.hasOwnProperty("license"))
+            object.license = $root.License.toObject(message.license, options);
+        if (message.publishedBeforeJoystream != null && message.hasOwnProperty("publishedBeforeJoystream"))
+            object.publishedBeforeJoystream = $root.PublishedBeforeJoystream.toObject(message.publishedBeforeJoystream, options);
+        if (message.hasMarketing != null && message.hasOwnProperty("hasMarketing"))
+            object.hasMarketing = message.hasMarketing;
+        if (message.isPublic != null && message.hasOwnProperty("isPublic"))
+            object.isPublic = message.isPublic;
+        if (message.isExplicit != null && message.hasOwnProperty("isExplicit"))
+            object.isExplicit = message.isExplicit;
+        if (message.persons && message.persons.length) {
+            object.persons = [];
+            for (var j = 0; j < message.persons.length; ++j)
+                if (typeof message.persons[j] === "number")
+                    object.persons[j] = options.longs === String ? String(message.persons[j]) : message.persons[j];
+                else
+                    object.persons[j] = options.longs === String ? $util.Long.prototype.toString.call(message.persons[j]) : options.longs === Number ? new $util.LongBits(message.persons[j].low >>> 0, message.persons[j].high >>> 0).toNumber(true) : message.persons[j];
+        }
+        if (message.category != null && message.hasOwnProperty("category"))
+            object.category = message.category;
+        if (message.subtitles && message.subtitles.length) {
+            object.subtitles = [];
+            for (var j = 0; j < message.subtitles.length; ++j)
+                object.subtitles[j] = $root.SubtitleMetadata.toObject(message.subtitles[j], options);
+        }
+        if (message.enableComments != null && message.hasOwnProperty("enableComments"))
+            object.enableComments = message.enableComments;
+        if (message.clearSubtitles != null && message.hasOwnProperty("clearSubtitles"))
+            object.clearSubtitles = message.clearSubtitles;
+        return object;
+    };
+
+    /**
+     * Converts this VideoMetadata to JSON.
+     * @function toJSON
+     * @memberof VideoMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    VideoMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return VideoMetadata;
+})();
+
+$root.ContentMetadata = (function() {
+
+    /**
+     * Properties of a ContentMetadata.
+     * @exports IContentMetadata
+     * @interface IContentMetadata
+     * @property {IVideoMetadata|null} [videoMetadata] ContentMetadata videoMetadata
+     */
+
+    /**
+     * Constructs a new ContentMetadata.
+     * @exports ContentMetadata
+     * @classdesc Represents a ContentMetadata.
+     * @implements IContentMetadata
+     * @constructor
+     * @param {IContentMetadata=} [properties] Properties to set
+     */
+    function ContentMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ContentMetadata videoMetadata.
+     * @member {IVideoMetadata|null|undefined} videoMetadata
+     * @memberof ContentMetadata
+     * @instance
+     */
+    ContentMetadata.prototype.videoMetadata = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * ContentMetadata contentMetadata.
+     * @member {"videoMetadata"|undefined} contentMetadata
+     * @memberof ContentMetadata
+     * @instance
+     */
+    Object.defineProperty(ContentMetadata.prototype, "contentMetadata", {
+        get: $util.oneOfGetter($oneOfFields = ["videoMetadata"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new ContentMetadata instance using the specified properties.
+     * @function create
+     * @memberof ContentMetadata
+     * @static
+     * @param {IContentMetadata=} [properties] Properties to set
+     * @returns {ContentMetadata} ContentMetadata instance
+     */
+    ContentMetadata.create = function create(properties) {
+        return new ContentMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified ContentMetadata message. Does not implicitly {@link ContentMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof ContentMetadata
+     * @static
+     * @param {IContentMetadata} message ContentMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ContentMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.videoMetadata != null && Object.hasOwnProperty.call(message, "videoMetadata"))
+            $root.VideoMetadata.encode(message.videoMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ContentMetadata message, length delimited. Does not implicitly {@link ContentMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ContentMetadata
+     * @static
+     * @param {IContentMetadata} message ContentMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ContentMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ContentMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof ContentMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ContentMetadata} ContentMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ContentMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContentMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.videoMetadata = $root.VideoMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a ContentMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ContentMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ContentMetadata} ContentMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ContentMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ContentMetadata message.
+     * @function verify
+     * @memberof ContentMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ContentMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.videoMetadata != null && message.hasOwnProperty("videoMetadata")) {
+            properties.contentMetadata = 1;
+            {
+                var error = $root.VideoMetadata.verify(message.videoMetadata);
+                if (error)
+                    return "videoMetadata." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a ContentMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ContentMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ContentMetadata} ContentMetadata
+     */
+    ContentMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.ContentMetadata)
+            return object;
+        var message = new $root.ContentMetadata();
+        if (object.videoMetadata != null) {
+            if (typeof object.videoMetadata !== "object")
+                throw TypeError(".ContentMetadata.videoMetadata: object expected");
+            message.videoMetadata = $root.VideoMetadata.fromObject(object.videoMetadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ContentMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ContentMetadata
+     * @static
+     * @param {ContentMetadata} message ContentMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ContentMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.videoMetadata != null && message.hasOwnProperty("videoMetadata")) {
+            object.videoMetadata = $root.VideoMetadata.toObject(message.videoMetadata, options);
+            if (options.oneofs)
+                object.contentMetadata = "videoMetadata";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this ContentMetadata to JSON.
+     * @function toJSON
+     * @memberof ContentMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ContentMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ContentMetadata;
+})();
+
+$root.OpeningMetadata = (function() {
+
+    /**
+     * Properties of an OpeningMetadata.
+     * @exports IOpeningMetadata
+     * @interface IOpeningMetadata
+     * @property {string|null} [shortDescription] OpeningMetadata shortDescription
+     * @property {string|null} [description] OpeningMetadata description
+     * @property {number|null} [hiringLimit] OpeningMetadata hiringLimit
+     * @property {number|null} [expectedEndingTimestamp] OpeningMetadata expectedEndingTimestamp
+     * @property {string|null} [applicationDetails] OpeningMetadata applicationDetails
+     * @property {Array.<OpeningMetadata.IApplicationFormQuestion>|null} [applicationFormQuestions] OpeningMetadata applicationFormQuestions
+     * @property {string|null} [title] OpeningMetadata title
+     */
+
+    /**
+     * Constructs a new OpeningMetadata.
+     * @exports OpeningMetadata
+     * @classdesc Represents an OpeningMetadata.
+     * @implements IOpeningMetadata
+     * @constructor
+     * @param {IOpeningMetadata=} [properties] Properties to set
+     */
+    function OpeningMetadata(properties) {
+        this.applicationFormQuestions = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * OpeningMetadata shortDescription.
+     * @member {string} shortDescription
+     * @memberof OpeningMetadata
+     * @instance
+     */
+    OpeningMetadata.prototype.shortDescription = "";
+
+    /**
+     * OpeningMetadata description.
+     * @member {string} description
+     * @memberof OpeningMetadata
+     * @instance
+     */
+    OpeningMetadata.prototype.description = "";
+
+    /**
+     * OpeningMetadata hiringLimit.
+     * @member {number} hiringLimit
+     * @memberof OpeningMetadata
+     * @instance
+     */
+    OpeningMetadata.prototype.hiringLimit = 0;
+
+    /**
+     * OpeningMetadata expectedEndingTimestamp.
+     * @member {number} expectedEndingTimestamp
+     * @memberof OpeningMetadata
+     * @instance
+     */
+    OpeningMetadata.prototype.expectedEndingTimestamp = 0;
+
+    /**
+     * OpeningMetadata applicationDetails.
+     * @member {string} applicationDetails
+     * @memberof OpeningMetadata
+     * @instance
+     */
+    OpeningMetadata.prototype.applicationDetails = "";
+
+    /**
+     * OpeningMetadata applicationFormQuestions.
+     * @member {Array.<OpeningMetadata.IApplicationFormQuestion>} applicationFormQuestions
+     * @memberof OpeningMetadata
+     * @instance
+     */
+    OpeningMetadata.prototype.applicationFormQuestions = $util.emptyArray;
+
+    /**
+     * OpeningMetadata title.
+     * @member {string} title
+     * @memberof OpeningMetadata
+     * @instance
+     */
+    OpeningMetadata.prototype.title = "";
+
+    /**
+     * Creates a new OpeningMetadata instance using the specified properties.
+     * @function create
+     * @memberof OpeningMetadata
+     * @static
+     * @param {IOpeningMetadata=} [properties] Properties to set
+     * @returns {OpeningMetadata} OpeningMetadata instance
+     */
+    OpeningMetadata.create = function create(properties) {
+        return new OpeningMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified OpeningMetadata message. Does not implicitly {@link OpeningMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof OpeningMetadata
+     * @static
+     * @param {IOpeningMetadata} message OpeningMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    OpeningMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.shortDescription != null && Object.hasOwnProperty.call(message, "shortDescription"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.shortDescription);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.hiringLimit != null && Object.hasOwnProperty.call(message, "hiringLimit"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.hiringLimit);
+        if (message.expectedEndingTimestamp != null && Object.hasOwnProperty.call(message, "expectedEndingTimestamp"))
+            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expectedEndingTimestamp);
+        if (message.applicationDetails != null && Object.hasOwnProperty.call(message, "applicationDetails"))
+            writer.uint32(/* id 5, wireType 2 =*/42).string(message.applicationDetails);
+        if (message.applicationFormQuestions != null && message.applicationFormQuestions.length)
+            for (var i = 0; i < message.applicationFormQuestions.length; ++i)
+                $root.OpeningMetadata.ApplicationFormQuestion.encode(message.applicationFormQuestions[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 7, wireType 2 =*/58).string(message.title);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified OpeningMetadata message, length delimited. Does not implicitly {@link OpeningMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof OpeningMetadata
+     * @static
+     * @param {IOpeningMetadata} message OpeningMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    OpeningMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an OpeningMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof OpeningMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {OpeningMetadata} OpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    OpeningMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpeningMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.shortDescription = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.hiringLimit = reader.uint32();
+                break;
+            case 4:
+                message.expectedEndingTimestamp = reader.uint32();
+                break;
+            case 5:
+                message.applicationDetails = reader.string();
+                break;
+            case 6:
+                if (!(message.applicationFormQuestions && message.applicationFormQuestions.length))
+                    message.applicationFormQuestions = [];
+                message.applicationFormQuestions.push($root.OpeningMetadata.ApplicationFormQuestion.decode(reader, reader.uint32()));
+                break;
+            case 7:
+                message.title = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes an OpeningMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof OpeningMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {OpeningMetadata} OpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    OpeningMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an OpeningMetadata message.
+     * @function verify
+     * @memberof OpeningMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    OpeningMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
+            if (!$util.isString(message.shortDescription))
+                return "shortDescription: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.hiringLimit != null && message.hasOwnProperty("hiringLimit"))
+            if (!$util.isInteger(message.hiringLimit))
+                return "hiringLimit: integer expected";
+        if (message.expectedEndingTimestamp != null && message.hasOwnProperty("expectedEndingTimestamp"))
+            if (!$util.isInteger(message.expectedEndingTimestamp))
+                return "expectedEndingTimestamp: integer expected";
+        if (message.applicationDetails != null && message.hasOwnProperty("applicationDetails"))
+            if (!$util.isString(message.applicationDetails))
+                return "applicationDetails: string expected";
+        if (message.applicationFormQuestions != null && message.hasOwnProperty("applicationFormQuestions")) {
+            if (!Array.isArray(message.applicationFormQuestions))
+                return "applicationFormQuestions: array expected";
+            for (var i = 0; i < message.applicationFormQuestions.length; ++i) {
+                var error = $root.OpeningMetadata.ApplicationFormQuestion.verify(message.applicationFormQuestions[i]);
+                if (error)
+                    return "applicationFormQuestions." + error;
+            }
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        return null;
+    };
+
+    /**
+     * Creates an OpeningMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof OpeningMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {OpeningMetadata} OpeningMetadata
+     */
+    OpeningMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.OpeningMetadata)
+            return object;
+        var message = new $root.OpeningMetadata();
+        if (object.shortDescription != null)
+            message.shortDescription = String(object.shortDescription);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.hiringLimit != null)
+            message.hiringLimit = object.hiringLimit >>> 0;
+        if (object.expectedEndingTimestamp != null)
+            message.expectedEndingTimestamp = object.expectedEndingTimestamp >>> 0;
+        if (object.applicationDetails != null)
+            message.applicationDetails = String(object.applicationDetails);
+        if (object.applicationFormQuestions) {
+            if (!Array.isArray(object.applicationFormQuestions))
+                throw TypeError(".OpeningMetadata.applicationFormQuestions: array expected");
+            message.applicationFormQuestions = [];
+            for (var i = 0; i < object.applicationFormQuestions.length; ++i) {
+                if (typeof object.applicationFormQuestions[i] !== "object")
+                    throw TypeError(".OpeningMetadata.applicationFormQuestions: object expected");
+                message.applicationFormQuestions[i] = $root.OpeningMetadata.ApplicationFormQuestion.fromObject(object.applicationFormQuestions[i]);
+            }
+        }
+        if (object.title != null)
+            message.title = String(object.title);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an OpeningMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof OpeningMetadata
+     * @static
+     * @param {OpeningMetadata} message OpeningMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    OpeningMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.applicationFormQuestions = [];
+        if (options.defaults) {
+            object.shortDescription = "";
+            object.description = "";
+            object.hiringLimit = 0;
+            object.expectedEndingTimestamp = 0;
+            object.applicationDetails = "";
+            object.title = "";
+        }
+        if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
+            object.shortDescription = message.shortDescription;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.hiringLimit != null && message.hasOwnProperty("hiringLimit"))
+            object.hiringLimit = message.hiringLimit;
+        if (message.expectedEndingTimestamp != null && message.hasOwnProperty("expectedEndingTimestamp"))
+            object.expectedEndingTimestamp = message.expectedEndingTimestamp;
+        if (message.applicationDetails != null && message.hasOwnProperty("applicationDetails"))
+            object.applicationDetails = message.applicationDetails;
+        if (message.applicationFormQuestions && message.applicationFormQuestions.length) {
+            object.applicationFormQuestions = [];
+            for (var j = 0; j < message.applicationFormQuestions.length; ++j)
+                object.applicationFormQuestions[j] = $root.OpeningMetadata.ApplicationFormQuestion.toObject(message.applicationFormQuestions[j], options);
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        return object;
+    };
+
+    /**
+     * Converts this OpeningMetadata to JSON.
+     * @function toJSON
+     * @memberof OpeningMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    OpeningMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    OpeningMetadata.ApplicationFormQuestion = (function() {
+
+        /**
+         * Properties of an ApplicationFormQuestion.
+         * @memberof OpeningMetadata
+         * @interface IApplicationFormQuestion
+         * @property {string|null} [question] ApplicationFormQuestion question
+         * @property {OpeningMetadata.ApplicationFormQuestion.InputType|null} [type] ApplicationFormQuestion type
+         */
+
+        /**
+         * Constructs a new ApplicationFormQuestion.
+         * @memberof OpeningMetadata
+         * @classdesc Represents an ApplicationFormQuestion.
+         * @implements IApplicationFormQuestion
+         * @constructor
+         * @param {OpeningMetadata.IApplicationFormQuestion=} [properties] Properties to set
+         */
+        function ApplicationFormQuestion(properties) {
+            if (properties)
+                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                    if (properties[keys[i]] != null)
+                        this[keys[i]] = properties[keys[i]];
+        }
+
+        /**
+         * ApplicationFormQuestion question.
+         * @member {string} question
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @instance
+         */
+        ApplicationFormQuestion.prototype.question = "";
+
+        /**
+         * ApplicationFormQuestion type.
+         * @member {OpeningMetadata.ApplicationFormQuestion.InputType} type
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @instance
+         */
+        ApplicationFormQuestion.prototype.type = 0;
+
+        /**
+         * Creates a new ApplicationFormQuestion instance using the specified properties.
+         * @function create
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {OpeningMetadata.IApplicationFormQuestion=} [properties] Properties to set
+         * @returns {OpeningMetadata.ApplicationFormQuestion} ApplicationFormQuestion instance
+         */
+        ApplicationFormQuestion.create = function create(properties) {
+            return new ApplicationFormQuestion(properties);
+        };
+
+        /**
+         * Encodes the specified ApplicationFormQuestion message. Does not implicitly {@link OpeningMetadata.ApplicationFormQuestion.verify|verify} messages.
+         * @function encode
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {OpeningMetadata.IApplicationFormQuestion} message ApplicationFormQuestion message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        ApplicationFormQuestion.encode = function encode(message, writer) {
+            if (!writer)
+                writer = $Writer.create();
+            if (message.question != null && Object.hasOwnProperty.call(message, "question"))
+                writer.uint32(/* id 1, wireType 2 =*/10).string(message.question);
+            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
+                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
+            return writer;
+        };
+
+        /**
+         * Encodes the specified ApplicationFormQuestion message, length delimited. Does not implicitly {@link OpeningMetadata.ApplicationFormQuestion.verify|verify} messages.
+         * @function encodeDelimited
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {OpeningMetadata.IApplicationFormQuestion} message ApplicationFormQuestion message or plain object to encode
+         * @param {$protobuf.Writer} [writer] Writer to encode to
+         * @returns {$protobuf.Writer} Writer
+         */
+        ApplicationFormQuestion.encodeDelimited = function encodeDelimited(message, writer) {
+            return this.encode(message, writer).ldelim();
+        };
+
+        /**
+         * Decodes an ApplicationFormQuestion message from the specified reader or buffer.
+         * @function decode
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @param {number} [length] Message length if known beforehand
+         * @returns {OpeningMetadata.ApplicationFormQuestion} ApplicationFormQuestion
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        ApplicationFormQuestion.decode = function decode(reader, length) {
+            if (!(reader instanceof $Reader))
+                reader = $Reader.create(reader);
+            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.OpeningMetadata.ApplicationFormQuestion();
+            while (reader.pos < end) {
+                var tag = reader.uint32();
+                switch (tag >>> 3) {
+                case 1:
+                    message.question = reader.string();
+                    break;
+                case 2:
+                    message.type = reader.int32();
+                    break;
+                default:
+                    reader.skipType(tag & 7);
+                    break;
+                }
+            }
+            return message;
+        };
+
+        /**
+         * Decodes an ApplicationFormQuestion message from the specified reader or buffer, length delimited.
+         * @function decodeDelimited
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+         * @returns {OpeningMetadata.ApplicationFormQuestion} ApplicationFormQuestion
+         * @throws {Error} If the payload is not a reader or valid buffer
+         * @throws {$protobuf.util.ProtocolError} If required fields are missing
+         */
+        ApplicationFormQuestion.decodeDelimited = function decodeDelimited(reader) {
+            if (!(reader instanceof $Reader))
+                reader = new $Reader(reader);
+            return this.decode(reader, reader.uint32());
+        };
+
+        /**
+         * Verifies an ApplicationFormQuestion message.
+         * @function verify
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {Object.<string,*>} message Plain object to verify
+         * @returns {string|null} `null` if valid, otherwise the reason why it is not
+         */
+        ApplicationFormQuestion.verify = function verify(message) {
+            if (typeof message !== "object" || message === null)
+                return "object expected";
+            if (message.question != null && message.hasOwnProperty("question"))
+                if (!$util.isString(message.question))
+                    return "question: string expected";
+            if (message.type != null && message.hasOwnProperty("type"))
+                switch (message.type) {
+                default:
+                    return "type: enum value expected";
+                case 0:
+                case 1:
+                    break;
+                }
+            return null;
+        };
+
+        /**
+         * Creates an ApplicationFormQuestion message from a plain object. Also converts values to their respective internal types.
+         * @function fromObject
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {Object.<string,*>} object Plain object
+         * @returns {OpeningMetadata.ApplicationFormQuestion} ApplicationFormQuestion
+         */
+        ApplicationFormQuestion.fromObject = function fromObject(object) {
+            if (object instanceof $root.OpeningMetadata.ApplicationFormQuestion)
+                return object;
+            var message = new $root.OpeningMetadata.ApplicationFormQuestion();
+            if (object.question != null)
+                message.question = String(object.question);
+            switch (object.type) {
+            case "TEXTAREA":
+            case 0:
+                message.type = 0;
+                break;
+            case "TEXT":
+            case 1:
+                message.type = 1;
+                break;
+            }
+            return message;
+        };
+
+        /**
+         * Creates a plain object from an ApplicationFormQuestion message. Also converts values to other types if specified.
+         * @function toObject
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @static
+         * @param {OpeningMetadata.ApplicationFormQuestion} message ApplicationFormQuestion
+         * @param {$protobuf.IConversionOptions} [options] Conversion options
+         * @returns {Object.<string,*>} Plain object
+         */
+        ApplicationFormQuestion.toObject = function toObject(message, options) {
+            if (!options)
+                options = {};
+            var object = {};
+            if (options.defaults) {
+                object.question = "";
+                object.type = options.enums === String ? "TEXTAREA" : 0;
+            }
+            if (message.question != null && message.hasOwnProperty("question"))
+                object.question = message.question;
+            if (message.type != null && message.hasOwnProperty("type"))
+                object.type = options.enums === String ? $root.OpeningMetadata.ApplicationFormQuestion.InputType[message.type] : message.type;
+            return object;
+        };
+
+        /**
+         * Converts this ApplicationFormQuestion to JSON.
+         * @function toJSON
+         * @memberof OpeningMetadata.ApplicationFormQuestion
+         * @instance
+         * @returns {Object.<string,*>} JSON object
+         */
+        ApplicationFormQuestion.prototype.toJSON = function toJSON() {
+            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+        };
+
+        /**
+         * InputType enum.
+         * @name OpeningMetadata.ApplicationFormQuestion.InputType
+         * @enum {number}
+         * @property {number} TEXTAREA=0 TEXTAREA value
+         * @property {number} TEXT=1 TEXT value
+         */
+        ApplicationFormQuestion.InputType = (function() {
+            var valuesById = {}, values = Object.create(valuesById);
+            values[valuesById[0] = "TEXTAREA"] = 0;
+            values[valuesById[1] = "TEXT"] = 1;
+            return values;
+        })();
+
+        return ApplicationFormQuestion;
+    })();
+
+    return OpeningMetadata;
+})();
+
+$root.UpcomingOpeningMetadata = (function() {
+
+    /**
+     * Properties of an UpcomingOpeningMetadata.
+     * @exports IUpcomingOpeningMetadata
+     * @interface IUpcomingOpeningMetadata
+     * @property {number|null} [expectedStart] UpcomingOpeningMetadata expectedStart
+     * @property {Long|null} [rewardPerBlock] UpcomingOpeningMetadata rewardPerBlock
+     * @property {Long|null} [minApplicationStake] UpcomingOpeningMetadata minApplicationStake
+     * @property {IOpeningMetadata|null} [metadata] UpcomingOpeningMetadata metadata
+     */
+
+    /**
+     * Constructs a new UpcomingOpeningMetadata.
+     * @exports UpcomingOpeningMetadata
+     * @classdesc Represents an UpcomingOpeningMetadata.
+     * @implements IUpcomingOpeningMetadata
+     * @constructor
+     * @param {IUpcomingOpeningMetadata=} [properties] Properties to set
+     */
+    function UpcomingOpeningMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * UpcomingOpeningMetadata expectedStart.
+     * @member {number} expectedStart
+     * @memberof UpcomingOpeningMetadata
+     * @instance
+     */
+    UpcomingOpeningMetadata.prototype.expectedStart = 0;
+
+    /**
+     * UpcomingOpeningMetadata rewardPerBlock.
+     * @member {Long} rewardPerBlock
+     * @memberof UpcomingOpeningMetadata
+     * @instance
+     */
+    UpcomingOpeningMetadata.prototype.rewardPerBlock = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * UpcomingOpeningMetadata minApplicationStake.
+     * @member {Long} minApplicationStake
+     * @memberof UpcomingOpeningMetadata
+     * @instance
+     */
+    UpcomingOpeningMetadata.prototype.minApplicationStake = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * UpcomingOpeningMetadata metadata.
+     * @member {IOpeningMetadata|null|undefined} metadata
+     * @memberof UpcomingOpeningMetadata
+     * @instance
+     */
+    UpcomingOpeningMetadata.prototype.metadata = null;
+
+    /**
+     * Creates a new UpcomingOpeningMetadata instance using the specified properties.
+     * @function create
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {IUpcomingOpeningMetadata=} [properties] Properties to set
+     * @returns {UpcomingOpeningMetadata} UpcomingOpeningMetadata instance
+     */
+    UpcomingOpeningMetadata.create = function create(properties) {
+        return new UpcomingOpeningMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified UpcomingOpeningMetadata message. Does not implicitly {@link UpcomingOpeningMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {IUpcomingOpeningMetadata} message UpcomingOpeningMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    UpcomingOpeningMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.expectedStart != null && Object.hasOwnProperty.call(message, "expectedStart"))
+            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.expectedStart);
+        if (message.rewardPerBlock != null && Object.hasOwnProperty.call(message, "rewardPerBlock"))
+            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.rewardPerBlock);
+        if (message.minApplicationStake != null && Object.hasOwnProperty.call(message, "minApplicationStake"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.minApplicationStake);
+        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
+            $root.OpeningMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified UpcomingOpeningMetadata message, length delimited. Does not implicitly {@link UpcomingOpeningMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {IUpcomingOpeningMetadata} message UpcomingOpeningMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    UpcomingOpeningMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an UpcomingOpeningMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {UpcomingOpeningMetadata} UpcomingOpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    UpcomingOpeningMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpcomingOpeningMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.expectedStart = reader.uint32();
+                break;
+            case 2:
+                message.rewardPerBlock = reader.uint64();
+                break;
+            case 3:
+                message.minApplicationStake = reader.uint64();
+                break;
+            case 4:
+                message.metadata = $root.OpeningMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes an UpcomingOpeningMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {UpcomingOpeningMetadata} UpcomingOpeningMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    UpcomingOpeningMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an UpcomingOpeningMetadata message.
+     * @function verify
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    UpcomingOpeningMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.expectedStart != null && message.hasOwnProperty("expectedStart"))
+            if (!$util.isInteger(message.expectedStart))
+                return "expectedStart: integer expected";
+        if (message.rewardPerBlock != null && message.hasOwnProperty("rewardPerBlock"))
+            if (!$util.isInteger(message.rewardPerBlock) && !(message.rewardPerBlock && $util.isInteger(message.rewardPerBlock.low) && $util.isInteger(message.rewardPerBlock.high)))
+                return "rewardPerBlock: integer|Long expected";
+        if (message.minApplicationStake != null && message.hasOwnProperty("minApplicationStake"))
+            if (!$util.isInteger(message.minApplicationStake) && !(message.minApplicationStake && $util.isInteger(message.minApplicationStake.low) && $util.isInteger(message.minApplicationStake.high)))
+                return "minApplicationStake: integer|Long expected";
+        if (message.metadata != null && message.hasOwnProperty("metadata")) {
+            var error = $root.OpeningMetadata.verify(message.metadata);
+            if (error)
+                return "metadata." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates an UpcomingOpeningMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {UpcomingOpeningMetadata} UpcomingOpeningMetadata
+     */
+    UpcomingOpeningMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.UpcomingOpeningMetadata)
+            return object;
+        var message = new $root.UpcomingOpeningMetadata();
+        if (object.expectedStart != null)
+            message.expectedStart = object.expectedStart >>> 0;
+        if (object.rewardPerBlock != null)
+            if ($util.Long)
+                (message.rewardPerBlock = $util.Long.fromValue(object.rewardPerBlock)).unsigned = true;
+            else if (typeof object.rewardPerBlock === "string")
+                message.rewardPerBlock = parseInt(object.rewardPerBlock, 10);
+            else if (typeof object.rewardPerBlock === "number")
+                message.rewardPerBlock = object.rewardPerBlock;
+            else if (typeof object.rewardPerBlock === "object")
+                message.rewardPerBlock = new $util.LongBits(object.rewardPerBlock.low >>> 0, object.rewardPerBlock.high >>> 0).toNumber(true);
+        if (object.minApplicationStake != null)
+            if ($util.Long)
+                (message.minApplicationStake = $util.Long.fromValue(object.minApplicationStake)).unsigned = true;
+            else if (typeof object.minApplicationStake === "string")
+                message.minApplicationStake = parseInt(object.minApplicationStake, 10);
+            else if (typeof object.minApplicationStake === "number")
+                message.minApplicationStake = object.minApplicationStake;
+            else if (typeof object.minApplicationStake === "object")
+                message.minApplicationStake = new $util.LongBits(object.minApplicationStake.low >>> 0, object.minApplicationStake.high >>> 0).toNumber(true);
+        if (object.metadata != null) {
+            if (typeof object.metadata !== "object")
+                throw TypeError(".UpcomingOpeningMetadata.metadata: object expected");
+            message.metadata = $root.OpeningMetadata.fromObject(object.metadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an UpcomingOpeningMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof UpcomingOpeningMetadata
+     * @static
+     * @param {UpcomingOpeningMetadata} message UpcomingOpeningMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    UpcomingOpeningMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.expectedStart = 0;
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.rewardPerBlock = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.rewardPerBlock = options.longs === String ? "0" : 0;
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.minApplicationStake = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.minApplicationStake = options.longs === String ? "0" : 0;
+            object.metadata = null;
+        }
+        if (message.expectedStart != null && message.hasOwnProperty("expectedStart"))
+            object.expectedStart = message.expectedStart;
+        if (message.rewardPerBlock != null && message.hasOwnProperty("rewardPerBlock"))
+            if (typeof message.rewardPerBlock === "number")
+                object.rewardPerBlock = options.longs === String ? String(message.rewardPerBlock) : message.rewardPerBlock;
+            else
+                object.rewardPerBlock = options.longs === String ? $util.Long.prototype.toString.call(message.rewardPerBlock) : options.longs === Number ? new $util.LongBits(message.rewardPerBlock.low >>> 0, message.rewardPerBlock.high >>> 0).toNumber(true) : message.rewardPerBlock;
+        if (message.minApplicationStake != null && message.hasOwnProperty("minApplicationStake"))
+            if (typeof message.minApplicationStake === "number")
+                object.minApplicationStake = options.longs === String ? String(message.minApplicationStake) : message.minApplicationStake;
+            else
+                object.minApplicationStake = options.longs === String ? $util.Long.prototype.toString.call(message.minApplicationStake) : options.longs === Number ? new $util.LongBits(message.minApplicationStake.low >>> 0, message.minApplicationStake.high >>> 0).toNumber(true) : message.minApplicationStake;
+        if (message.metadata != null && message.hasOwnProperty("metadata"))
+            object.metadata = $root.OpeningMetadata.toObject(message.metadata, options);
+        return object;
+    };
+
+    /**
+     * Converts this UpcomingOpeningMetadata to JSON.
+     * @function toJSON
+     * @memberof UpcomingOpeningMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    UpcomingOpeningMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return UpcomingOpeningMetadata;
+})();
+
+$root.ApplicationMetadata = (function() {
+
+    /**
+     * Properties of an ApplicationMetadata.
+     * @exports IApplicationMetadata
+     * @interface IApplicationMetadata
+     * @property {Array.<string>|null} [answers] ApplicationMetadata answers
+     */
+
+    /**
+     * Constructs a new ApplicationMetadata.
+     * @exports ApplicationMetadata
+     * @classdesc Represents an ApplicationMetadata.
+     * @implements IApplicationMetadata
+     * @constructor
+     * @param {IApplicationMetadata=} [properties] Properties to set
+     */
+    function ApplicationMetadata(properties) {
+        this.answers = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ApplicationMetadata answers.
+     * @member {Array.<string>} answers
+     * @memberof ApplicationMetadata
+     * @instance
+     */
+    ApplicationMetadata.prototype.answers = $util.emptyArray;
+
+    /**
+     * Creates a new ApplicationMetadata instance using the specified properties.
+     * @function create
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {IApplicationMetadata=} [properties] Properties to set
+     * @returns {ApplicationMetadata} ApplicationMetadata instance
+     */
+    ApplicationMetadata.create = function create(properties) {
+        return new ApplicationMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified ApplicationMetadata message. Does not implicitly {@link ApplicationMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {IApplicationMetadata} message ApplicationMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ApplicationMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.answers != null && message.answers.length)
+            for (var i = 0; i < message.answers.length; ++i)
+                writer.uint32(/* id 1, wireType 2 =*/10).string(message.answers[i]);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ApplicationMetadata message, length delimited. Does not implicitly {@link ApplicationMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {IApplicationMetadata} message ApplicationMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ApplicationMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an ApplicationMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ApplicationMetadata} ApplicationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ApplicationMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ApplicationMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                if (!(message.answers && message.answers.length))
+                    message.answers = [];
+                message.answers.push(reader.string());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes an ApplicationMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ApplicationMetadata} ApplicationMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ApplicationMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an ApplicationMetadata message.
+     * @function verify
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ApplicationMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.answers != null && message.hasOwnProperty("answers")) {
+            if (!Array.isArray(message.answers))
+                return "answers: array expected";
+            for (var i = 0; i < message.answers.length; ++i)
+                if (!$util.isString(message.answers[i]))
+                    return "answers: string[] expected";
+        }
+        return null;
+    };
+
+    /**
+     * Creates an ApplicationMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ApplicationMetadata} ApplicationMetadata
+     */
+    ApplicationMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.ApplicationMetadata)
+            return object;
+        var message = new $root.ApplicationMetadata();
+        if (object.answers) {
+            if (!Array.isArray(object.answers))
+                throw TypeError(".ApplicationMetadata.answers: array expected");
+            message.answers = [];
+            for (var i = 0; i < object.answers.length; ++i)
+                message.answers[i] = String(object.answers[i]);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an ApplicationMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ApplicationMetadata
+     * @static
+     * @param {ApplicationMetadata} message ApplicationMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ApplicationMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.answers = [];
+        if (message.answers && message.answers.length) {
+            object.answers = [];
+            for (var j = 0; j < message.answers.length; ++j)
+                object.answers[j] = message.answers[j];
+        }
+        return object;
+    };
+
+    /**
+     * Converts this ApplicationMetadata to JSON.
+     * @function toJSON
+     * @memberof ApplicationMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ApplicationMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ApplicationMetadata;
+})();
+
+$root.WorkingGroupMetadata = (function() {
+
+    /**
+     * Properties of a WorkingGroupMetadata.
+     * @exports IWorkingGroupMetadata
+     * @interface IWorkingGroupMetadata
+     * @property {string|null} [description] WorkingGroupMetadata description
+     * @property {string|null} [about] WorkingGroupMetadata about
+     * @property {string|null} [status] WorkingGroupMetadata status
+     * @property {string|null} [statusMessage] WorkingGroupMetadata statusMessage
+     */
+
+    /**
+     * Constructs a new WorkingGroupMetadata.
+     * @exports WorkingGroupMetadata
+     * @classdesc Represents a WorkingGroupMetadata.
+     * @implements IWorkingGroupMetadata
+     * @constructor
+     * @param {IWorkingGroupMetadata=} [properties] Properties to set
+     */
+    function WorkingGroupMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * WorkingGroupMetadata description.
+     * @member {string} description
+     * @memberof WorkingGroupMetadata
+     * @instance
+     */
+    WorkingGroupMetadata.prototype.description = "";
+
+    /**
+     * WorkingGroupMetadata about.
+     * @member {string} about
+     * @memberof WorkingGroupMetadata
+     * @instance
+     */
+    WorkingGroupMetadata.prototype.about = "";
+
+    /**
+     * WorkingGroupMetadata status.
+     * @member {string} status
+     * @memberof WorkingGroupMetadata
+     * @instance
+     */
+    WorkingGroupMetadata.prototype.status = "";
+
+    /**
+     * WorkingGroupMetadata statusMessage.
+     * @member {string} statusMessage
+     * @memberof WorkingGroupMetadata
+     * @instance
+     */
+    WorkingGroupMetadata.prototype.statusMessage = "";
+
+    /**
+     * Creates a new WorkingGroupMetadata instance using the specified properties.
+     * @function create
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {IWorkingGroupMetadata=} [properties] Properties to set
+     * @returns {WorkingGroupMetadata} WorkingGroupMetadata instance
+     */
+    WorkingGroupMetadata.create = function create(properties) {
+        return new WorkingGroupMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified WorkingGroupMetadata message. Does not implicitly {@link WorkingGroupMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {IWorkingGroupMetadata} message WorkingGroupMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    WorkingGroupMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
+        if (message.about != null && Object.hasOwnProperty.call(message, "about"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.about);
+        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.status);
+        if (message.statusMessage != null && Object.hasOwnProperty.call(message, "statusMessage"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.statusMessage);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified WorkingGroupMetadata message, length delimited. Does not implicitly {@link WorkingGroupMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {IWorkingGroupMetadata} message WorkingGroupMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    WorkingGroupMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a WorkingGroupMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {WorkingGroupMetadata} WorkingGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    WorkingGroupMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WorkingGroupMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.description = reader.string();
+                break;
+            case 2:
+                message.about = reader.string();
+                break;
+            case 3:
+                message.status = reader.string();
+                break;
+            case 4:
+                message.statusMessage = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a WorkingGroupMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {WorkingGroupMetadata} WorkingGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    WorkingGroupMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a WorkingGroupMetadata message.
+     * @function verify
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    WorkingGroupMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.about != null && message.hasOwnProperty("about"))
+            if (!$util.isString(message.about))
+                return "about: string expected";
+        if (message.status != null && message.hasOwnProperty("status"))
+            if (!$util.isString(message.status))
+                return "status: string expected";
+        if (message.statusMessage != null && message.hasOwnProperty("statusMessage"))
+            if (!$util.isString(message.statusMessage))
+                return "statusMessage: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a WorkingGroupMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {WorkingGroupMetadata} WorkingGroupMetadata
+     */
+    WorkingGroupMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.WorkingGroupMetadata)
+            return object;
+        var message = new $root.WorkingGroupMetadata();
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.about != null)
+            message.about = String(object.about);
+        if (object.status != null)
+            message.status = String(object.status);
+        if (object.statusMessage != null)
+            message.statusMessage = String(object.statusMessage);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a WorkingGroupMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof WorkingGroupMetadata
+     * @static
+     * @param {WorkingGroupMetadata} message WorkingGroupMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    WorkingGroupMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.description = "";
+            object.about = "";
+            object.status = "";
+            object.statusMessage = "";
+        }
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.about != null && message.hasOwnProperty("about"))
+            object.about = message.about;
+        if (message.status != null && message.hasOwnProperty("status"))
+            object.status = message.status;
+        if (message.statusMessage != null && message.hasOwnProperty("statusMessage"))
+            object.statusMessage = message.statusMessage;
+        return object;
+    };
+
+    /**
+     * Converts this WorkingGroupMetadata to JSON.
+     * @function toJSON
+     * @memberof WorkingGroupMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    WorkingGroupMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return WorkingGroupMetadata;
+})();
+
+$root.SetGroupMetadata = (function() {
+
+    /**
+     * Properties of a SetGroupMetadata.
+     * @exports ISetGroupMetadata
+     * @interface ISetGroupMetadata
+     * @property {IWorkingGroupMetadata|null} [newMetadata] SetGroupMetadata newMetadata
+     */
+
+    /**
+     * Constructs a new SetGroupMetadata.
+     * @exports SetGroupMetadata
+     * @classdesc Represents a SetGroupMetadata.
+     * @implements ISetGroupMetadata
+     * @constructor
+     * @param {ISetGroupMetadata=} [properties] Properties to set
+     */
+    function SetGroupMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * SetGroupMetadata newMetadata.
+     * @member {IWorkingGroupMetadata|null|undefined} newMetadata
+     * @memberof SetGroupMetadata
+     * @instance
+     */
+    SetGroupMetadata.prototype.newMetadata = null;
+
+    /**
+     * Creates a new SetGroupMetadata instance using the specified properties.
+     * @function create
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {ISetGroupMetadata=} [properties] Properties to set
+     * @returns {SetGroupMetadata} SetGroupMetadata instance
+     */
+    SetGroupMetadata.create = function create(properties) {
+        return new SetGroupMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified SetGroupMetadata message. Does not implicitly {@link SetGroupMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {ISetGroupMetadata} message SetGroupMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SetGroupMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.newMetadata != null && Object.hasOwnProperty.call(message, "newMetadata"))
+            $root.WorkingGroupMetadata.encode(message.newMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified SetGroupMetadata message, length delimited. Does not implicitly {@link SetGroupMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {ISetGroupMetadata} message SetGroupMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SetGroupMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a SetGroupMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {SetGroupMetadata} SetGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SetGroupMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SetGroupMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.newMetadata = $root.WorkingGroupMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a SetGroupMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {SetGroupMetadata} SetGroupMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SetGroupMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a SetGroupMetadata message.
+     * @function verify
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    SetGroupMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.newMetadata != null && message.hasOwnProperty("newMetadata")) {
+            var error = $root.WorkingGroupMetadata.verify(message.newMetadata);
+            if (error)
+                return "newMetadata." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates a SetGroupMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {SetGroupMetadata} SetGroupMetadata
+     */
+    SetGroupMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.SetGroupMetadata)
+            return object;
+        var message = new $root.SetGroupMetadata();
+        if (object.newMetadata != null) {
+            if (typeof object.newMetadata !== "object")
+                throw TypeError(".SetGroupMetadata.newMetadata: object expected");
+            message.newMetadata = $root.WorkingGroupMetadata.fromObject(object.newMetadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a SetGroupMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof SetGroupMetadata
+     * @static
+     * @param {SetGroupMetadata} message SetGroupMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    SetGroupMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.newMetadata = null;
+        if (message.newMetadata != null && message.hasOwnProperty("newMetadata"))
+            object.newMetadata = $root.WorkingGroupMetadata.toObject(message.newMetadata, options);
+        return object;
+    };
+
+    /**
+     * Converts this SetGroupMetadata to JSON.
+     * @function toJSON
+     * @memberof SetGroupMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    SetGroupMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return SetGroupMetadata;
+})();
+
+$root.AddUpcomingOpening = (function() {
+
+    /**
+     * Properties of an AddUpcomingOpening.
+     * @exports IAddUpcomingOpening
+     * @interface IAddUpcomingOpening
+     * @property {IUpcomingOpeningMetadata|null} [metadata] AddUpcomingOpening metadata
+     */
+
+    /**
+     * Constructs a new AddUpcomingOpening.
+     * @exports AddUpcomingOpening
+     * @classdesc Represents an AddUpcomingOpening.
+     * @implements IAddUpcomingOpening
+     * @constructor
+     * @param {IAddUpcomingOpening=} [properties] Properties to set
+     */
+    function AddUpcomingOpening(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * AddUpcomingOpening metadata.
+     * @member {IUpcomingOpeningMetadata|null|undefined} metadata
+     * @memberof AddUpcomingOpening
+     * @instance
+     */
+    AddUpcomingOpening.prototype.metadata = null;
+
+    /**
+     * Creates a new AddUpcomingOpening instance using the specified properties.
+     * @function create
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {IAddUpcomingOpening=} [properties] Properties to set
+     * @returns {AddUpcomingOpening} AddUpcomingOpening instance
+     */
+    AddUpcomingOpening.create = function create(properties) {
+        return new AddUpcomingOpening(properties);
+    };
+
+    /**
+     * Encodes the specified AddUpcomingOpening message. Does not implicitly {@link AddUpcomingOpening.verify|verify} messages.
+     * @function encode
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {IAddUpcomingOpening} message AddUpcomingOpening message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AddUpcomingOpening.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
+            $root.UpcomingOpeningMetadata.encode(message.metadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified AddUpcomingOpening message, length delimited. Does not implicitly {@link AddUpcomingOpening.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {IAddUpcomingOpening} message AddUpcomingOpening message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    AddUpcomingOpening.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an AddUpcomingOpening message from the specified reader or buffer.
+     * @function decode
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {AddUpcomingOpening} AddUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AddUpcomingOpening.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AddUpcomingOpening();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.metadata = $root.UpcomingOpeningMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes an AddUpcomingOpening message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {AddUpcomingOpening} AddUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    AddUpcomingOpening.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an AddUpcomingOpening message.
+     * @function verify
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    AddUpcomingOpening.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.metadata != null && message.hasOwnProperty("metadata")) {
+            var error = $root.UpcomingOpeningMetadata.verify(message.metadata);
+            if (error)
+                return "metadata." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates an AddUpcomingOpening message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {AddUpcomingOpening} AddUpcomingOpening
+     */
+    AddUpcomingOpening.fromObject = function fromObject(object) {
+        if (object instanceof $root.AddUpcomingOpening)
+            return object;
+        var message = new $root.AddUpcomingOpening();
+        if (object.metadata != null) {
+            if (typeof object.metadata !== "object")
+                throw TypeError(".AddUpcomingOpening.metadata: object expected");
+            message.metadata = $root.UpcomingOpeningMetadata.fromObject(object.metadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an AddUpcomingOpening message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof AddUpcomingOpening
+     * @static
+     * @param {AddUpcomingOpening} message AddUpcomingOpening
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    AddUpcomingOpening.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.metadata = null;
+        if (message.metadata != null && message.hasOwnProperty("metadata"))
+            object.metadata = $root.UpcomingOpeningMetadata.toObject(message.metadata, options);
+        return object;
+    };
+
+    /**
+     * Converts this AddUpcomingOpening to JSON.
+     * @function toJSON
+     * @memberof AddUpcomingOpening
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    AddUpcomingOpening.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return AddUpcomingOpening;
+})();
+
+$root.RemoveUpcomingOpening = (function() {
+
+    /**
+     * Properties of a RemoveUpcomingOpening.
+     * @exports IRemoveUpcomingOpening
+     * @interface IRemoveUpcomingOpening
+     * @property {string|null} [id] RemoveUpcomingOpening id
+     */
+
+    /**
+     * Constructs a new RemoveUpcomingOpening.
+     * @exports RemoveUpcomingOpening
+     * @classdesc Represents a RemoveUpcomingOpening.
+     * @implements IRemoveUpcomingOpening
+     * @constructor
+     * @param {IRemoveUpcomingOpening=} [properties] Properties to set
+     */
+    function RemoveUpcomingOpening(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * RemoveUpcomingOpening id.
+     * @member {string} id
+     * @memberof RemoveUpcomingOpening
+     * @instance
+     */
+    RemoveUpcomingOpening.prototype.id = "";
+
+    /**
+     * Creates a new RemoveUpcomingOpening instance using the specified properties.
+     * @function create
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {IRemoveUpcomingOpening=} [properties] Properties to set
+     * @returns {RemoveUpcomingOpening} RemoveUpcomingOpening instance
+     */
+    RemoveUpcomingOpening.create = function create(properties) {
+        return new RemoveUpcomingOpening(properties);
+    };
+
+    /**
+     * Encodes the specified RemoveUpcomingOpening message. Does not implicitly {@link RemoveUpcomingOpening.verify|verify} messages.
+     * @function encode
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {IRemoveUpcomingOpening} message RemoveUpcomingOpening message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    RemoveUpcomingOpening.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified RemoveUpcomingOpening message, length delimited. Does not implicitly {@link RemoveUpcomingOpening.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {IRemoveUpcomingOpening} message RemoveUpcomingOpening message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    RemoveUpcomingOpening.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a RemoveUpcomingOpening message from the specified reader or buffer.
+     * @function decode
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {RemoveUpcomingOpening} RemoveUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    RemoveUpcomingOpening.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemoveUpcomingOpening();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.id = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a RemoveUpcomingOpening message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {RemoveUpcomingOpening} RemoveUpcomingOpening
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    RemoveUpcomingOpening.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a RemoveUpcomingOpening message.
+     * @function verify
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    RemoveUpcomingOpening.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.id != null && message.hasOwnProperty("id"))
+            if (!$util.isString(message.id))
+                return "id: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a RemoveUpcomingOpening message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {RemoveUpcomingOpening} RemoveUpcomingOpening
+     */
+    RemoveUpcomingOpening.fromObject = function fromObject(object) {
+        if (object instanceof $root.RemoveUpcomingOpening)
+            return object;
+        var message = new $root.RemoveUpcomingOpening();
+        if (object.id != null)
+            message.id = String(object.id);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a RemoveUpcomingOpening message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof RemoveUpcomingOpening
+     * @static
+     * @param {RemoveUpcomingOpening} message RemoveUpcomingOpening
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    RemoveUpcomingOpening.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.id = "";
+        if (message.id != null && message.hasOwnProperty("id"))
+            object.id = message.id;
+        return object;
+    };
+
+    /**
+     * Converts this RemoveUpcomingOpening to JSON.
+     * @function toJSON
+     * @memberof RemoveUpcomingOpening
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    RemoveUpcomingOpening.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return RemoveUpcomingOpening;
+})();
+
+$root.WorkingGroupMetadataAction = (function() {
+
+    /**
+     * Properties of a WorkingGroupMetadataAction.
+     * @exports IWorkingGroupMetadataAction
+     * @interface IWorkingGroupMetadataAction
+     * @property {ISetGroupMetadata|null} [setGroupMetadata] WorkingGroupMetadataAction setGroupMetadata
+     * @property {IAddUpcomingOpening|null} [addUpcomingOpening] WorkingGroupMetadataAction addUpcomingOpening
+     * @property {IRemoveUpcomingOpening|null} [removeUpcomingOpening] WorkingGroupMetadataAction removeUpcomingOpening
+     */
+
+    /**
+     * Constructs a new WorkingGroupMetadataAction.
+     * @exports WorkingGroupMetadataAction
+     * @classdesc Represents a WorkingGroupMetadataAction.
+     * @implements IWorkingGroupMetadataAction
+     * @constructor
+     * @param {IWorkingGroupMetadataAction=} [properties] Properties to set
+     */
+    function WorkingGroupMetadataAction(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * WorkingGroupMetadataAction setGroupMetadata.
+     * @member {ISetGroupMetadata|null|undefined} setGroupMetadata
+     * @memberof WorkingGroupMetadataAction
+     * @instance
+     */
+    WorkingGroupMetadataAction.prototype.setGroupMetadata = null;
+
+    /**
+     * WorkingGroupMetadataAction addUpcomingOpening.
+     * @member {IAddUpcomingOpening|null|undefined} addUpcomingOpening
+     * @memberof WorkingGroupMetadataAction
+     * @instance
+     */
+    WorkingGroupMetadataAction.prototype.addUpcomingOpening = null;
+
+    /**
+     * WorkingGroupMetadataAction removeUpcomingOpening.
+     * @member {IRemoveUpcomingOpening|null|undefined} removeUpcomingOpening
+     * @memberof WorkingGroupMetadataAction
+     * @instance
+     */
+    WorkingGroupMetadataAction.prototype.removeUpcomingOpening = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * WorkingGroupMetadataAction action.
+     * @member {"setGroupMetadata"|"addUpcomingOpening"|"removeUpcomingOpening"|undefined} action
+     * @memberof WorkingGroupMetadataAction
+     * @instance
+     */
+    Object.defineProperty(WorkingGroupMetadataAction.prototype, "action", {
+        get: $util.oneOfGetter($oneOfFields = ["setGroupMetadata", "addUpcomingOpening", "removeUpcomingOpening"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new WorkingGroupMetadataAction instance using the specified properties.
+     * @function create
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {IWorkingGroupMetadataAction=} [properties] Properties to set
+     * @returns {WorkingGroupMetadataAction} WorkingGroupMetadataAction instance
+     */
+    WorkingGroupMetadataAction.create = function create(properties) {
+        return new WorkingGroupMetadataAction(properties);
+    };
+
+    /**
+     * Encodes the specified WorkingGroupMetadataAction message. Does not implicitly {@link WorkingGroupMetadataAction.verify|verify} messages.
+     * @function encode
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {IWorkingGroupMetadataAction} message WorkingGroupMetadataAction message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    WorkingGroupMetadataAction.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.setGroupMetadata != null && Object.hasOwnProperty.call(message, "setGroupMetadata"))
+            $root.SetGroupMetadata.encode(message.setGroupMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        if (message.addUpcomingOpening != null && Object.hasOwnProperty.call(message, "addUpcomingOpening"))
+            $root.AddUpcomingOpening.encode(message.addUpcomingOpening, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
+        if (message.removeUpcomingOpening != null && Object.hasOwnProperty.call(message, "removeUpcomingOpening"))
+            $root.RemoveUpcomingOpening.encode(message.removeUpcomingOpening, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified WorkingGroupMetadataAction message, length delimited. Does not implicitly {@link WorkingGroupMetadataAction.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {IWorkingGroupMetadataAction} message WorkingGroupMetadataAction message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    WorkingGroupMetadataAction.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a WorkingGroupMetadataAction message from the specified reader or buffer.
+     * @function decode
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {WorkingGroupMetadataAction} WorkingGroupMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    WorkingGroupMetadataAction.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.WorkingGroupMetadataAction();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.setGroupMetadata = $root.SetGroupMetadata.decode(reader, reader.uint32());
+                break;
+            case 2:
+                message.addUpcomingOpening = $root.AddUpcomingOpening.decode(reader, reader.uint32());
+                break;
+            case 3:
+                message.removeUpcomingOpening = $root.RemoveUpcomingOpening.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a WorkingGroupMetadataAction message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {WorkingGroupMetadataAction} WorkingGroupMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    WorkingGroupMetadataAction.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a WorkingGroupMetadataAction message.
+     * @function verify
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    WorkingGroupMetadataAction.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.setGroupMetadata != null && message.hasOwnProperty("setGroupMetadata")) {
+            properties.action = 1;
+            {
+                var error = $root.SetGroupMetadata.verify(message.setGroupMetadata);
+                if (error)
+                    return "setGroupMetadata." + error;
+            }
+        }
+        if (message.addUpcomingOpening != null && message.hasOwnProperty("addUpcomingOpening")) {
+            if (properties.action === 1)
+                return "action: multiple values";
+            properties.action = 1;
+            {
+                var error = $root.AddUpcomingOpening.verify(message.addUpcomingOpening);
+                if (error)
+                    return "addUpcomingOpening." + error;
+            }
+        }
+        if (message.removeUpcomingOpening != null && message.hasOwnProperty("removeUpcomingOpening")) {
+            if (properties.action === 1)
+                return "action: multiple values";
+            properties.action = 1;
+            {
+                var error = $root.RemoveUpcomingOpening.verify(message.removeUpcomingOpening);
+                if (error)
+                    return "removeUpcomingOpening." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a WorkingGroupMetadataAction message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {WorkingGroupMetadataAction} WorkingGroupMetadataAction
+     */
+    WorkingGroupMetadataAction.fromObject = function fromObject(object) {
+        if (object instanceof $root.WorkingGroupMetadataAction)
+            return object;
+        var message = new $root.WorkingGroupMetadataAction();
+        if (object.setGroupMetadata != null) {
+            if (typeof object.setGroupMetadata !== "object")
+                throw TypeError(".WorkingGroupMetadataAction.setGroupMetadata: object expected");
+            message.setGroupMetadata = $root.SetGroupMetadata.fromObject(object.setGroupMetadata);
+        }
+        if (object.addUpcomingOpening != null) {
+            if (typeof object.addUpcomingOpening !== "object")
+                throw TypeError(".WorkingGroupMetadataAction.addUpcomingOpening: object expected");
+            message.addUpcomingOpening = $root.AddUpcomingOpening.fromObject(object.addUpcomingOpening);
+        }
+        if (object.removeUpcomingOpening != null) {
+            if (typeof object.removeUpcomingOpening !== "object")
+                throw TypeError(".WorkingGroupMetadataAction.removeUpcomingOpening: object expected");
+            message.removeUpcomingOpening = $root.RemoveUpcomingOpening.fromObject(object.removeUpcomingOpening);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a WorkingGroupMetadataAction message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof WorkingGroupMetadataAction
+     * @static
+     * @param {WorkingGroupMetadataAction} message WorkingGroupMetadataAction
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    WorkingGroupMetadataAction.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.setGroupMetadata != null && message.hasOwnProperty("setGroupMetadata")) {
+            object.setGroupMetadata = $root.SetGroupMetadata.toObject(message.setGroupMetadata, options);
+            if (options.oneofs)
+                object.action = "setGroupMetadata";
+        }
+        if (message.addUpcomingOpening != null && message.hasOwnProperty("addUpcomingOpening")) {
+            object.addUpcomingOpening = $root.AddUpcomingOpening.toObject(message.addUpcomingOpening, options);
+            if (options.oneofs)
+                object.action = "addUpcomingOpening";
+        }
+        if (message.removeUpcomingOpening != null && message.hasOwnProperty("removeUpcomingOpening")) {
+            object.removeUpcomingOpening = $root.RemoveUpcomingOpening.toObject(message.removeUpcomingOpening, options);
+            if (options.oneofs)
+                object.action = "removeUpcomingOpening";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this WorkingGroupMetadataAction to JSON.
+     * @function toJSON
+     * @memberof WorkingGroupMetadataAction
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    WorkingGroupMetadataAction.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return WorkingGroupMetadataAction;
+})();
+
+$root.ModeratePost = (function() {
+
+    /**
+     * Properties of a ModeratePost.
+     * @exports IModeratePost
+     * @interface IModeratePost
+     * @property {Long} postId ModeratePost postId
+     * @property {string} rationale ModeratePost rationale
+     */
+
+    /**
+     * Constructs a new ModeratePost.
+     * @exports ModeratePost
+     * @classdesc Represents a ModeratePost.
+     * @implements IModeratePost
+     * @constructor
+     * @param {IModeratePost=} [properties] Properties to set
+     */
+    function ModeratePost(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * ModeratePost postId.
+     * @member {Long} postId
+     * @memberof ModeratePost
+     * @instance
+     */
+    ModeratePost.prototype.postId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    /**
+     * ModeratePost rationale.
+     * @member {string} rationale
+     * @memberof ModeratePost
+     * @instance
+     */
+    ModeratePost.prototype.rationale = "";
+
+    /**
+     * Creates a new ModeratePost instance using the specified properties.
+     * @function create
+     * @memberof ModeratePost
+     * @static
+     * @param {IModeratePost=} [properties] Properties to set
+     * @returns {ModeratePost} ModeratePost instance
+     */
+    ModeratePost.create = function create(properties) {
+        return new ModeratePost(properties);
+    };
+
+    /**
+     * Encodes the specified ModeratePost message. Does not implicitly {@link ModeratePost.verify|verify} messages.
+     * @function encode
+     * @memberof ModeratePost
+     * @static
+     * @param {IModeratePost} message ModeratePost message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ModeratePost.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.postId);
+        writer.uint32(/* id 2, wireType 2 =*/18).string(message.rationale);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified ModeratePost message, length delimited. Does not implicitly {@link ModeratePost.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof ModeratePost
+     * @static
+     * @param {IModeratePost} message ModeratePost message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    ModeratePost.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a ModeratePost message from the specified reader or buffer.
+     * @function decode
+     * @memberof ModeratePost
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {ModeratePost} ModeratePost
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ModeratePost.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ModeratePost();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.postId = reader.uint64();
+                break;
+            case 2:
+                message.rationale = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        if (!message.hasOwnProperty("postId"))
+            throw $util.ProtocolError("missing required 'postId'", { instance: message });
+        if (!message.hasOwnProperty("rationale"))
+            throw $util.ProtocolError("missing required 'rationale'", { instance: message });
+        return message;
+    };
+
+    /**
+     * Decodes a ModeratePost message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof ModeratePost
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {ModeratePost} ModeratePost
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    ModeratePost.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a ModeratePost message.
+     * @function verify
+     * @memberof ModeratePost
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    ModeratePost.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (!$util.isInteger(message.postId) && !(message.postId && $util.isInteger(message.postId.low) && $util.isInteger(message.postId.high)))
+            return "postId: integer|Long expected";
+        if (!$util.isString(message.rationale))
+            return "rationale: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a ModeratePost message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof ModeratePost
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {ModeratePost} ModeratePost
+     */
+    ModeratePost.fromObject = function fromObject(object) {
+        if (object instanceof $root.ModeratePost)
+            return object;
+        var message = new $root.ModeratePost();
+        if (object.postId != null)
+            if ($util.Long)
+                (message.postId = $util.Long.fromValue(object.postId)).unsigned = true;
+            else if (typeof object.postId === "string")
+                message.postId = parseInt(object.postId, 10);
+            else if (typeof object.postId === "number")
+                message.postId = object.postId;
+            else if (typeof object.postId === "object")
+                message.postId = new $util.LongBits(object.postId.low >>> 0, object.postId.high >>> 0).toNumber(true);
+        if (object.rationale != null)
+            message.rationale = String(object.rationale);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a ModeratePost message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof ModeratePost
+     * @static
+     * @param {ModeratePost} message ModeratePost
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    ModeratePost.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.postId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.postId = options.longs === String ? "0" : 0;
+            object.rationale = "";
+        }
+        if (message.postId != null && message.hasOwnProperty("postId"))
+            if (typeof message.postId === "number")
+                object.postId = options.longs === String ? String(message.postId) : message.postId;
+            else
+                object.postId = options.longs === String ? $util.Long.prototype.toString.call(message.postId) : options.longs === Number ? new $util.LongBits(message.postId.low >>> 0, message.postId.high >>> 0).toNumber(true) : message.postId;
+        if (message.rationale != null && message.hasOwnProperty("rationale"))
+            object.rationale = message.rationale;
+        return object;
+    };
+
+    /**
+     * Converts this ModeratePost to JSON.
+     * @function toJSON
+     * @memberof ModeratePost
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    ModeratePost.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return ModeratePost;
+})();
+
+$root.RemarkMetadataAction = (function() {
+
+    /**
+     * Properties of a RemarkMetadataAction.
+     * @exports IRemarkMetadataAction
+     * @interface IRemarkMetadataAction
+     * @property {IModeratePost|null} [moderatePost] RemarkMetadataAction moderatePost
+     */
+
+    /**
+     * Constructs a new RemarkMetadataAction.
+     * @exports RemarkMetadataAction
+     * @classdesc Represents a RemarkMetadataAction.
+     * @implements IRemarkMetadataAction
+     * @constructor
+     * @param {IRemarkMetadataAction=} [properties] Properties to set
+     */
+    function RemarkMetadataAction(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * RemarkMetadataAction moderatePost.
+     * @member {IModeratePost|null|undefined} moderatePost
+     * @memberof RemarkMetadataAction
+     * @instance
+     */
+    RemarkMetadataAction.prototype.moderatePost = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * RemarkMetadataAction action.
+     * @member {"moderatePost"|undefined} action
+     * @memberof RemarkMetadataAction
+     * @instance
+     */
+    Object.defineProperty(RemarkMetadataAction.prototype, "action", {
+        get: $util.oneOfGetter($oneOfFields = ["moderatePost"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new RemarkMetadataAction instance using the specified properties.
+     * @function create
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {IRemarkMetadataAction=} [properties] Properties to set
+     * @returns {RemarkMetadataAction} RemarkMetadataAction instance
+     */
+    RemarkMetadataAction.create = function create(properties) {
+        return new RemarkMetadataAction(properties);
+    };
+
+    /**
+     * Encodes the specified RemarkMetadataAction message. Does not implicitly {@link RemarkMetadataAction.verify|verify} messages.
+     * @function encode
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {IRemarkMetadataAction} message RemarkMetadataAction message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    RemarkMetadataAction.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.moderatePost != null && Object.hasOwnProperty.call(message, "moderatePost"))
+            $root.ModeratePost.encode(message.moderatePost, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified RemarkMetadataAction message, length delimited. Does not implicitly {@link RemarkMetadataAction.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {IRemarkMetadataAction} message RemarkMetadataAction message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    RemarkMetadataAction.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a RemarkMetadataAction message from the specified reader or buffer.
+     * @function decode
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {RemarkMetadataAction} RemarkMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    RemarkMetadataAction.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RemarkMetadataAction();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.moderatePost = $root.ModeratePost.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a RemarkMetadataAction message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {RemarkMetadataAction} RemarkMetadataAction
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    RemarkMetadataAction.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a RemarkMetadataAction message.
+     * @function verify
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    RemarkMetadataAction.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.moderatePost != null && message.hasOwnProperty("moderatePost")) {
+            properties.action = 1;
+            {
+                var error = $root.ModeratePost.verify(message.moderatePost);
+                if (error)
+                    return "moderatePost." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a RemarkMetadataAction message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {RemarkMetadataAction} RemarkMetadataAction
+     */
+    RemarkMetadataAction.fromObject = function fromObject(object) {
+        if (object instanceof $root.RemarkMetadataAction)
+            return object;
+        var message = new $root.RemarkMetadataAction();
+        if (object.moderatePost != null) {
+            if (typeof object.moderatePost !== "object")
+                throw TypeError(".RemarkMetadataAction.moderatePost: object expected");
+            message.moderatePost = $root.ModeratePost.fromObject(object.moderatePost);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a RemarkMetadataAction message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof RemarkMetadataAction
+     * @static
+     * @param {RemarkMetadataAction} message RemarkMetadataAction
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    RemarkMetadataAction.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.moderatePost != null && message.hasOwnProperty("moderatePost")) {
+            object.moderatePost = $root.ModeratePost.toObject(message.moderatePost, options);
+            if (options.oneofs)
+                object.action = "moderatePost";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this RemarkMetadataAction to JSON.
+     * @function toJSON
+     * @memberof RemarkMetadataAction
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    RemarkMetadataAction.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return RemarkMetadataAction;
+})();
+
+module.exports = $root;
diff --git a/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts b/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts
index c95539d..843fa32 100755
--- a/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts
+++ b/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts
@@ -1,4 +1,3 @@
-import { Long } from 'long'
 import * as $protobuf from "protobufjs";
 /** Properties of an AppActionMetadata. */
 export interface IAppActionMetadata {
@@ -4545,6 +4544,333 @@ export class DistributionBucketFamilyMetadata implements IDistributionBucketFami
     public toJSON(): { [k: string]: any };
 }
 
+/** Properties of a TokenMetadata. */
+export interface ITokenMetadata {
+
+    /** TokenMetadata name */
+    name?: (string|null);
+
+    /** TokenMetadata description */
+    description?: (string|null);
+
+    /** TokenMetadata avatarObject */
+    avatarObject?: (number|null);
+
+    /** TokenMetadata avatarUri */
+    avatarUri?: (string|null);
+
+    /** TokenMetadata benefits */
+    benefits?: (IBenefit[]|null);
+
+    /** TokenMetadata whitelistApplicationNote */
+    whitelistApplicationNote?: (string|null);
+
+    /** TokenMetadata whitelistApplicationApplyLink */
+    whitelistApplicationApplyLink?: (string|null);
+}
+
+/** Represents a TokenMetadata. */
+export class TokenMetadata implements ITokenMetadata {
+
+    /**
+     * Constructs a new TokenMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ITokenMetadata);
+
+    /** TokenMetadata name. */
+    public name: string;
+
+    /** TokenMetadata description. */
+    public description: string;
+
+    /** TokenMetadata avatarObject. */
+    public avatarObject?: (number|null);
+
+    /** TokenMetadata avatarUri. */
+    public avatarUri?: (string|null);
+
+    /** TokenMetadata benefits. */
+    public benefits: IBenefit[];
+
+    /** TokenMetadata whitelistApplicationNote. */
+    public whitelistApplicationNote: string;
+
+    /** TokenMetadata whitelistApplicationApplyLink. */
+    public whitelistApplicationApplyLink: string;
+
+    /** TokenMetadata avatar. */
+    public avatar?: ("avatarObject"|"avatarUri");
+
+    /**
+     * Creates a new TokenMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns TokenMetadata instance
+     */
+    public static create(properties?: ITokenMetadata): TokenMetadata;
+
+    /**
+     * Encodes the specified TokenMetadata message. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @param message TokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ITokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified TokenMetadata message, length delimited. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @param message TokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ITokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TokenMetadata;
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TokenMetadata;
+
+    /**
+     * Verifies a TokenMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a TokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns TokenMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): TokenMetadata;
+
+    /**
+     * Creates a plain object from a TokenMetadata message. Also converts values to other types if specified.
+     * @param message TokenMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: TokenMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this TokenMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a Benefit. */
+export interface IBenefit {
+
+    /** Benefit title */
+    title?: (string|null);
+
+    /** Benefit description */
+    description?: (string|null);
+
+    /** Benefit emoji */
+    emoji?: (string|null);
+
+    /** Benefit displayOrder */
+    displayOrder?: (number|null);
+}
+
+/** Represents a Benefit. */
+export class Benefit implements IBenefit {
+
+    /**
+     * Constructs a new Benefit.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IBenefit);
+
+    /** Benefit title. */
+    public title: string;
+
+    /** Benefit description. */
+    public description: string;
+
+    /** Benefit emoji. */
+    public emoji: string;
+
+    /** Benefit displayOrder. */
+    public displayOrder: number;
+
+    /**
+     * Creates a new Benefit instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns Benefit instance
+     */
+    public static create(properties?: IBenefit): Benefit;
+
+    /**
+     * Encodes the specified Benefit message. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @param message Benefit message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IBenefit, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified Benefit message, length delimited. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @param message Benefit message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IBenefit, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Benefit;
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Benefit;
+
+    /**
+     * Verifies a Benefit message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a Benefit message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns Benefit
+     */
+    public static fromObject(object: { [k: string]: any }): Benefit;
+
+    /**
+     * Creates a plain object from a Benefit message. Also converts values to other types if specified.
+     * @param message Benefit
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: Benefit, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this Benefit to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a SaleMetadata. */
+export interface ISaleMetadata {
+
+    /** SaleMetadata termsAndConditions */
+    termsAndConditions?: (string|null);
+}
+
+/** Represents a SaleMetadata. */
+export class SaleMetadata implements ISaleMetadata {
+
+    /**
+     * Constructs a new SaleMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ISaleMetadata);
+
+    /** SaleMetadata termsAndConditions. */
+    public termsAndConditions: string;
+
+    /**
+     * Creates a new SaleMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns SaleMetadata instance
+     */
+    public static create(properties?: ISaleMetadata): SaleMetadata;
+
+    /**
+     * Encodes the specified SaleMetadata message. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @param message SaleMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ISaleMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified SaleMetadata message, length delimited. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @param message SaleMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ISaleMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SaleMetadata;
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SaleMetadata;
+
+    /**
+     * Verifies a SaleMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a SaleMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns SaleMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): SaleMetadata;
+
+    /**
+     * Creates a plain object from a SaleMetadata message. Also converts values to other types if specified.
+     * @param message SaleMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: SaleMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this SaleMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
 /** Properties of a PublishedBeforeJoystream. */
 export interface IPublishedBeforeJoystream {
 
diff --git a/node_modules/@joystream/metadata-protobuf/compiled/index.js b/node_modules/@joystream/metadata-protobuf/compiled/index.js
index 2e7a59c..5e93e98 100755
--- a/node_modules/@joystream/metadata-protobuf/compiled/index.js
+++ b/node_modules/@joystream/metadata-protobuf/compiled/index.js
@@ -11132,6 +11132,814 @@ $root.DistributionBucketFamilyMetadata = (function() {
     return DistributionBucketFamilyMetadata;
 })();
 
+$root.TokenMetadata = (function() {
+
+    /**
+     * Properties of a TokenMetadata.
+     * @exports ITokenMetadata
+     * @interface ITokenMetadata
+     * @property {string|null} [name] TokenMetadata name
+     * @property {string|null} [description] TokenMetadata description
+     * @property {number|null} [avatarObject] TokenMetadata avatarObject
+     * @property {string|null} [avatarUri] TokenMetadata avatarUri
+     * @property {Array.<IBenefit>|null} [benefits] TokenMetadata benefits
+     * @property {string|null} [whitelistApplicationNote] TokenMetadata whitelistApplicationNote
+     * @property {string|null} [whitelistApplicationApplyLink] TokenMetadata whitelistApplicationApplyLink
+     */
+
+    /**
+     * Constructs a new TokenMetadata.
+     * @exports TokenMetadata
+     * @classdesc Represents a TokenMetadata.
+     * @implements ITokenMetadata
+     * @constructor
+     * @param {ITokenMetadata=} [properties] Properties to set
+     */
+    function TokenMetadata(properties) {
+        this.benefits = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * TokenMetadata name.
+     * @member {string} name
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.name = "";
+
+    /**
+     * TokenMetadata description.
+     * @member {string} description
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.description = "";
+
+    /**
+     * TokenMetadata avatarObject.
+     * @member {number|null|undefined} avatarObject
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.avatarObject = null;
+
+    /**
+     * TokenMetadata avatarUri.
+     * @member {string|null|undefined} avatarUri
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.avatarUri = null;
+
+    /**
+     * TokenMetadata benefits.
+     * @member {Array.<IBenefit>} benefits
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.benefits = $util.emptyArray;
+
+    /**
+     * TokenMetadata whitelistApplicationNote.
+     * @member {string} whitelistApplicationNote
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.whitelistApplicationNote = "";
+
+    /**
+     * TokenMetadata whitelistApplicationApplyLink.
+     * @member {string} whitelistApplicationApplyLink
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.whitelistApplicationApplyLink = "";
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * TokenMetadata avatar.
+     * @member {"avatarObject"|"avatarUri"|undefined} avatar
+     * @memberof TokenMetadata
+     * @instance
+     */
+    Object.defineProperty(TokenMetadata.prototype, "avatar", {
+        get: $util.oneOfGetter($oneOfFields = ["avatarObject", "avatarUri"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new TokenMetadata instance using the specified properties.
+     * @function create
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata=} [properties] Properties to set
+     * @returns {TokenMetadata} TokenMetadata instance
+     */
+    TokenMetadata.create = function create(properties) {
+        return new TokenMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified TokenMetadata message. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata} message TokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    TokenMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.avatarObject != null && Object.hasOwnProperty.call(message, "avatarObject"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.avatarObject);
+        if (message.avatarUri != null && Object.hasOwnProperty.call(message, "avatarUri"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarUri);
+        if (message.benefits != null && message.benefits.length)
+            for (var i = 0; i < message.benefits.length; ++i)
+                $root.Benefit.encode(message.benefits[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
+        if (message.whitelistApplicationNote != null && Object.hasOwnProperty.call(message, "whitelistApplicationNote"))
+            writer.uint32(/* id 6, wireType 2 =*/50).string(message.whitelistApplicationNote);
+        if (message.whitelistApplicationApplyLink != null && Object.hasOwnProperty.call(message, "whitelistApplicationApplyLink"))
+            writer.uint32(/* id 7, wireType 2 =*/58).string(message.whitelistApplicationApplyLink);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified TokenMetadata message, length delimited. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata} message TokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    TokenMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof TokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {TokenMetadata} TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    TokenMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TokenMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.name = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.avatarObject = reader.uint32();
+                break;
+            case 4:
+                message.avatarUri = reader.string();
+                break;
+            case 5:
+                if (!(message.benefits && message.benefits.length))
+                    message.benefits = [];
+                message.benefits.push($root.Benefit.decode(reader, reader.uint32()));
+                break;
+            case 6:
+                message.whitelistApplicationNote = reader.string();
+                break;
+            case 7:
+                message.whitelistApplicationApplyLink = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof TokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {TokenMetadata} TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    TokenMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a TokenMetadata message.
+     * @function verify
+     * @memberof TokenMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    TokenMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.name != null && message.hasOwnProperty("name"))
+            if (!$util.isString(message.name))
+                return "name: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            properties.avatar = 1;
+            if (!$util.isInteger(message.avatarObject))
+                return "avatarObject: integer expected";
+        }
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            if (properties.avatar === 1)
+                return "avatar: multiple values";
+            properties.avatar = 1;
+            if (!$util.isString(message.avatarUri))
+                return "avatarUri: string expected";
+        }
+        if (message.benefits != null && message.hasOwnProperty("benefits")) {
+            if (!Array.isArray(message.benefits))
+                return "benefits: array expected";
+            for (var i = 0; i < message.benefits.length; ++i) {
+                var error = $root.Benefit.verify(message.benefits[i]);
+                if (error)
+                    return "benefits." + error;
+            }
+        }
+        if (message.whitelistApplicationNote != null && message.hasOwnProperty("whitelistApplicationNote"))
+            if (!$util.isString(message.whitelistApplicationNote))
+                return "whitelistApplicationNote: string expected";
+        if (message.whitelistApplicationApplyLink != null && message.hasOwnProperty("whitelistApplicationApplyLink"))
+            if (!$util.isString(message.whitelistApplicationApplyLink))
+                return "whitelistApplicationApplyLink: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a TokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof TokenMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {TokenMetadata} TokenMetadata
+     */
+    TokenMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.TokenMetadata)
+            return object;
+        var message = new $root.TokenMetadata();
+        if (object.name != null)
+            message.name = String(object.name);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.avatarObject != null)
+            message.avatarObject = object.avatarObject >>> 0;
+        if (object.avatarUri != null)
+            message.avatarUri = String(object.avatarUri);
+        if (object.benefits) {
+            if (!Array.isArray(object.benefits))
+                throw TypeError(".TokenMetadata.benefits: array expected");
+            message.benefits = [];
+            for (var i = 0; i < object.benefits.length; ++i) {
+                if (typeof object.benefits[i] !== "object")
+                    throw TypeError(".TokenMetadata.benefits: object expected");
+                message.benefits[i] = $root.Benefit.fromObject(object.benefits[i]);
+            }
+        }
+        if (object.whitelistApplicationNote != null)
+            message.whitelistApplicationNote = String(object.whitelistApplicationNote);
+        if (object.whitelistApplicationApplyLink != null)
+            message.whitelistApplicationApplyLink = String(object.whitelistApplicationApplyLink);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a TokenMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof TokenMetadata
+     * @static
+     * @param {TokenMetadata} message TokenMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    TokenMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.benefits = [];
+        if (options.defaults) {
+            object.name = "";
+            object.description = "";
+            object.whitelistApplicationNote = "";
+            object.whitelistApplicationApplyLink = "";
+        }
+        if (message.name != null && message.hasOwnProperty("name"))
+            object.name = message.name;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            object.avatarObject = message.avatarObject;
+            if (options.oneofs)
+                object.avatar = "avatarObject";
+        }
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            object.avatarUri = message.avatarUri;
+            if (options.oneofs)
+                object.avatar = "avatarUri";
+        }
+        if (message.benefits && message.benefits.length) {
+            object.benefits = [];
+            for (var j = 0; j < message.benefits.length; ++j)
+                object.benefits[j] = $root.Benefit.toObject(message.benefits[j], options);
+        }
+        if (message.whitelistApplicationNote != null && message.hasOwnProperty("whitelistApplicationNote"))
+            object.whitelistApplicationNote = message.whitelistApplicationNote;
+        if (message.whitelistApplicationApplyLink != null && message.hasOwnProperty("whitelistApplicationApplyLink"))
+            object.whitelistApplicationApplyLink = message.whitelistApplicationApplyLink;
+        return object;
+    };
+
+    /**
+     * Converts this TokenMetadata to JSON.
+     * @function toJSON
+     * @memberof TokenMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    TokenMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return TokenMetadata;
+})();
+
+$root.Benefit = (function() {
+
+    /**
+     * Properties of a Benefit.
+     * @exports IBenefit
+     * @interface IBenefit
+     * @property {string|null} [title] Benefit title
+     * @property {string|null} [description] Benefit description
+     * @property {string|null} [emoji] Benefit emoji
+     * @property {number|null} [displayOrder] Benefit displayOrder
+     */
+
+    /**
+     * Constructs a new Benefit.
+     * @exports Benefit
+     * @classdesc Represents a Benefit.
+     * @implements IBenefit
+     * @constructor
+     * @param {IBenefit=} [properties] Properties to set
+     */
+    function Benefit(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * Benefit title.
+     * @member {string} title
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.title = "";
+
+    /**
+     * Benefit description.
+     * @member {string} description
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.description = "";
+
+    /**
+     * Benefit emoji.
+     * @member {string} emoji
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.emoji = "";
+
+    /**
+     * Benefit displayOrder.
+     * @member {number} displayOrder
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.displayOrder = 0;
+
+    /**
+     * Creates a new Benefit instance using the specified properties.
+     * @function create
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit=} [properties] Properties to set
+     * @returns {Benefit} Benefit instance
+     */
+    Benefit.create = function create(properties) {
+        return new Benefit(properties);
+    };
+
+    /**
+     * Encodes the specified Benefit message. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @function encode
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit} message Benefit message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Benefit.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.emoji);
+        if (message.displayOrder != null && Object.hasOwnProperty.call(message, "displayOrder"))
+            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.displayOrder);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified Benefit message, length delimited. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit} message Benefit message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Benefit.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer.
+     * @function decode
+     * @memberof Benefit
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {Benefit} Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Benefit.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Benefit();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.emoji = reader.string();
+                break;
+            case 4:
+                message.displayOrder = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof Benefit
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {Benefit} Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Benefit.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a Benefit message.
+     * @function verify
+     * @memberof Benefit
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    Benefit.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.emoji != null && message.hasOwnProperty("emoji"))
+            if (!$util.isString(message.emoji))
+                return "emoji: string expected";
+        if (message.displayOrder != null && message.hasOwnProperty("displayOrder"))
+            if (!$util.isInteger(message.displayOrder))
+                return "displayOrder: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a Benefit message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof Benefit
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {Benefit} Benefit
+     */
+    Benefit.fromObject = function fromObject(object) {
+        if (object instanceof $root.Benefit)
+            return object;
+        var message = new $root.Benefit();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.emoji != null)
+            message.emoji = String(object.emoji);
+        if (object.displayOrder != null)
+            message.displayOrder = object.displayOrder >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a Benefit message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof Benefit
+     * @static
+     * @param {Benefit} message Benefit
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    Benefit.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            object.emoji = "";
+            object.displayOrder = 0;
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.emoji != null && message.hasOwnProperty("emoji"))
+            object.emoji = message.emoji;
+        if (message.displayOrder != null && message.hasOwnProperty("displayOrder"))
+            object.displayOrder = message.displayOrder;
+        return object;
+    };
+
+    /**
+     * Converts this Benefit to JSON.
+     * @function toJSON
+     * @memberof Benefit
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    Benefit.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return Benefit;
+})();
+
+$root.SaleMetadata = (function() {
+
+    /**
+     * Properties of a SaleMetadata.
+     * @exports ISaleMetadata
+     * @interface ISaleMetadata
+     * @property {string|null} [termsAndConditions] SaleMetadata termsAndConditions
+     */
+
+    /**
+     * Constructs a new SaleMetadata.
+     * @exports SaleMetadata
+     * @classdesc Represents a SaleMetadata.
+     * @implements ISaleMetadata
+     * @constructor
+     * @param {ISaleMetadata=} [properties] Properties to set
+     */
+    function SaleMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * SaleMetadata termsAndConditions.
+     * @member {string} termsAndConditions
+     * @memberof SaleMetadata
+     * @instance
+     */
+    SaleMetadata.prototype.termsAndConditions = "";
+
+    /**
+     * Creates a new SaleMetadata instance using the specified properties.
+     * @function create
+     * @memberof SaleMetadata
+     * @static
+     * @param {ISaleMetadata=} [properties] Properties to set
+     * @returns {SaleMetadata} SaleMetadata instance
+     */
+    SaleMetadata.create = function create(properties) {
+        return new SaleMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified SaleMetadata message. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof SaleMetadata
+     * @static
+     * @param {ISaleMetadata} message SaleMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SaleMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.termsAndConditions != null && Object.hasOwnProperty.call(message, "termsAndConditions"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.termsAndConditions);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified SaleMetadata message, length delimited. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof SaleMetadata
+     * @static
+     * @param {ISaleMetadata} message SaleMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SaleMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof SaleMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {SaleMetadata} SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SaleMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SaleMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.termsAndConditions = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof SaleMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {SaleMetadata} SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SaleMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a SaleMetadata message.
+     * @function verify
+     * @memberof SaleMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    SaleMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
+            if (!$util.isString(message.termsAndConditions))
+                return "termsAndConditions: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a SaleMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof SaleMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {SaleMetadata} SaleMetadata
+     */
+    SaleMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.SaleMetadata)
+            return object;
+        var message = new $root.SaleMetadata();
+        if (object.termsAndConditions != null)
+            message.termsAndConditions = String(object.termsAndConditions);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a SaleMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof SaleMetadata
+     * @static
+     * @param {SaleMetadata} message SaleMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    SaleMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.termsAndConditions = "";
+        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
+            object.termsAndConditions = message.termsAndConditions;
+        return object;
+    };
+
+    /**
+     * Converts this SaleMetadata to JSON.
+     * @function toJSON
+     * @memberof SaleMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    SaleMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return SaleMetadata;
+})();
+
 $root.PublishedBeforeJoystream = (function() {
 
     /**
