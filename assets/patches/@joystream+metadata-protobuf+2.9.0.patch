diff --git a/node_modules/@joystream/metadata-protobuf/.eslintignore b/node_modules/@joystream/metadata-protobuf/.eslintignore
new file mode 100644
index 0000000..d0049b1
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/.eslintignore
@@ -0,0 +1,4 @@
+lib/
+proto/
+compiled/
+.eslintrc.js
diff --git a/node_modules/@joystream/metadata-protobuf/.eslintrc.js b/node_modules/@joystream/metadata-protobuf/.eslintrc.js
new file mode 100644
index 0000000..d8ea276
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/.eslintrc.js
@@ -0,0 +1,16 @@
+module.exports = {
+  env: {
+    mocha: true,
+  },
+  parserOptions: {
+    project: './tsconfig.json'
+  },
+  extends: [
+    '@joystream/eslint-config'
+  ],
+  rules: {
+    'no-unused-vars': 'off', // Required by the typescript rule below
+    '@typescript-eslint/no-unused-vars': ['error'],
+    '@typescript-eslint/no-floating-promises': 'error',
+  },
+}
diff --git a/node_modules/@joystream/metadata-protobuf/.gitignore b/node_modules/@joystream/metadata-protobuf/.gitignore
new file mode 100644
index 0000000..1789b65
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/.gitignore
@@ -0,0 +1,4 @@
+node_modules/
+lib/
+compiled/
+src/json/*.json
diff --git a/node_modules/@joystream/metadata-protobuf/.prettierignore b/node_modules/@joystream/metadata-protobuf/.prettierignore
new file mode 100644
index 0000000..79fafec
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/.prettierignore
@@ -0,0 +1,5 @@
+lib/
+doc/
+proto/
+compiled/
+src/json/messages.json
\ No newline at end of file
diff --git a/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts b/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts
old mode 100755
new mode 100644
index c95539d..eabd4b9
--- a/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts
+++ b/node_modules/@joystream/metadata-protobuf/compiled/index.d.ts
@@ -4545,6 +4545,522 @@ export class DistributionBucketFamilyMetadata implements IDistributionBucketFami
     public toJSON(): { [k: string]: any };
 }
 
+/** Properties of a CreatorTokenIssuerRemarked. */
+export interface ICreatorTokenIssuerRemarked {
+
+    /** CreatorTokenIssuerRemarked updateTokenMetadata */
+    updateTokenMetadata?: (IUpdateTokenMetadata|null);
+}
+
+/** Represents a CreatorTokenIssuerRemarked. */
+export class CreatorTokenIssuerRemarked implements ICreatorTokenIssuerRemarked {
+
+    /**
+     * Constructs a new CreatorTokenIssuerRemarked.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ICreatorTokenIssuerRemarked);
+
+    /** CreatorTokenIssuerRemarked updateTokenMetadata. */
+    public updateTokenMetadata?: (IUpdateTokenMetadata|null);
+
+    /** CreatorTokenIssuerRemarked creatorTokenIssuerRemarked. */
+    public creatorTokenIssuerRemarked?: "updateTokenMetadata";
+
+    /**
+     * Creates a new CreatorTokenIssuerRemarked instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns CreatorTokenIssuerRemarked instance
+     */
+    public static create(properties?: ICreatorTokenIssuerRemarked): CreatorTokenIssuerRemarked;
+
+    /**
+     * Encodes the specified CreatorTokenIssuerRemarked message. Does not implicitly {@link CreatorTokenIssuerRemarked.verify|verify} messages.
+     * @param message CreatorTokenIssuerRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ICreatorTokenIssuerRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified CreatorTokenIssuerRemarked message, length delimited. Does not implicitly {@link CreatorTokenIssuerRemarked.verify|verify} messages.
+     * @param message CreatorTokenIssuerRemarked message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ICreatorTokenIssuerRemarked, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a CreatorTokenIssuerRemarked message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns CreatorTokenIssuerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): CreatorTokenIssuerRemarked;
+
+    /**
+     * Decodes a CreatorTokenIssuerRemarked message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns CreatorTokenIssuerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): CreatorTokenIssuerRemarked;
+
+    /**
+     * Verifies a CreatorTokenIssuerRemarked message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a CreatorTokenIssuerRemarked message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns CreatorTokenIssuerRemarked
+     */
+    public static fromObject(object: { [k: string]: any }): CreatorTokenIssuerRemarked;
+
+    /**
+     * Creates a plain object from a CreatorTokenIssuerRemarked message. Also converts values to other types if specified.
+     * @param message CreatorTokenIssuerRemarked
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: CreatorTokenIssuerRemarked, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this CreatorTokenIssuerRemarked to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of an UpdateTokenMetadata. */
+export interface IUpdateTokenMetadata {
+
+    /** UpdateTokenMetadata newMetadata */
+    newMetadata?: (ITokenMetadata|null);
+}
+
+/** Represents an UpdateTokenMetadata. */
+export class UpdateTokenMetadata implements IUpdateTokenMetadata {
+
+    /**
+     * Constructs a new UpdateTokenMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IUpdateTokenMetadata);
+
+    /** UpdateTokenMetadata newMetadata. */
+    public newMetadata?: (ITokenMetadata|null);
+
+    /**
+     * Creates a new UpdateTokenMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns UpdateTokenMetadata instance
+     */
+    public static create(properties?: IUpdateTokenMetadata): UpdateTokenMetadata;
+
+    /**
+     * Encodes the specified UpdateTokenMetadata message. Does not implicitly {@link UpdateTokenMetadata.verify|verify} messages.
+     * @param message UpdateTokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IUpdateTokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified UpdateTokenMetadata message, length delimited. Does not implicitly {@link UpdateTokenMetadata.verify|verify} messages.
+     * @param message UpdateTokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IUpdateTokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes an UpdateTokenMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns UpdateTokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): UpdateTokenMetadata;
+
+    /**
+     * Decodes an UpdateTokenMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns UpdateTokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): UpdateTokenMetadata;
+
+    /**
+     * Verifies an UpdateTokenMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates an UpdateTokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns UpdateTokenMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): UpdateTokenMetadata;
+
+    /**
+     * Creates a plain object from an UpdateTokenMetadata message. Also converts values to other types if specified.
+     * @param message UpdateTokenMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: UpdateTokenMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this UpdateTokenMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a TokenMetadata. */
+export interface ITokenMetadata {
+
+    /** TokenMetadata name */
+    name?: (string|null);
+
+    /** TokenMetadata description */
+    description?: (string|null);
+
+    /** TokenMetadata avatarObject */
+    avatarObject?: (number|null);
+
+    /** TokenMetadata avatarUri */
+    avatarUri?: (string|null);
+
+    /** TokenMetadata benefits */
+    benefits?: (IBenefit[]|null);
+
+    /** TokenMetadata whitelistApplicationNote */
+    whitelistApplicationNote?: (string|null);
+
+    /** TokenMetadata whitelistApplicationApplyLink */
+    whitelistApplicationApplyLink?: (string|null);
+
+    /** TokenMetadata trailerVideoId */
+    trailerVideoId?: (Long|null);
+}
+
+/** Represents a TokenMetadata. */
+export class TokenMetadata implements ITokenMetadata {
+
+    /**
+     * Constructs a new TokenMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ITokenMetadata);
+
+    /** TokenMetadata name. */
+    public name: string;
+
+    /** TokenMetadata description. */
+    public description: string;
+
+    /** TokenMetadata avatarObject. */
+    public avatarObject?: (number|null);
+
+    /** TokenMetadata avatarUri. */
+    public avatarUri?: (string|null);
+
+    /** TokenMetadata benefits. */
+    public benefits: IBenefit[];
+
+    /** TokenMetadata whitelistApplicationNote. */
+    public whitelistApplicationNote: string;
+
+    /** TokenMetadata whitelistApplicationApplyLink. */
+    public whitelistApplicationApplyLink: string;
+
+    /** TokenMetadata trailerVideoId. */
+    public trailerVideoId: Long;
+
+    /** TokenMetadata avatar. */
+    public avatar?: ("avatarObject"|"avatarUri");
+
+    /**
+     * Creates a new TokenMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns TokenMetadata instance
+     */
+    public static create(properties?: ITokenMetadata): TokenMetadata;
+
+    /**
+     * Encodes the specified TokenMetadata message. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @param message TokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ITokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified TokenMetadata message, length delimited. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @param message TokenMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ITokenMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TokenMetadata;
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TokenMetadata;
+
+    /**
+     * Verifies a TokenMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a TokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns TokenMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): TokenMetadata;
+
+    /**
+     * Creates a plain object from a TokenMetadata message. Also converts values to other types if specified.
+     * @param message TokenMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: TokenMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this TokenMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a Benefit. */
+export interface IBenefit {
+
+    /** Benefit title */
+    title?: (string|null);
+
+    /** Benefit description */
+    description?: (string|null);
+
+    /** Benefit emoji */
+    emoji?: (string|null);
+
+    /** Benefit displayOrder */
+    displayOrder?: (number|null);
+}
+
+/** Represents a Benefit. */
+export class Benefit implements IBenefit {
+
+    /**
+     * Constructs a new Benefit.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: IBenefit);
+
+    /** Benefit title. */
+    public title: string;
+
+    /** Benefit description. */
+    public description: string;
+
+    /** Benefit emoji. */
+    public emoji: string;
+
+    /** Benefit displayOrder. */
+    public displayOrder: number;
+
+    /**
+     * Creates a new Benefit instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns Benefit instance
+     */
+    public static create(properties?: IBenefit): Benefit;
+
+    /**
+     * Encodes the specified Benefit message. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @param message Benefit message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: IBenefit, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified Benefit message, length delimited. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @param message Benefit message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: IBenefit, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Benefit;
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Benefit;
+
+    /**
+     * Verifies a Benefit message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a Benefit message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns Benefit
+     */
+    public static fromObject(object: { [k: string]: any }): Benefit;
+
+    /**
+     * Creates a plain object from a Benefit message. Also converts values to other types if specified.
+     * @param message Benefit
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: Benefit, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this Benefit to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
+/** Properties of a SaleMetadata. */
+export interface ISaleMetadata {
+
+    /** SaleMetadata termsAndConditions */
+    termsAndConditions?: (string|null);
+}
+
+/** Represents a SaleMetadata. */
+export class SaleMetadata implements ISaleMetadata {
+
+    /**
+     * Constructs a new SaleMetadata.
+     * @param [properties] Properties to set
+     */
+    constructor(properties?: ISaleMetadata);
+
+    /** SaleMetadata termsAndConditions. */
+    public termsAndConditions: string;
+
+    /**
+     * Creates a new SaleMetadata instance using the specified properties.
+     * @param [properties] Properties to set
+     * @returns SaleMetadata instance
+     */
+    public static create(properties?: ISaleMetadata): SaleMetadata;
+
+    /**
+     * Encodes the specified SaleMetadata message. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @param message SaleMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encode(message: ISaleMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Encodes the specified SaleMetadata message, length delimited. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @param message SaleMetadata message or plain object to encode
+     * @param [writer] Writer to encode to
+     * @returns Writer
+     */
+    public static encodeDelimited(message: ISaleMetadata, writer?: $protobuf.Writer): $protobuf.Writer;
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer.
+     * @param reader Reader or buffer to decode from
+     * @param [length] Message length if known beforehand
+     * @returns SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): SaleMetadata;
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer, length delimited.
+     * @param reader Reader or buffer to decode from
+     * @returns SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): SaleMetadata;
+
+    /**
+     * Verifies a SaleMetadata message.
+     * @param message Plain object to verify
+     * @returns `null` if valid, otherwise the reason why it is not
+     */
+    public static verify(message: { [k: string]: any }): (string|null);
+
+    /**
+     * Creates a SaleMetadata message from a plain object. Also converts values to their respective internal types.
+     * @param object Plain object
+     * @returns SaleMetadata
+     */
+    public static fromObject(object: { [k: string]: any }): SaleMetadata;
+
+    /**
+     * Creates a plain object from a SaleMetadata message. Also converts values to other types if specified.
+     * @param message SaleMetadata
+     * @param [options] Conversion options
+     * @returns Plain object
+     */
+    public static toObject(message: SaleMetadata, options?: $protobuf.IConversionOptions): { [k: string]: any };
+
+    /**
+     * Converts this SaleMetadata to JSON.
+     * @returns JSON object
+     */
+    public toJSON(): { [k: string]: any };
+}
+
 /** Properties of a PublishedBeforeJoystream. */
 export interface IPublishedBeforeJoystream {
 
diff --git a/node_modules/@joystream/metadata-protobuf/compiled/index.js b/node_modules/@joystream/metadata-protobuf/compiled/index.js
old mode 100755
new mode 100644
index 2e7a59c..824d80c
--- a/node_modules/@joystream/metadata-protobuf/compiled/index.js
+++ b/node_modules/@joystream/metadata-protobuf/compiled/index.js
@@ -11132,6 +11132,1253 @@ $root.DistributionBucketFamilyMetadata = (function() {
     return DistributionBucketFamilyMetadata;
 })();
 
+$root.CreatorTokenIssuerRemarked = (function() {
+
+    /**
+     * Properties of a CreatorTokenIssuerRemarked.
+     * @exports ICreatorTokenIssuerRemarked
+     * @interface ICreatorTokenIssuerRemarked
+     * @property {IUpdateTokenMetadata|null} [updateTokenMetadata] CreatorTokenIssuerRemarked updateTokenMetadata
+     */
+
+    /**
+     * Constructs a new CreatorTokenIssuerRemarked.
+     * @exports CreatorTokenIssuerRemarked
+     * @classdesc Represents a CreatorTokenIssuerRemarked.
+     * @implements ICreatorTokenIssuerRemarked
+     * @constructor
+     * @param {ICreatorTokenIssuerRemarked=} [properties] Properties to set
+     */
+    function CreatorTokenIssuerRemarked(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * CreatorTokenIssuerRemarked updateTokenMetadata.
+     * @member {IUpdateTokenMetadata|null|undefined} updateTokenMetadata
+     * @memberof CreatorTokenIssuerRemarked
+     * @instance
+     */
+    CreatorTokenIssuerRemarked.prototype.updateTokenMetadata = null;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * CreatorTokenIssuerRemarked creatorTokenIssuerRemarked.
+     * @member {"updateTokenMetadata"|undefined} creatorTokenIssuerRemarked
+     * @memberof CreatorTokenIssuerRemarked
+     * @instance
+     */
+    Object.defineProperty(CreatorTokenIssuerRemarked.prototype, "creatorTokenIssuerRemarked", {
+        get: $util.oneOfGetter($oneOfFields = ["updateTokenMetadata"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new CreatorTokenIssuerRemarked instance using the specified properties.
+     * @function create
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {ICreatorTokenIssuerRemarked=} [properties] Properties to set
+     * @returns {CreatorTokenIssuerRemarked} CreatorTokenIssuerRemarked instance
+     */
+    CreatorTokenIssuerRemarked.create = function create(properties) {
+        return new CreatorTokenIssuerRemarked(properties);
+    };
+
+    /**
+     * Encodes the specified CreatorTokenIssuerRemarked message. Does not implicitly {@link CreatorTokenIssuerRemarked.verify|verify} messages.
+     * @function encode
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {ICreatorTokenIssuerRemarked} message CreatorTokenIssuerRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreatorTokenIssuerRemarked.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.updateTokenMetadata != null && Object.hasOwnProperty.call(message, "updateTokenMetadata"))
+            $root.UpdateTokenMetadata.encode(message.updateTokenMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified CreatorTokenIssuerRemarked message, length delimited. Does not implicitly {@link CreatorTokenIssuerRemarked.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {ICreatorTokenIssuerRemarked} message CreatorTokenIssuerRemarked message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    CreatorTokenIssuerRemarked.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a CreatorTokenIssuerRemarked message from the specified reader or buffer.
+     * @function decode
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {CreatorTokenIssuerRemarked} CreatorTokenIssuerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreatorTokenIssuerRemarked.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CreatorTokenIssuerRemarked();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.updateTokenMetadata = $root.UpdateTokenMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a CreatorTokenIssuerRemarked message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {CreatorTokenIssuerRemarked} CreatorTokenIssuerRemarked
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    CreatorTokenIssuerRemarked.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a CreatorTokenIssuerRemarked message.
+     * @function verify
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    CreatorTokenIssuerRemarked.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.updateTokenMetadata != null && message.hasOwnProperty("updateTokenMetadata")) {
+            properties.creatorTokenIssuerRemarked = 1;
+            {
+                var error = $root.UpdateTokenMetadata.verify(message.updateTokenMetadata);
+                if (error)
+                    return "updateTokenMetadata." + error;
+            }
+        }
+        return null;
+    };
+
+    /**
+     * Creates a CreatorTokenIssuerRemarked message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {CreatorTokenIssuerRemarked} CreatorTokenIssuerRemarked
+     */
+    CreatorTokenIssuerRemarked.fromObject = function fromObject(object) {
+        if (object instanceof $root.CreatorTokenIssuerRemarked)
+            return object;
+        var message = new $root.CreatorTokenIssuerRemarked();
+        if (object.updateTokenMetadata != null) {
+            if (typeof object.updateTokenMetadata !== "object")
+                throw TypeError(".CreatorTokenIssuerRemarked.updateTokenMetadata: object expected");
+            message.updateTokenMetadata = $root.UpdateTokenMetadata.fromObject(object.updateTokenMetadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a CreatorTokenIssuerRemarked message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof CreatorTokenIssuerRemarked
+     * @static
+     * @param {CreatorTokenIssuerRemarked} message CreatorTokenIssuerRemarked
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    CreatorTokenIssuerRemarked.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (message.updateTokenMetadata != null && message.hasOwnProperty("updateTokenMetadata")) {
+            object.updateTokenMetadata = $root.UpdateTokenMetadata.toObject(message.updateTokenMetadata, options);
+            if (options.oneofs)
+                object.creatorTokenIssuerRemarked = "updateTokenMetadata";
+        }
+        return object;
+    };
+
+    /**
+     * Converts this CreatorTokenIssuerRemarked to JSON.
+     * @function toJSON
+     * @memberof CreatorTokenIssuerRemarked
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    CreatorTokenIssuerRemarked.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return CreatorTokenIssuerRemarked;
+})();
+
+$root.UpdateTokenMetadata = (function() {
+
+    /**
+     * Properties of an UpdateTokenMetadata.
+     * @exports IUpdateTokenMetadata
+     * @interface IUpdateTokenMetadata
+     * @property {ITokenMetadata|null} [newMetadata] UpdateTokenMetadata newMetadata
+     */
+
+    /**
+     * Constructs a new UpdateTokenMetadata.
+     * @exports UpdateTokenMetadata
+     * @classdesc Represents an UpdateTokenMetadata.
+     * @implements IUpdateTokenMetadata
+     * @constructor
+     * @param {IUpdateTokenMetadata=} [properties] Properties to set
+     */
+    function UpdateTokenMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * UpdateTokenMetadata newMetadata.
+     * @member {ITokenMetadata|null|undefined} newMetadata
+     * @memberof UpdateTokenMetadata
+     * @instance
+     */
+    UpdateTokenMetadata.prototype.newMetadata = null;
+
+    /**
+     * Creates a new UpdateTokenMetadata instance using the specified properties.
+     * @function create
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {IUpdateTokenMetadata=} [properties] Properties to set
+     * @returns {UpdateTokenMetadata} UpdateTokenMetadata instance
+     */
+    UpdateTokenMetadata.create = function create(properties) {
+        return new UpdateTokenMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified UpdateTokenMetadata message. Does not implicitly {@link UpdateTokenMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {IUpdateTokenMetadata} message UpdateTokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    UpdateTokenMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.newMetadata != null && Object.hasOwnProperty.call(message, "newMetadata"))
+            $root.TokenMetadata.encode(message.newMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
+        return writer;
+    };
+
+    /**
+     * Encodes the specified UpdateTokenMetadata message, length delimited. Does not implicitly {@link UpdateTokenMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {IUpdateTokenMetadata} message UpdateTokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    UpdateTokenMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes an UpdateTokenMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {UpdateTokenMetadata} UpdateTokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    UpdateTokenMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.UpdateTokenMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.newMetadata = $root.TokenMetadata.decode(reader, reader.uint32());
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes an UpdateTokenMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {UpdateTokenMetadata} UpdateTokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    UpdateTokenMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies an UpdateTokenMetadata message.
+     * @function verify
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    UpdateTokenMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.newMetadata != null && message.hasOwnProperty("newMetadata")) {
+            var error = $root.TokenMetadata.verify(message.newMetadata);
+            if (error)
+                return "newMetadata." + error;
+        }
+        return null;
+    };
+
+    /**
+     * Creates an UpdateTokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {UpdateTokenMetadata} UpdateTokenMetadata
+     */
+    UpdateTokenMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.UpdateTokenMetadata)
+            return object;
+        var message = new $root.UpdateTokenMetadata();
+        if (object.newMetadata != null) {
+            if (typeof object.newMetadata !== "object")
+                throw TypeError(".UpdateTokenMetadata.newMetadata: object expected");
+            message.newMetadata = $root.TokenMetadata.fromObject(object.newMetadata);
+        }
+        return message;
+    };
+
+    /**
+     * Creates a plain object from an UpdateTokenMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof UpdateTokenMetadata
+     * @static
+     * @param {UpdateTokenMetadata} message UpdateTokenMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    UpdateTokenMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.newMetadata = null;
+        if (message.newMetadata != null && message.hasOwnProperty("newMetadata"))
+            object.newMetadata = $root.TokenMetadata.toObject(message.newMetadata, options);
+        return object;
+    };
+
+    /**
+     * Converts this UpdateTokenMetadata to JSON.
+     * @function toJSON
+     * @memberof UpdateTokenMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    UpdateTokenMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return UpdateTokenMetadata;
+})();
+
+$root.TokenMetadata = (function() {
+
+    /**
+     * Properties of a TokenMetadata.
+     * @exports ITokenMetadata
+     * @interface ITokenMetadata
+     * @property {string|null} [name] TokenMetadata name
+     * @property {string|null} [description] TokenMetadata description
+     * @property {number|null} [avatarObject] TokenMetadata avatarObject
+     * @property {string|null} [avatarUri] TokenMetadata avatarUri
+     * @property {Array.<IBenefit>|null} [benefits] TokenMetadata benefits
+     * @property {string|null} [whitelistApplicationNote] TokenMetadata whitelistApplicationNote
+     * @property {string|null} [whitelistApplicationApplyLink] TokenMetadata whitelistApplicationApplyLink
+     * @property {Long|null} [trailerVideoId] TokenMetadata trailerVideoId
+     */
+
+    /**
+     * Constructs a new TokenMetadata.
+     * @exports TokenMetadata
+     * @classdesc Represents a TokenMetadata.
+     * @implements ITokenMetadata
+     * @constructor
+     * @param {ITokenMetadata=} [properties] Properties to set
+     */
+    function TokenMetadata(properties) {
+        this.benefits = [];
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * TokenMetadata name.
+     * @member {string} name
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.name = "";
+
+    /**
+     * TokenMetadata description.
+     * @member {string} description
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.description = "";
+
+    /**
+     * TokenMetadata avatarObject.
+     * @member {number|null|undefined} avatarObject
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.avatarObject = null;
+
+    /**
+     * TokenMetadata avatarUri.
+     * @member {string|null|undefined} avatarUri
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.avatarUri = null;
+
+    /**
+     * TokenMetadata benefits.
+     * @member {Array.<IBenefit>} benefits
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.benefits = $util.emptyArray;
+
+    /**
+     * TokenMetadata whitelistApplicationNote.
+     * @member {string} whitelistApplicationNote
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.whitelistApplicationNote = "";
+
+    /**
+     * TokenMetadata whitelistApplicationApplyLink.
+     * @member {string} whitelistApplicationApplyLink
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.whitelistApplicationApplyLink = "";
+
+    /**
+     * TokenMetadata trailerVideoId.
+     * @member {Long} trailerVideoId
+     * @memberof TokenMetadata
+     * @instance
+     */
+    TokenMetadata.prototype.trailerVideoId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
+
+    // OneOf field names bound to virtual getters and setters
+    var $oneOfFields;
+
+    /**
+     * TokenMetadata avatar.
+     * @member {"avatarObject"|"avatarUri"|undefined} avatar
+     * @memberof TokenMetadata
+     * @instance
+     */
+    Object.defineProperty(TokenMetadata.prototype, "avatar", {
+        get: $util.oneOfGetter($oneOfFields = ["avatarObject", "avatarUri"]),
+        set: $util.oneOfSetter($oneOfFields)
+    });
+
+    /**
+     * Creates a new TokenMetadata instance using the specified properties.
+     * @function create
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata=} [properties] Properties to set
+     * @returns {TokenMetadata} TokenMetadata instance
+     */
+    TokenMetadata.create = function create(properties) {
+        return new TokenMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified TokenMetadata message. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata} message TokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    TokenMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.avatarObject != null && Object.hasOwnProperty.call(message, "avatarObject"))
+            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.avatarObject);
+        if (message.avatarUri != null && Object.hasOwnProperty.call(message, "avatarUri"))
+            writer.uint32(/* id 4, wireType 2 =*/34).string(message.avatarUri);
+        if (message.benefits != null && message.benefits.length)
+            for (var i = 0; i < message.benefits.length; ++i)
+                $root.Benefit.encode(message.benefits[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
+        if (message.whitelistApplicationNote != null && Object.hasOwnProperty.call(message, "whitelistApplicationNote"))
+            writer.uint32(/* id 6, wireType 2 =*/50).string(message.whitelistApplicationNote);
+        if (message.whitelistApplicationApplyLink != null && Object.hasOwnProperty.call(message, "whitelistApplicationApplyLink"))
+            writer.uint32(/* id 7, wireType 2 =*/58).string(message.whitelistApplicationApplyLink);
+        if (message.trailerVideoId != null && Object.hasOwnProperty.call(message, "trailerVideoId"))
+            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.trailerVideoId);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified TokenMetadata message, length delimited. Does not implicitly {@link TokenMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof TokenMetadata
+     * @static
+     * @param {ITokenMetadata} message TokenMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    TokenMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof TokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {TokenMetadata} TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    TokenMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TokenMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.name = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.avatarObject = reader.uint32();
+                break;
+            case 4:
+                message.avatarUri = reader.string();
+                break;
+            case 5:
+                if (!(message.benefits && message.benefits.length))
+                    message.benefits = [];
+                message.benefits.push($root.Benefit.decode(reader, reader.uint32()));
+                break;
+            case 6:
+                message.whitelistApplicationNote = reader.string();
+                break;
+            case 7:
+                message.whitelistApplicationApplyLink = reader.string();
+                break;
+            case 8:
+                message.trailerVideoId = reader.uint64();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a TokenMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof TokenMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {TokenMetadata} TokenMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    TokenMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a TokenMetadata message.
+     * @function verify
+     * @memberof TokenMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    TokenMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        var properties = {};
+        if (message.name != null && message.hasOwnProperty("name"))
+            if (!$util.isString(message.name))
+                return "name: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            properties.avatar = 1;
+            if (!$util.isInteger(message.avatarObject))
+                return "avatarObject: integer expected";
+        }
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            if (properties.avatar === 1)
+                return "avatar: multiple values";
+            properties.avatar = 1;
+            if (!$util.isString(message.avatarUri))
+                return "avatarUri: string expected";
+        }
+        if (message.benefits != null && message.hasOwnProperty("benefits")) {
+            if (!Array.isArray(message.benefits))
+                return "benefits: array expected";
+            for (var i = 0; i < message.benefits.length; ++i) {
+                var error = $root.Benefit.verify(message.benefits[i]);
+                if (error)
+                    return "benefits." + error;
+            }
+        }
+        if (message.whitelistApplicationNote != null && message.hasOwnProperty("whitelistApplicationNote"))
+            if (!$util.isString(message.whitelistApplicationNote))
+                return "whitelistApplicationNote: string expected";
+        if (message.whitelistApplicationApplyLink != null && message.hasOwnProperty("whitelistApplicationApplyLink"))
+            if (!$util.isString(message.whitelistApplicationApplyLink))
+                return "whitelistApplicationApplyLink: string expected";
+        if (message.trailerVideoId != null && message.hasOwnProperty("trailerVideoId"))
+            if (!$util.isInteger(message.trailerVideoId) && !(message.trailerVideoId && $util.isInteger(message.trailerVideoId.low) && $util.isInteger(message.trailerVideoId.high)))
+                return "trailerVideoId: integer|Long expected";
+        return null;
+    };
+
+    /**
+     * Creates a TokenMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof TokenMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {TokenMetadata} TokenMetadata
+     */
+    TokenMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.TokenMetadata)
+            return object;
+        var message = new $root.TokenMetadata();
+        if (object.name != null)
+            message.name = String(object.name);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.avatarObject != null)
+            message.avatarObject = object.avatarObject >>> 0;
+        if (object.avatarUri != null)
+            message.avatarUri = String(object.avatarUri);
+        if (object.benefits) {
+            if (!Array.isArray(object.benefits))
+                throw TypeError(".TokenMetadata.benefits: array expected");
+            message.benefits = [];
+            for (var i = 0; i < object.benefits.length; ++i) {
+                if (typeof object.benefits[i] !== "object")
+                    throw TypeError(".TokenMetadata.benefits: object expected");
+                message.benefits[i] = $root.Benefit.fromObject(object.benefits[i]);
+            }
+        }
+        if (object.whitelistApplicationNote != null)
+            message.whitelistApplicationNote = String(object.whitelistApplicationNote);
+        if (object.whitelistApplicationApplyLink != null)
+            message.whitelistApplicationApplyLink = String(object.whitelistApplicationApplyLink);
+        if (object.trailerVideoId != null)
+            if ($util.Long)
+                (message.trailerVideoId = $util.Long.fromValue(object.trailerVideoId)).unsigned = true;
+            else if (typeof object.trailerVideoId === "string")
+                message.trailerVideoId = parseInt(object.trailerVideoId, 10);
+            else if (typeof object.trailerVideoId === "number")
+                message.trailerVideoId = object.trailerVideoId;
+            else if (typeof object.trailerVideoId === "object")
+                message.trailerVideoId = new $util.LongBits(object.trailerVideoId.low >>> 0, object.trailerVideoId.high >>> 0).toNumber(true);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a TokenMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof TokenMetadata
+     * @static
+     * @param {TokenMetadata} message TokenMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    TokenMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.arrays || options.defaults)
+            object.benefits = [];
+        if (options.defaults) {
+            object.name = "";
+            object.description = "";
+            object.whitelistApplicationNote = "";
+            object.whitelistApplicationApplyLink = "";
+            if ($util.Long) {
+                var long = new $util.Long(0, 0, true);
+                object.trailerVideoId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
+            } else
+                object.trailerVideoId = options.longs === String ? "0" : 0;
+        }
+        if (message.name != null && message.hasOwnProperty("name"))
+            object.name = message.name;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.avatarObject != null && message.hasOwnProperty("avatarObject")) {
+            object.avatarObject = message.avatarObject;
+            if (options.oneofs)
+                object.avatar = "avatarObject";
+        }
+        if (message.avatarUri != null && message.hasOwnProperty("avatarUri")) {
+            object.avatarUri = message.avatarUri;
+            if (options.oneofs)
+                object.avatar = "avatarUri";
+        }
+        if (message.benefits && message.benefits.length) {
+            object.benefits = [];
+            for (var j = 0; j < message.benefits.length; ++j)
+                object.benefits[j] = $root.Benefit.toObject(message.benefits[j], options);
+        }
+        if (message.whitelistApplicationNote != null && message.hasOwnProperty("whitelistApplicationNote"))
+            object.whitelistApplicationNote = message.whitelistApplicationNote;
+        if (message.whitelistApplicationApplyLink != null && message.hasOwnProperty("whitelistApplicationApplyLink"))
+            object.whitelistApplicationApplyLink = message.whitelistApplicationApplyLink;
+        if (message.trailerVideoId != null && message.hasOwnProperty("trailerVideoId"))
+            if (typeof message.trailerVideoId === "number")
+                object.trailerVideoId = options.longs === String ? String(message.trailerVideoId) : message.trailerVideoId;
+            else
+                object.trailerVideoId = options.longs === String ? $util.Long.prototype.toString.call(message.trailerVideoId) : options.longs === Number ? new $util.LongBits(message.trailerVideoId.low >>> 0, message.trailerVideoId.high >>> 0).toNumber(true) : message.trailerVideoId;
+        return object;
+    };
+
+    /**
+     * Converts this TokenMetadata to JSON.
+     * @function toJSON
+     * @memberof TokenMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    TokenMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return TokenMetadata;
+})();
+
+$root.Benefit = (function() {
+
+    /**
+     * Properties of a Benefit.
+     * @exports IBenefit
+     * @interface IBenefit
+     * @property {string|null} [title] Benefit title
+     * @property {string|null} [description] Benefit description
+     * @property {string|null} [emoji] Benefit emoji
+     * @property {number|null} [displayOrder] Benefit displayOrder
+     */
+
+    /**
+     * Constructs a new Benefit.
+     * @exports Benefit
+     * @classdesc Represents a Benefit.
+     * @implements IBenefit
+     * @constructor
+     * @param {IBenefit=} [properties] Properties to set
+     */
+    function Benefit(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * Benefit title.
+     * @member {string} title
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.title = "";
+
+    /**
+     * Benefit description.
+     * @member {string} description
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.description = "";
+
+    /**
+     * Benefit emoji.
+     * @member {string} emoji
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.emoji = "";
+
+    /**
+     * Benefit displayOrder.
+     * @member {number} displayOrder
+     * @memberof Benefit
+     * @instance
+     */
+    Benefit.prototype.displayOrder = 0;
+
+    /**
+     * Creates a new Benefit instance using the specified properties.
+     * @function create
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit=} [properties] Properties to set
+     * @returns {Benefit} Benefit instance
+     */
+    Benefit.create = function create(properties) {
+        return new Benefit(properties);
+    };
+
+    /**
+     * Encodes the specified Benefit message. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @function encode
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit} message Benefit message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Benefit.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.title != null && Object.hasOwnProperty.call(message, "title"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.title);
+        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
+            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
+        if (message.emoji != null && Object.hasOwnProperty.call(message, "emoji"))
+            writer.uint32(/* id 3, wireType 2 =*/26).string(message.emoji);
+        if (message.displayOrder != null && Object.hasOwnProperty.call(message, "displayOrder"))
+            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.displayOrder);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified Benefit message, length delimited. Does not implicitly {@link Benefit.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof Benefit
+     * @static
+     * @param {IBenefit} message Benefit message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    Benefit.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer.
+     * @function decode
+     * @memberof Benefit
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {Benefit} Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Benefit.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Benefit();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.title = reader.string();
+                break;
+            case 2:
+                message.description = reader.string();
+                break;
+            case 3:
+                message.emoji = reader.string();
+                break;
+            case 4:
+                message.displayOrder = reader.uint32();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a Benefit message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof Benefit
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {Benefit} Benefit
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    Benefit.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a Benefit message.
+     * @function verify
+     * @memberof Benefit
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    Benefit.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.title != null && message.hasOwnProperty("title"))
+            if (!$util.isString(message.title))
+                return "title: string expected";
+        if (message.description != null && message.hasOwnProperty("description"))
+            if (!$util.isString(message.description))
+                return "description: string expected";
+        if (message.emoji != null && message.hasOwnProperty("emoji"))
+            if (!$util.isString(message.emoji))
+                return "emoji: string expected";
+        if (message.displayOrder != null && message.hasOwnProperty("displayOrder"))
+            if (!$util.isInteger(message.displayOrder))
+                return "displayOrder: integer expected";
+        return null;
+    };
+
+    /**
+     * Creates a Benefit message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof Benefit
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {Benefit} Benefit
+     */
+    Benefit.fromObject = function fromObject(object) {
+        if (object instanceof $root.Benefit)
+            return object;
+        var message = new $root.Benefit();
+        if (object.title != null)
+            message.title = String(object.title);
+        if (object.description != null)
+            message.description = String(object.description);
+        if (object.emoji != null)
+            message.emoji = String(object.emoji);
+        if (object.displayOrder != null)
+            message.displayOrder = object.displayOrder >>> 0;
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a Benefit message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof Benefit
+     * @static
+     * @param {Benefit} message Benefit
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    Benefit.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults) {
+            object.title = "";
+            object.description = "";
+            object.emoji = "";
+            object.displayOrder = 0;
+        }
+        if (message.title != null && message.hasOwnProperty("title"))
+            object.title = message.title;
+        if (message.description != null && message.hasOwnProperty("description"))
+            object.description = message.description;
+        if (message.emoji != null && message.hasOwnProperty("emoji"))
+            object.emoji = message.emoji;
+        if (message.displayOrder != null && message.hasOwnProperty("displayOrder"))
+            object.displayOrder = message.displayOrder;
+        return object;
+    };
+
+    /**
+     * Converts this Benefit to JSON.
+     * @function toJSON
+     * @memberof Benefit
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    Benefit.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return Benefit;
+})();
+
+$root.SaleMetadata = (function() {
+
+    /**
+     * Properties of a SaleMetadata.
+     * @exports ISaleMetadata
+     * @interface ISaleMetadata
+     * @property {string|null} [termsAndConditions] SaleMetadata termsAndConditions
+     */
+
+    /**
+     * Constructs a new SaleMetadata.
+     * @exports SaleMetadata
+     * @classdesc Represents a SaleMetadata.
+     * @implements ISaleMetadata
+     * @constructor
+     * @param {ISaleMetadata=} [properties] Properties to set
+     */
+    function SaleMetadata(properties) {
+        if (properties)
+            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
+                if (properties[keys[i]] != null)
+                    this[keys[i]] = properties[keys[i]];
+    }
+
+    /**
+     * SaleMetadata termsAndConditions.
+     * @member {string} termsAndConditions
+     * @memberof SaleMetadata
+     * @instance
+     */
+    SaleMetadata.prototype.termsAndConditions = "";
+
+    /**
+     * Creates a new SaleMetadata instance using the specified properties.
+     * @function create
+     * @memberof SaleMetadata
+     * @static
+     * @param {ISaleMetadata=} [properties] Properties to set
+     * @returns {SaleMetadata} SaleMetadata instance
+     */
+    SaleMetadata.create = function create(properties) {
+        return new SaleMetadata(properties);
+    };
+
+    /**
+     * Encodes the specified SaleMetadata message. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @function encode
+     * @memberof SaleMetadata
+     * @static
+     * @param {ISaleMetadata} message SaleMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SaleMetadata.encode = function encode(message, writer) {
+        if (!writer)
+            writer = $Writer.create();
+        if (message.termsAndConditions != null && Object.hasOwnProperty.call(message, "termsAndConditions"))
+            writer.uint32(/* id 1, wireType 2 =*/10).string(message.termsAndConditions);
+        return writer;
+    };
+
+    /**
+     * Encodes the specified SaleMetadata message, length delimited. Does not implicitly {@link SaleMetadata.verify|verify} messages.
+     * @function encodeDelimited
+     * @memberof SaleMetadata
+     * @static
+     * @param {ISaleMetadata} message SaleMetadata message or plain object to encode
+     * @param {$protobuf.Writer} [writer] Writer to encode to
+     * @returns {$protobuf.Writer} Writer
+     */
+    SaleMetadata.encodeDelimited = function encodeDelimited(message, writer) {
+        return this.encode(message, writer).ldelim();
+    };
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer.
+     * @function decode
+     * @memberof SaleMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @param {number} [length] Message length if known beforehand
+     * @returns {SaleMetadata} SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SaleMetadata.decode = function decode(reader, length) {
+        if (!(reader instanceof $Reader))
+            reader = $Reader.create(reader);
+        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SaleMetadata();
+        while (reader.pos < end) {
+            var tag = reader.uint32();
+            switch (tag >>> 3) {
+            case 1:
+                message.termsAndConditions = reader.string();
+                break;
+            default:
+                reader.skipType(tag & 7);
+                break;
+            }
+        }
+        return message;
+    };
+
+    /**
+     * Decodes a SaleMetadata message from the specified reader or buffer, length delimited.
+     * @function decodeDelimited
+     * @memberof SaleMetadata
+     * @static
+     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
+     * @returns {SaleMetadata} SaleMetadata
+     * @throws {Error} If the payload is not a reader or valid buffer
+     * @throws {$protobuf.util.ProtocolError} If required fields are missing
+     */
+    SaleMetadata.decodeDelimited = function decodeDelimited(reader) {
+        if (!(reader instanceof $Reader))
+            reader = new $Reader(reader);
+        return this.decode(reader, reader.uint32());
+    };
+
+    /**
+     * Verifies a SaleMetadata message.
+     * @function verify
+     * @memberof SaleMetadata
+     * @static
+     * @param {Object.<string,*>} message Plain object to verify
+     * @returns {string|null} `null` if valid, otherwise the reason why it is not
+     */
+    SaleMetadata.verify = function verify(message) {
+        if (typeof message !== "object" || message === null)
+            return "object expected";
+        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
+            if (!$util.isString(message.termsAndConditions))
+                return "termsAndConditions: string expected";
+        return null;
+    };
+
+    /**
+     * Creates a SaleMetadata message from a plain object. Also converts values to their respective internal types.
+     * @function fromObject
+     * @memberof SaleMetadata
+     * @static
+     * @param {Object.<string,*>} object Plain object
+     * @returns {SaleMetadata} SaleMetadata
+     */
+    SaleMetadata.fromObject = function fromObject(object) {
+        if (object instanceof $root.SaleMetadata)
+            return object;
+        var message = new $root.SaleMetadata();
+        if (object.termsAndConditions != null)
+            message.termsAndConditions = String(object.termsAndConditions);
+        return message;
+    };
+
+    /**
+     * Creates a plain object from a SaleMetadata message. Also converts values to other types if specified.
+     * @function toObject
+     * @memberof SaleMetadata
+     * @static
+     * @param {SaleMetadata} message SaleMetadata
+     * @param {$protobuf.IConversionOptions} [options] Conversion options
+     * @returns {Object.<string,*>} Plain object
+     */
+    SaleMetadata.toObject = function toObject(message, options) {
+        if (!options)
+            options = {};
+        var object = {};
+        if (options.defaults)
+            object.termsAndConditions = "";
+        if (message.termsAndConditions != null && message.hasOwnProperty("termsAndConditions"))
+            object.termsAndConditions = message.termsAndConditions;
+        return object;
+    };
+
+    /**
+     * Converts this SaleMetadata to JSON.
+     * @function toJSON
+     * @memberof SaleMetadata
+     * @instance
+     * @returns {Object.<string,*>} JSON object
+     */
+    SaleMetadata.prototype.toJSON = function toJSON() {
+        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
+    };
+
+    return SaleMetadata;
+})();
+
 $root.PublishedBeforeJoystream = (function() {
 
     /**
diff --git a/node_modules/@joystream/metadata-protobuf/doc-appendix.md b/node_modules/@joystream/metadata-protobuf/doc-appendix.md
new file mode 100644
index 0000000..b07cf18
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/doc-appendix.md
@@ -0,0 +1,41 @@
+<!-- 
+    This extra documentation will be appended to the generated docs.
+-->
+
+## Referencing Assets
+<a name=".Assets"></a>
+
+Applications that process messages that contain a `uint32` field that references an asset such as a cover photo or video, should interpret this value as a zero based index into an array/vector that is received external (out of band) to the protobuf message.
+
+Example in context of query-node processing the runtime event `VideoCreated`
+
+```rust
+// Runtime event associated with creating a Video
+VideoCreated(video_id: VideoId, video: Video, assets: Vec<NewAsset>, params: VideoCreationParameters)
+
+struct VideoCreationParameters {
+  in_category: VideoCategoryId,
+  // binary serialized VideoMetadata protobuf message
+  meta: Vec<u8>,
+}
+
+// suppose assets is a vector of two elements. This is the "out of band" array being referenced by the VideoMetadata message
+assets = [
+    NewAsset::Uri("https://mydomain.net/thumbnail.png"),
+    NewAsset::Upload({
+       content_id,
+       ipfs_hash,
+       size,
+       ...
+    }),
+];
+
+meta = VideoMetadata {
+    ...
+    // refers to second element: assets[1] which is being uploaded to the storage system
+    video: 1,
+    // refers to the first element assets[0] which is being referneced by a url string.
+    thumbnail_photo: 0,
+    ...
+};
+```
\ No newline at end of file
diff --git a/node_modules/@joystream/metadata-protobuf/generate-md-doc.sh b/node_modules/@joystream/metadata-protobuf/generate-md-doc.sh
new file mode 100755
index 0000000..46b521b
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/generate-md-doc.sh
@@ -0,0 +1,13 @@
+#!/usr/bin/env bash
+
+# Directory to write generated documentation to
+OUT_DIR_DOC="./doc"
+mkdir -p ${OUT_DIR_DOC}
+
+# Gernerate Markdown docs
+protoc \
+    --doc_out="${OUT_DIR_DOC}" --doc_opt=markdown,index.md \
+    proto/*.proto
+
+# Append some custom docs to generated protocol docs
+cat doc-appendix.md >> ${OUT_DIR_DOC}/index.md
diff --git a/node_modules/@joystream/metadata-protobuf/lib/json/index.d.ts b/node_modules/@joystream/metadata-protobuf/lib/json/index.d.ts
new file mode 100644
index 0000000..76f77af
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/lib/json/index.d.ts
@@ -0,0 +1,2 @@
+import { nested } from './messages.json';
+export default nested;
diff --git a/node_modules/@joystream/metadata-protobuf/lib/json/index.js b/node_modules/@joystream/metadata-protobuf/lib/json/index.js
new file mode 100644
index 0000000..f8ced4e
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/lib/json/index.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const messages_json_1 = require("./messages.json");
+exports.default = messages_json_1.nested;
diff --git a/node_modules/@joystream/metadata-protobuf/lib/json/messages.json b/node_modules/@joystream/metadata-protobuf/lib/json/messages.json
new file mode 100644
index 0000000..479c647
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/lib/json/messages.json
@@ -0,0 +1,1348 @@
+{
+    "nested": {
+        "AppActionMetadata": {
+            "fields": {
+                "videoId": {
+                    "type": "string",
+                    "id": 2
+                }
+            }
+        },
+        "AppAction": {
+            "fields": {
+                "appId": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 999
+                },
+                "metadata": {
+                    "type": "bytes",
+                    "id": 2
+                },
+                "rawAction": {
+                    "type": "bytes",
+                    "id": 3
+                },
+                "signature": {
+                    "type": "bytes",
+                    "id": 4
+                }
+            },
+            "nested": {
+                "ActionType": {
+                    "values": {
+                        "CREATE_VIDEO": 0,
+                        "CREATE_CHANNEL": 1
+                    }
+                },
+                "CreatorType": {
+                    "values": {
+                        "CHANNEL": 0,
+                        "MEMBER": 1,
+                        "CURATOR_GROUP": 2
+                    }
+                }
+            }
+        },
+        "BountyMetadata": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "discussionThread": {
+                    "type": "uint64",
+                    "id": 3
+                },
+                "bannerImageUri": {
+                    "type": "string",
+                    "id": 4
+                }
+            }
+        },
+        "BountyWorkData": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                }
+            }
+        },
+        "ChannelMetadata": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "isPublic": {
+                    "type": "bool",
+                    "id": 3
+                },
+                "language": {
+                    "type": "string",
+                    "id": 4
+                },
+                "coverPhoto": {
+                    "type": "uint32",
+                    "id": 5
+                },
+                "avatarPhoto": {
+                    "type": "uint32",
+                    "id": 6
+                }
+            }
+        },
+        "ChannelPayoutsMetadata": {
+            "fields": {
+                "header": {
+                    "rule": "required",
+                    "type": "Header",
+                    "id": 1
+                },
+                "body": {
+                    "rule": "required",
+                    "type": "Body",
+                    "id": 2
+                }
+            },
+            "nested": {
+                "Header": {
+                    "fields": {
+                        "payloadLengthInBytes": {
+                            "rule": "required",
+                            "type": "fixed64",
+                            "id": 1
+                        },
+                        "headerLengthInBytes": {
+                            "rule": "required",
+                            "type": "fixed64",
+                            "id": 2
+                        },
+                        "numberOfChannels": {
+                            "rule": "required",
+                            "type": "fixed32",
+                            "id": 3
+                        },
+                        "channelPayoutByteOffsets": {
+                            "rule": "repeated",
+                            "type": "ChannelPayoutByteOffset",
+                            "id": 4
+                        }
+                    },
+                    "nested": {
+                        "ChannelPayoutByteOffset": {
+                            "fields": {
+                                "channelId": {
+                                    "rule": "required",
+                                    "type": "fixed32",
+                                    "id": 1
+                                },
+                                "byteOffset": {
+                                    "rule": "required",
+                                    "type": "fixed64",
+                                    "id": 2
+                                }
+                            }
+                        }
+                    }
+                },
+                "Body": {
+                    "fields": {
+                        "channelPayouts": {
+                            "rule": "repeated",
+                            "type": "ChannelPayoutProof",
+                            "id": 1
+                        }
+                    },
+                    "nested": {
+                        "ChannelPayoutProof": {
+                            "fields": {
+                                "channelId": {
+                                    "rule": "required",
+                                    "type": "uint32",
+                                    "id": 1
+                                },
+                                "cumulativeRewardEarned": {
+                                    "rule": "required",
+                                    "type": "string",
+                                    "id": 2
+                                },
+                                "merkleBranch": {
+                                    "rule": "repeated",
+                                    "type": "ProofElement",
+                                    "id": 3
+                                },
+                                "reason": {
+                                    "rule": "required",
+                                    "type": "string",
+                                    "id": 4
+                                }
+                            },
+                            "nested": {
+                                "Side": {
+                                    "values": {
+                                        "Left": 0,
+                                        "Right": 1
+                                    }
+                                },
+                                "ProofElement": {
+                                    "fields": {
+                                        "hash": {
+                                            "rule": "required",
+                                            "type": "string",
+                                            "id": 1
+                                        },
+                                        "side": {
+                                            "rule": "required",
+                                            "type": "Side",
+                                            "id": 2
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "CouncilCandidacyNoteMetadata": {
+            "fields": {
+                "header": {
+                    "type": "string",
+                    "id": 1
+                },
+                "bulletPoints": {
+                    "rule": "repeated",
+                    "type": "string",
+                    "id": 2
+                },
+                "bannerImageUri": {
+                    "type": "string",
+                    "id": 3
+                },
+                "description": {
+                    "type": "string",
+                    "id": 4
+                }
+            }
+        },
+        "ForumPostMetadata": {
+            "fields": {
+                "text": {
+                    "type": "string",
+                    "id": 1
+                },
+                "repliesTo": {
+                    "type": "uint32",
+                    "id": 2
+                }
+            }
+        },
+        "ForumThreadMetadata": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "tags": {
+                    "rule": "repeated",
+                    "type": "string",
+                    "id": 2
+                }
+            }
+        },
+        "MembershipMetadata": {
+            "oneofs": {
+                "avatar": {
+                    "oneof": [
+                        "avatarObject",
+                        "avatarUri"
+                    ]
+                }
+            },
+            "fields": {
+                "name": {
+                    "type": "string",
+                    "id": 1
+                },
+                "avatarObject": {
+                    "type": "uint32",
+                    "id": 2
+                },
+                "avatarUri": {
+                    "type": "string",
+                    "id": 4
+                },
+                "about": {
+                    "type": "string",
+                    "id": 3
+                },
+                "externalResources": {
+                    "rule": "repeated",
+                    "type": "ExternalResource",
+                    "id": 5
+                }
+            },
+            "nested": {
+                "ExternalResource": {
+                    "fields": {
+                        "type": {
+                            "type": "ResourceType",
+                            "id": 1
+                        },
+                        "value": {
+                            "type": "string",
+                            "id": 2
+                        }
+                    },
+                    "nested": {
+                        "ResourceType": {
+                            "values": {
+                                "EMAIL": 0,
+                                "HYPERLINK": 1,
+                                "TWITTER": 2,
+                                "TELEGRAM": 3,
+                                "DISCORD": 4,
+                                "FACEBOOK": 5,
+                                "YOUTUBE": 6,
+                                "MATRIX": 7,
+                                "IRC": 8,
+                                "WECHAT": 9,
+                                "WHATSAPP": 10
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "ReactVideo": {
+            "fields": {
+                "videoId": {
+                    "rule": "required",
+                    "type": "uint64",
+                    "id": 1
+                },
+                "reaction": {
+                    "rule": "required",
+                    "type": "Reaction",
+                    "id": 2
+                }
+            },
+            "nested": {
+                "Reaction": {
+                    "values": {
+                        "LIKE": 0,
+                        "UNLIKE": 1
+                    }
+                }
+            }
+        },
+        "ReactComment": {
+            "fields": {
+                "commentId": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                },
+                "reactionId": {
+                    "rule": "required",
+                    "type": "uint32",
+                    "id": 2
+                }
+            }
+        },
+        "CreateComment": {
+            "fields": {
+                "videoId": {
+                    "rule": "required",
+                    "type": "uint64",
+                    "id": 1
+                },
+                "parentCommentId": {
+                    "type": "string",
+                    "id": 2
+                },
+                "body": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 3
+                }
+            }
+        },
+        "EditComment": {
+            "fields": {
+                "commentId": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                },
+                "newBody": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 2
+                }
+            }
+        },
+        "DeleteComment": {
+            "fields": {
+                "commentId": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                }
+            }
+        },
+        "PinOrUnpinComment": {
+            "fields": {
+                "videoId": {
+                    "rule": "required",
+                    "type": "uint64",
+                    "id": 1
+                },
+                "commentId": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 2
+                },
+                "option": {
+                    "rule": "required",
+                    "type": "Option",
+                    "id": 3
+                }
+            },
+            "nested": {
+                "Option": {
+                    "values": {
+                        "PIN": 0,
+                        "UNPIN": 1
+                    }
+                }
+            }
+        },
+        "ModerateComment": {
+            "fields": {
+                "commentId": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                },
+                "rationale": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 2
+                }
+            }
+        },
+        "BanOrUnbanMemberFromChannel": {
+            "fields": {
+                "memberId": {
+                    "rule": "required",
+                    "type": "uint64",
+                    "id": 1
+                },
+                "option": {
+                    "rule": "required",
+                    "type": "Option",
+                    "id": 2
+                }
+            },
+            "nested": {
+                "Option": {
+                    "values": {
+                        "BAN": 0,
+                        "UNBAN": 1
+                    }
+                }
+            }
+        },
+        "VideoReactionsPreference": {
+            "fields": {
+                "videoId": {
+                    "rule": "required",
+                    "type": "uint64",
+                    "id": 1
+                },
+                "option": {
+                    "rule": "required",
+                    "type": "Option",
+                    "id": 2
+                }
+            },
+            "nested": {
+                "Option": {
+                    "values": {
+                        "ENABLE": 0,
+                        "DISABLE": 1
+                    }
+                }
+            }
+        },
+        "CreateVideoCategory": {
+            "fields": {
+                "name": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "parentCategoryId": {
+                    "type": "string",
+                    "id": 3
+                }
+            }
+        },
+        "MakeChannelPayment": {
+            "oneofs": {
+                "paymentContext": {
+                    "oneof": [
+                        "videoId"
+                    ]
+                }
+            },
+            "fields": {
+                "rationale": {
+                    "type": "string",
+                    "id": 1
+                },
+                "videoId": {
+                    "type": "uint64",
+                    "id": 2
+                }
+            }
+        },
+        "AppMetadata": {
+            "fields": {
+                "websiteUrl": {
+                    "type": "string",
+                    "id": 2
+                },
+                "useUri": {
+                    "type": "string",
+                    "id": 3
+                },
+                "smallIcon": {
+                    "type": "string",
+                    "id": 4
+                },
+                "mediumIcon": {
+                    "type": "string",
+                    "id": 5
+                },
+                "bigIcon": {
+                    "type": "string",
+                    "id": 6
+                },
+                "oneLiner": {
+                    "type": "string",
+                    "id": 7
+                },
+                "description": {
+                    "type": "string",
+                    "id": 8
+                },
+                "termsOfService": {
+                    "type": "string",
+                    "id": 9
+                },
+                "authKey": {
+                    "type": "string",
+                    "id": 10
+                },
+                "platforms": {
+                    "rule": "repeated",
+                    "type": "string",
+                    "id": 11
+                },
+                "category": {
+                    "type": "string",
+                    "id": 12
+                }
+            }
+        },
+        "CreateApp": {
+            "fields": {
+                "name": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                },
+                "appMetadata": {
+                    "type": "AppMetadata",
+                    "id": 2
+                }
+            }
+        },
+        "UpdateApp": {
+            "fields": {
+                "appId": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                },
+                "appMetadata": {
+                    "type": "AppMetadata",
+                    "id": 2
+                }
+            }
+        },
+        "MemberRemarked": {
+            "oneofs": {
+                "memberRemarked": {
+                    "oneof": [
+                        "reactVideo",
+                        "reactComment",
+                        "createComment",
+                        "editComment",
+                        "deleteComment",
+                        "createVideoCategory",
+                        "createApp",
+                        "updateApp",
+                        "makeChannelPayment"
+                    ]
+                }
+            },
+            "fields": {
+                "reactVideo": {
+                    "type": "ReactVideo",
+                    "id": 1
+                },
+                "reactComment": {
+                    "type": "ReactComment",
+                    "id": 2
+                },
+                "createComment": {
+                    "type": "CreateComment",
+                    "id": 3
+                },
+                "editComment": {
+                    "type": "EditComment",
+                    "id": 4
+                },
+                "deleteComment": {
+                    "type": "DeleteComment",
+                    "id": 5
+                },
+                "createVideoCategory": {
+                    "type": "CreateVideoCategory",
+                    "id": 6
+                },
+                "createApp": {
+                    "type": "CreateApp",
+                    "id": 7
+                },
+                "updateApp": {
+                    "type": "UpdateApp",
+                    "id": 8
+                },
+                "makeChannelPayment": {
+                    "type": "MakeChannelPayment",
+                    "id": 10
+                }
+            }
+        },
+        "ChannelModeratorRemarked": {
+            "oneofs": {
+                "channelModeratorRemarked": {
+                    "oneof": [
+                        "moderateComment"
+                    ]
+                }
+            },
+            "fields": {
+                "moderateComment": {
+                    "type": "ModerateComment",
+                    "id": 1
+                }
+            }
+        },
+        "ChannelOwnerRemarked": {
+            "oneofs": {
+                "channelOwnerRemarked": {
+                    "oneof": [
+                        "pinOrUnpinComment",
+                        "banOrUnbanMemberFromChannel",
+                        "videoReactionsPreference",
+                        "moderateComment"
+                    ]
+                }
+            },
+            "fields": {
+                "pinOrUnpinComment": {
+                    "type": "PinOrUnpinComment",
+                    "id": 1
+                },
+                "banOrUnbanMemberFromChannel": {
+                    "type": "BanOrUnbanMemberFromChannel",
+                    "id": 2
+                },
+                "videoReactionsPreference": {
+                    "type": "VideoReactionsPreference",
+                    "id": 3
+                },
+                "moderateComment": {
+                    "type": "ModerateComment",
+                    "id": 5
+                }
+            }
+        },
+        "PersonMetadata": {
+            "fields": {
+                "firstName": {
+                    "type": "string",
+                    "id": 1
+                },
+                "middleName": {
+                    "type": "string",
+                    "id": 2
+                },
+                "lastName": {
+                    "type": "string",
+                    "id": 3
+                },
+                "about": {
+                    "type": "string",
+                    "id": 4
+                },
+                "coverPhoto": {
+                    "type": "uint32",
+                    "id": 5
+                },
+                "avatarPhoto": {
+                    "type": "uint32",
+                    "id": 6
+                }
+            }
+        },
+        "ProposalsDiscussionPostMetadata": {
+            "fields": {
+                "text": {
+                    "type": "string",
+                    "id": 1
+                },
+                "repliesTo": {
+                    "type": "uint32",
+                    "id": 2
+                }
+            }
+        },
+        "SeriesMetadata": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "coverPhoto": {
+                    "type": "uint32",
+                    "id": 3
+                },
+                "persons": {
+                    "rule": "repeated",
+                    "type": "uint64",
+                    "id": 4
+                }
+            }
+        },
+        "SeasonMetadata": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "coverPhoto": {
+                    "type": "uint32",
+                    "id": 3
+                },
+                "persons": {
+                    "rule": "repeated",
+                    "type": "uint64",
+                    "id": 4
+                }
+            }
+        },
+        "GeoCoordiantes": {
+            "fields": {
+                "latitude": {
+                    "type": "float",
+                    "id": 3
+                },
+                "longitude": {
+                    "type": "float",
+                    "id": 4
+                }
+            }
+        },
+        "NodeLocationMetadata": {
+            "fields": {
+                "countryCode": {
+                    "type": "string",
+                    "id": 1
+                },
+                "city": {
+                    "type": "string",
+                    "id": 2
+                },
+                "coordinates": {
+                    "type": "GeoCoordiantes",
+                    "id": 3
+                }
+            }
+        },
+        "StorageBucketOperatorMetadata": {
+            "fields": {
+                "endpoint": {
+                    "type": "string",
+                    "id": 1
+                },
+                "location": {
+                    "type": "NodeLocationMetadata",
+                    "id": 2
+                },
+                "extra": {
+                    "type": "string",
+                    "id": 3
+                }
+            }
+        },
+        "DistributionBucketOperatorMetadata": {
+            "fields": {
+                "endpoint": {
+                    "type": "string",
+                    "id": 1
+                },
+                "location": {
+                    "type": "NodeLocationMetadata",
+                    "id": 2
+                },
+                "extra": {
+                    "type": "string",
+                    "id": 3
+                }
+            }
+        },
+        "GeographicalArea": {
+            "oneofs": {
+                "code": {
+                    "oneof": [
+                        "continent",
+                        "countryCode",
+                        "subdivisionCode"
+                    ]
+                }
+            },
+            "fields": {
+                "continent": {
+                    "type": "Continent",
+                    "id": 1
+                },
+                "countryCode": {
+                    "type": "string",
+                    "id": 2
+                },
+                "subdivisionCode": {
+                    "type": "string",
+                    "id": 3
+                }
+            },
+            "nested": {
+                "Continent": {
+                    "values": {
+                        "AF": 1,
+                        "NA": 2,
+                        "OC": 3,
+                        "AN": 4,
+                        "AS": 5,
+                        "EU": 6,
+                        "SA": 7
+                    }
+                }
+            }
+        },
+        "DistributionBucketFamilyMetadata": {
+            "fields": {
+                "region": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "areas": {
+                    "rule": "repeated",
+                    "type": "GeographicalArea",
+                    "id": 3
+                },
+                "latencyTestTargets": {
+                    "rule": "repeated",
+                    "type": "string",
+                    "id": 4
+                }
+            }
+        },
+        "CreatorTokenIssuerRemarked": {
+            "oneofs": {
+                "creatorTokenIssuerRemarked": {
+                    "oneof": [
+                        "updateTokenMetadata"
+                    ]
+                }
+            },
+            "fields": {
+                "updateTokenMetadata": {
+                    "type": "UpdateTokenMetadata",
+                    "id": 1
+                }
+            }
+        },
+        "UpdateTokenMetadata": {
+            "fields": {
+                "newMetadata": {
+                    "type": "TokenMetadata",
+                    "id": 1
+                }
+            }
+        },
+        "TokenMetadata": {
+            "oneofs": {
+                "avatar": {
+                    "oneof": [
+                        "avatarObject",
+                        "avatarUri"
+                    ]
+                }
+            },
+            "fields": {
+                "name": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "avatarObject": {
+                    "type": "uint32",
+                    "id": 3
+                },
+                "avatarUri": {
+                    "type": "string",
+                    "id": 4
+                },
+                "benefits": {
+                    "rule": "repeated",
+                    "type": "Benefit",
+                    "id": 5
+                },
+                "whitelistApplicationNote": {
+                    "type": "string",
+                    "id": 6
+                },
+                "whitelistApplicationApplyLink": {
+                    "type": "string",
+                    "id": 7
+                },
+                "trailerVideoId": {
+                    "type": "uint64",
+                    "id": 8
+                }
+            }
+        },
+        "Benefit": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "emoji": {
+                    "type": "string",
+                    "id": 3
+                },
+                "displayOrder": {
+                    "type": "uint32",
+                    "id": 4
+                }
+            }
+        },
+        "SaleMetadata": {
+            "fields": {
+                "termsAndConditions": {
+                    "type": "string",
+                    "id": 1
+                }
+            }
+        },
+        "PublishedBeforeJoystream": {
+            "fields": {
+                "isPublished": {
+                    "type": "bool",
+                    "id": 1
+                },
+                "date": {
+                    "type": "string",
+                    "id": 2
+                }
+            }
+        },
+        "License": {
+            "fields": {
+                "code": {
+                    "type": "uint32",
+                    "id": 1
+                },
+                "attribution": {
+                    "type": "string",
+                    "id": 2
+                },
+                "customText": {
+                    "type": "string",
+                    "id": 3
+                }
+            }
+        },
+        "MediaType": {
+            "fields": {
+                "codecName": {
+                    "type": "string",
+                    "id": 1
+                },
+                "container": {
+                    "type": "string",
+                    "id": 2
+                },
+                "mimeMediaType": {
+                    "type": "string",
+                    "id": 3
+                }
+            }
+        },
+        "SubtitleMetadata": {
+            "fields": {
+                "type": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 1
+                },
+                "newAsset": {
+                    "type": "uint32",
+                    "id": 2
+                },
+                "language": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 3
+                },
+                "mimeType": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 4
+                }
+            }
+        },
+        "VideoMetadata": {
+            "fields": {
+                "title": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "video": {
+                    "type": "uint32",
+                    "id": 3
+                },
+                "thumbnailPhoto": {
+                    "type": "uint32",
+                    "id": 4
+                },
+                "duration": {
+                    "type": "uint32",
+                    "id": 5
+                },
+                "mediaPixelHeight": {
+                    "type": "uint32",
+                    "id": 6
+                },
+                "mediaPixelWidth": {
+                    "type": "uint32",
+                    "id": 7
+                },
+                "mediaType": {
+                    "type": "MediaType",
+                    "id": 8
+                },
+                "language": {
+                    "type": "string",
+                    "id": 9
+                },
+                "license": {
+                    "type": "License",
+                    "id": 10
+                },
+                "publishedBeforeJoystream": {
+                    "type": "PublishedBeforeJoystream",
+                    "id": 11
+                },
+                "hasMarketing": {
+                    "type": "bool",
+                    "id": 12
+                },
+                "isPublic": {
+                    "type": "bool",
+                    "id": 13
+                },
+                "isExplicit": {
+                    "type": "bool",
+                    "id": 14
+                },
+                "persons": {
+                    "rule": "repeated",
+                    "type": "uint64",
+                    "id": 15
+                },
+                "category": {
+                    "type": "string",
+                    "id": 16
+                },
+                "subtitles": {
+                    "rule": "repeated",
+                    "type": "SubtitleMetadata",
+                    "id": 17
+                },
+                "enableComments": {
+                    "type": "bool",
+                    "id": 18
+                },
+                "clearSubtitles": {
+                    "type": "bool",
+                    "id": 19
+                }
+            }
+        },
+        "ContentMetadata": {
+            "oneofs": {
+                "contentMetadata": {
+                    "oneof": [
+                        "videoMetadata"
+                    ]
+                }
+            },
+            "fields": {
+                "videoMetadata": {
+                    "type": "VideoMetadata",
+                    "id": 1
+                }
+            }
+        },
+        "OpeningMetadata": {
+            "fields": {
+                "shortDescription": {
+                    "type": "string",
+                    "id": 1
+                },
+                "description": {
+                    "type": "string",
+                    "id": 2
+                },
+                "hiringLimit": {
+                    "type": "uint32",
+                    "id": 3
+                },
+                "expectedEndingTimestamp": {
+                    "type": "uint32",
+                    "id": 4
+                },
+                "applicationDetails": {
+                    "type": "string",
+                    "id": 5
+                },
+                "applicationFormQuestions": {
+                    "rule": "repeated",
+                    "type": "ApplicationFormQuestion",
+                    "id": 6
+                },
+                "title": {
+                    "type": "string",
+                    "id": 7
+                }
+            },
+            "nested": {
+                "ApplicationFormQuestion": {
+                    "fields": {
+                        "question": {
+                            "type": "string",
+                            "id": 1
+                        },
+                        "type": {
+                            "type": "InputType",
+                            "id": 2
+                        }
+                    },
+                    "nested": {
+                        "InputType": {
+                            "values": {
+                                "TEXTAREA": 0,
+                                "TEXT": 1
+                            }
+                        }
+                    }
+                }
+            }
+        },
+        "UpcomingOpeningMetadata": {
+            "fields": {
+                "expectedStart": {
+                    "type": "uint32",
+                    "id": 1
+                },
+                "rewardPerBlock": {
+                    "type": "uint64",
+                    "id": 2
+                },
+                "minApplicationStake": {
+                    "type": "uint64",
+                    "id": 3
+                },
+                "metadata": {
+                    "type": "OpeningMetadata",
+                    "id": 4
+                }
+            }
+        },
+        "ApplicationMetadata": {
+            "fields": {
+                "answers": {
+                    "rule": "repeated",
+                    "type": "string",
+                    "id": 1
+                }
+            }
+        },
+        "WorkingGroupMetadata": {
+            "fields": {
+                "description": {
+                    "type": "string",
+                    "id": 1
+                },
+                "about": {
+                    "type": "string",
+                    "id": 2
+                },
+                "status": {
+                    "type": "string",
+                    "id": 3
+                },
+                "statusMessage": {
+                    "type": "string",
+                    "id": 4
+                }
+            }
+        },
+        "SetGroupMetadata": {
+            "fields": {
+                "newMetadata": {
+                    "type": "WorkingGroupMetadata",
+                    "id": 1
+                }
+            }
+        },
+        "AddUpcomingOpening": {
+            "fields": {
+                "metadata": {
+                    "type": "UpcomingOpeningMetadata",
+                    "id": 1
+                }
+            }
+        },
+        "RemoveUpcomingOpening": {
+            "fields": {
+                "id": {
+                    "type": "string",
+                    "id": 1
+                }
+            }
+        },
+        "WorkingGroupMetadataAction": {
+            "oneofs": {
+                "action": {
+                    "oneof": [
+                        "setGroupMetadata",
+                        "addUpcomingOpening",
+                        "removeUpcomingOpening"
+                    ]
+                }
+            },
+            "fields": {
+                "setGroupMetadata": {
+                    "type": "SetGroupMetadata",
+                    "id": 1
+                },
+                "addUpcomingOpening": {
+                    "type": "AddUpcomingOpening",
+                    "id": 2
+                },
+                "removeUpcomingOpening": {
+                    "type": "RemoveUpcomingOpening",
+                    "id": 3
+                }
+            }
+        },
+        "ModeratePost": {
+            "fields": {
+                "postId": {
+                    "rule": "required",
+                    "type": "uint64",
+                    "id": 1
+                },
+                "rationale": {
+                    "rule": "required",
+                    "type": "string",
+                    "id": 2
+                }
+            }
+        },
+        "RemarkMetadataAction": {
+            "oneofs": {
+                "action": {
+                    "oneof": [
+                        "moderatePost"
+                    ]
+                }
+            },
+            "fields": {
+                "moderatePost": {
+                    "type": "ModeratePost",
+                    "id": 1
+                }
+            }
+        }
+    }
+}
diff --git a/node_modules/@joystream/metadata-protobuf/lib/types.d.ts b/node_modules/@joystream/metadata-protobuf/lib/types.d.ts
index 79612c9..dd7db96 100644
--- a/node_modules/@joystream/metadata-protobuf/lib/types.d.ts
+++ b/node_modules/@joystream/metadata-protobuf/lib/types.d.ts
@@ -4,6 +4,7 @@ export declare type AnyMessage<T> = T & {
     toJSON(): Record<string, unknown>;
 };
 export declare type AnyMetadataClass<T> = {
+    new (): T;
     name: string;
     decode(binary: Uint8Array): AnyMessage<T>;
     encode(obj: T): {
diff --git a/node_modules/@joystream/metadata-protobuf/proto/Token.proto b/node_modules/@joystream/metadata-protobuf/proto/Token.proto
new file mode 100644
index 0000000..19832e8
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/proto/Token.proto
@@ -0,0 +1,34 @@
+syntax = "proto2";
+message CreatorTokenIssuerRemarked {
+    oneof creator_token_issuer_remarked {
+        UpdateTokenMetadata update_token_metadata = 1;
+    }
+}
+
+message UpdateTokenMetadata {
+    optional TokenMetadata new_metadata = 1;
+}
+
+message TokenMetadata {
+  optional string name = 1; // Title
+  optional string description = 2; // token description
+  oneof avatar {
+    uint32 avatar_object = 3; // avatar for token - index into external [assets array](#.Assets)
+    string avatar_uri = 4; // Url to member's avatar
+  }
+  repeated Benefit benefits = 5; // benefits for tokne
+  optional string whitelist_application_note = 6; // note for applicant
+  optional string whitelist_application_apply_link = 7; // link to application process
+  optional uint64 trailer_video_id = 8; // runtime id for video trailer
+}
+
+message Benefit {
+  optional string title = 1;
+  optional string description = 2;
+  optional string emoji = 3;
+  optional uint32 display_order = 4;
+}
+
+message SaleMetadata {
+  optional string terms_and_conditions = 1;
+}
diff --git a/node_modules/@joystream/metadata-protobuf/scripts/compile.ts b/node_modules/@joystream/metadata-protobuf/scripts/compile.ts
new file mode 100644
index 0000000..09056e1
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/scripts/compile.ts
@@ -0,0 +1,44 @@
+import { main as pbjs } from 'protobufjs/cli/pbjs'
+import { main as pbts } from 'protobufjs/cli/pbts'
+import path from 'path'
+import fs from 'fs'
+
+const MODULE_OUT_DIR = path.resolve(__dirname, '../compiled')
+const JSON_OUT_DIR = path.resolve(__dirname, '../src/json')
+
+if (!fs.existsSync(MODULE_OUT_DIR)) {
+  fs.mkdirSync(MODULE_OUT_DIR)
+}
+
+if (!fs.existsSync(JSON_OUT_DIR)) {
+  fs.mkdirSync(JSON_OUT_DIR)
+}
+
+pbjs(
+  ['--target', 'static-module', '-w', 'commonjs', '-o', `${MODULE_OUT_DIR}/index.js`, '--force-long', 'proto/*.proto'],
+  function (err) {
+    if (err) {
+      throw err
+    }
+    console.log(`${MODULE_OUT_DIR}/index.js updated`)
+  }
+)
+
+pbjs(['--target', 'json', '-o', `${JSON_OUT_DIR}/messages.json`, '--force-long', 'proto/*.proto'], function (err) {
+  if (err) {
+    throw err
+  }
+  console.log(`${JSON_OUT_DIR}/messages.json updated`)
+})
+
+pbts([`${MODULE_OUT_DIR}/*.js`], function (err, output) {
+  if (err) {
+    throw err
+  }
+  // Fix missing Long import
+  output = `import { Long } from 'long'\n${output}`
+
+  fs.writeFileSync(`${MODULE_OUT_DIR}/index.d.ts`, output)
+
+  console.log(`${MODULE_OUT_DIR}/index.d.ts updated`)
+})
diff --git a/node_modules/@joystream/metadata-protobuf/scripts/tsconfig.json b/node_modules/@joystream/metadata-protobuf/scripts/tsconfig.json
new file mode 100644
index 0000000..8ea7ca9
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/scripts/tsconfig.json
@@ -0,0 +1,11 @@
+{
+  "compilerOptions": {
+    "noEmit": true,
+    "strict": true,
+    "esModuleInterop": true,
+    "forceConsistentCasingInFileNames": true,
+    "skipLibCheck": true,
+    "resolveJsonModule": true
+  },
+  "include": ["./*.ts"]
+}
diff --git a/node_modules/@joystream/metadata-protobuf/src/KnownLicenses.json b/node_modules/@joystream/metadata-protobuf/src/KnownLicenses.json
new file mode 100644
index 0000000..8def94a
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/KnownLicenses.json
@@ -0,0 +1,74 @@
+[
+  {
+    "code": 1000,
+    "name": "CUSTOM",
+    "longName": "Custom License",
+    "description": "A user defined License",
+    "url": "",
+    "attributionRequired": false
+  },
+  {
+    "code": 1001,
+    "name": "PDM",
+    "longName": "Public Domain",
+    "description": "For items which are not protected by copyright. This is not a license, but rather a copyright status. Some government-produced works, items with expired copyrights, and those which are ineligible for copyright protection may be included in this category.",
+    "url": "https://creativecommons.org/share-your-work/public-domain/pdm",
+    "attributionRequired": false
+  },
+  {
+    "code": 1002,
+    "name": "CC0",
+    "longName": "Public Domain Dedication",
+    "description": "The CC0 (Public Domain Dedication) License allows creators to waive all rights to their creations and release them into the Public Domain.",
+    "url": "https://creativecommons.org/share-your-work/public-domain/cc0",
+    "attributionRequired": true
+  },
+  {
+    "code": 1003,
+    "name": "CC_BY",
+    "longName": "Creative Commons Attribution License",
+    "description": "Sharing and adapting this content is permitted, but attribution must be provided. Read the License Deed for more information.",
+    "url": "https://creativecommons.org/licenses/by/4.0",
+    "attributionRequired": true
+  },
+  {
+    "code": 1004,
+    "name": "CC_BY_SA",
+    "longName": "Creative Commons Attribution-ShareAlike License",
+    "description": "Sharing and adapting this content is permitted, but attribution must be provided. Any derivative works must be distributed under the same license. Read the License Deed for more information.",
+    "url": "https://creativecommons.org/licenses/by-sa/4.0",
+    "attributionRequired": true
+  },
+  {
+    "code": 1005,
+    "name": "CC_BY_ND",
+    "longName": "Creative Commons Attribution-NoDerivs License",
+    "description": "Sharing this content is permitted, but attribution must be provided. You may not remix, transform, or build upon the material. Read the License Deed for more information.",
+    "url": "https://creativecommons.org/licenses/by-nd/4.0",
+    "attributionRequired": true
+  },
+  {
+    "code": 1006,
+    "name": "CC_BY_NC",
+    "longName": "Creative Commons Attribution-NonCommercial License",
+    "description": "Sharing and adapting this content is permitted, but attribution must be provided. Commercial use is not permitted. Read the License Deed for more information.",
+    "url": "https://creativecommons.org/licenses/by-nc/4.0",
+    "attributionRequired": true
+  },
+  {
+    "code": 1007,
+    "name": "CC_BY_NC_SA",
+    "longName": "Creative Commons Attribution-NonCommercial-ShareAlike License",
+    "description": "Sharing and adapting this content is permitted, but attribution must be provided. Any derivative works must be distributed under the same license. Commercial use is not permitted. Read the License Deed for more information.",
+    "url": "https://creativecommons.org/licenses/by-nc-sa/4.0",
+    "attributionRequired": true
+  },
+  {
+    "code": 1008,
+    "name": "CC_BY_NC_ND",
+    "longName": "Creative Commons Attribution-NonCommercial-NoDerivs License",
+    "description": "Sharing this content is permitted, but attribution must be provided. You may not remix, transform, or build upon the material. Commercial use is not permitted. Read the License Deed for more information.",
+    "url": "https://creativecommons.org/licenses/by-nc-nd/4.0",
+    "attributionRequired": true
+  }
+]
diff --git a/node_modules/@joystream/metadata-protobuf/src/consts.ts b/node_modules/@joystream/metadata-protobuf/src/consts.ts
new file mode 100644
index 0000000..47d0ec7
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/consts.ts
@@ -0,0 +1 @@
+export const MAX_TAGS_PER_FORUM_THREAD = 5
diff --git a/node_modules/@joystream/metadata-protobuf/src/index.ts b/node_modules/@joystream/metadata-protobuf/src/index.ts
new file mode 100644
index 0000000..5b41d1c
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/index.ts
@@ -0,0 +1,2 @@
+// protobuf message constructors
+export * from '../compiled'
diff --git a/node_modules/@joystream/metadata-protobuf/src/json/index.ts b/node_modules/@joystream/metadata-protobuf/src/json/index.ts
new file mode 100644
index 0000000..56c581a
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/json/index.ts
@@ -0,0 +1,2 @@
+import { nested } from './messages.json'
+export default nested
diff --git a/node_modules/@joystream/metadata-protobuf/src/json/messages.json b/node_modules/@joystream/metadata-protobuf/src/json/messages.json
new file mode 100644
index 0000000..77e3244
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/json/messages.json
@@ -0,0 +1,1348 @@
+{
+  "nested": {
+    "AppActionMetadata": {
+      "fields": {
+        "videoId": {
+          "type": "string",
+          "id": 2
+        }
+      }
+    },
+    "AppAction": {
+      "fields": {
+        "appId": {
+          "rule": "required",
+          "type": "string",
+          "id": 999
+        },
+        "metadata": {
+          "type": "bytes",
+          "id": 2
+        },
+        "rawAction": {
+          "type": "bytes",
+          "id": 3
+        },
+        "signature": {
+          "type": "bytes",
+          "id": 4
+        }
+      },
+      "nested": {
+        "ActionType": {
+          "values": {
+            "CREATE_VIDEO": 0,
+            "CREATE_CHANNEL": 1
+          }
+        },
+        "CreatorType": {
+          "values": {
+            "CHANNEL": 0,
+            "MEMBER": 1,
+            "CURATOR_GROUP": 2
+          }
+        }
+      }
+    },
+    "BountyMetadata": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "discussionThread": {
+          "type": "uint64",
+          "id": 3
+        },
+        "bannerImageUri": {
+          "type": "string",
+          "id": 4
+        }
+      }
+    },
+    "BountyWorkData": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        }
+      }
+    },
+    "ChannelMetadata": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "isPublic": {
+          "type": "bool",
+          "id": 3
+        },
+        "language": {
+          "type": "string",
+          "id": 4
+        },
+        "coverPhoto": {
+          "type": "uint32",
+          "id": 5
+        },
+        "avatarPhoto": {
+          "type": "uint32",
+          "id": 6
+        }
+      }
+    },
+    "ChannelPayoutsMetadata": {
+      "fields": {
+        "header": {
+          "rule": "required",
+          "type": "Header",
+          "id": 1
+        },
+        "body": {
+          "rule": "required",
+          "type": "Body",
+          "id": 2
+        }
+      },
+      "nested": {
+        "Header": {
+          "fields": {
+            "payloadLengthInBytes": {
+              "rule": "required",
+              "type": "fixed64",
+              "id": 1
+            },
+            "headerLengthInBytes": {
+              "rule": "required",
+              "type": "fixed64",
+              "id": 2
+            },
+            "numberOfChannels": {
+              "rule": "required",
+              "type": "fixed32",
+              "id": 3
+            },
+            "channelPayoutByteOffsets": {
+              "rule": "repeated",
+              "type": "ChannelPayoutByteOffset",
+              "id": 4
+            }
+          },
+          "nested": {
+            "ChannelPayoutByteOffset": {
+              "fields": {
+                "channelId": {
+                  "rule": "required",
+                  "type": "fixed32",
+                  "id": 1
+                },
+                "byteOffset": {
+                  "rule": "required",
+                  "type": "fixed64",
+                  "id": 2
+                }
+              }
+            }
+          }
+        },
+        "Body": {
+          "fields": {
+            "channelPayouts": {
+              "rule": "repeated",
+              "type": "ChannelPayoutProof",
+              "id": 1
+            }
+          },
+          "nested": {
+            "ChannelPayoutProof": {
+              "fields": {
+                "channelId": {
+                  "rule": "required",
+                  "type": "uint32",
+                  "id": 1
+                },
+                "cumulativeRewardEarned": {
+                  "rule": "required",
+                  "type": "string",
+                  "id": 2
+                },
+                "merkleBranch": {
+                  "rule": "repeated",
+                  "type": "ProofElement",
+                  "id": 3
+                },
+                "reason": {
+                  "rule": "required",
+                  "type": "string",
+                  "id": 4
+                }
+              },
+              "nested": {
+                "Side": {
+                  "values": {
+                    "Left": 0,
+                    "Right": 1
+                  }
+                },
+                "ProofElement": {
+                  "fields": {
+                    "hash": {
+                      "rule": "required",
+                      "type": "string",
+                      "id": 1
+                    },
+                    "side": {
+                      "rule": "required",
+                      "type": "Side",
+                      "id": 2
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    },
+    "CouncilCandidacyNoteMetadata": {
+      "fields": {
+        "header": {
+          "type": "string",
+          "id": 1
+        },
+        "bulletPoints": {
+          "rule": "repeated",
+          "type": "string",
+          "id": 2
+        },
+        "bannerImageUri": {
+          "type": "string",
+          "id": 3
+        },
+        "description": {
+          "type": "string",
+          "id": 4
+        }
+      }
+    },
+    "ForumPostMetadata": {
+      "fields": {
+        "text": {
+          "type": "string",
+          "id": 1
+        },
+        "repliesTo": {
+          "type": "uint32",
+          "id": 2
+        }
+      }
+    },
+    "ForumThreadMetadata": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "tags": {
+          "rule": "repeated",
+          "type": "string",
+          "id": 2
+        }
+      }
+    },
+    "MembershipMetadata": {
+      "oneofs": {
+        "avatar": {
+          "oneof": [
+            "avatarObject",
+            "avatarUri"
+          ]
+        }
+      },
+      "fields": {
+        "name": {
+          "type": "string",
+          "id": 1
+        },
+        "avatarObject": {
+          "type": "uint32",
+          "id": 2
+        },
+        "avatarUri": {
+          "type": "string",
+          "id": 4
+        },
+        "about": {
+          "type": "string",
+          "id": 3
+        },
+        "externalResources": {
+          "rule": "repeated",
+          "type": "ExternalResource",
+          "id": 5
+        }
+      },
+      "nested": {
+        "ExternalResource": {
+          "fields": {
+            "type": {
+              "type": "ResourceType",
+              "id": 1
+            },
+            "value": {
+              "type": "string",
+              "id": 2
+            }
+          },
+          "nested": {
+            "ResourceType": {
+              "values": {
+                "EMAIL": 0,
+                "HYPERLINK": 1,
+                "TWITTER": 2,
+                "TELEGRAM": 3,
+                "DISCORD": 4,
+                "FACEBOOK": 5,
+                "YOUTUBE": 6,
+                "MATRIX": 7,
+                "IRC": 8,
+                "WECHAT": 9,
+                "WHATSAPP": 10
+              }
+            }
+          }
+        }
+      }
+    },
+    "ReactVideo": {
+      "fields": {
+        "videoId": {
+          "rule": "required",
+          "type": "uint64",
+          "id": 1
+        },
+        "reaction": {
+          "rule": "required",
+          "type": "Reaction",
+          "id": 2
+        }
+      },
+      "nested": {
+        "Reaction": {
+          "values": {
+            "LIKE": 0,
+            "UNLIKE": 1
+          }
+        }
+      }
+    },
+    "ReactComment": {
+      "fields": {
+        "commentId": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        },
+        "reactionId": {
+          "rule": "required",
+          "type": "uint32",
+          "id": 2
+        }
+      }
+    },
+    "CreateComment": {
+      "fields": {
+        "videoId": {
+          "rule": "required",
+          "type": "uint64",
+          "id": 1
+        },
+        "parentCommentId": {
+          "type": "string",
+          "id": 2
+        },
+        "body": {
+          "rule": "required",
+          "type": "string",
+          "id": 3
+        }
+      }
+    },
+    "EditComment": {
+      "fields": {
+        "commentId": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        },
+        "newBody": {
+          "rule": "required",
+          "type": "string",
+          "id": 2
+        }
+      }
+    },
+    "DeleteComment": {
+      "fields": {
+        "commentId": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        }
+      }
+    },
+    "PinOrUnpinComment": {
+      "fields": {
+        "videoId": {
+          "rule": "required",
+          "type": "uint64",
+          "id": 1
+        },
+        "commentId": {
+          "rule": "required",
+          "type": "string",
+          "id": 2
+        },
+        "option": {
+          "rule": "required",
+          "type": "Option",
+          "id": 3
+        }
+      },
+      "nested": {
+        "Option": {
+          "values": {
+            "PIN": 0,
+            "UNPIN": 1
+          }
+        }
+      }
+    },
+    "ModerateComment": {
+      "fields": {
+        "commentId": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        },
+        "rationale": {
+          "rule": "required",
+          "type": "string",
+          "id": 2
+        }
+      }
+    },
+    "BanOrUnbanMemberFromChannel": {
+      "fields": {
+        "memberId": {
+          "rule": "required",
+          "type": "uint64",
+          "id": 1
+        },
+        "option": {
+          "rule": "required",
+          "type": "Option",
+          "id": 2
+        }
+      },
+      "nested": {
+        "Option": {
+          "values": {
+            "BAN": 0,
+            "UNBAN": 1
+          }
+        }
+      }
+    },
+    "VideoReactionsPreference": {
+      "fields": {
+        "videoId": {
+          "rule": "required",
+          "type": "uint64",
+          "id": 1
+        },
+        "option": {
+          "rule": "required",
+          "type": "Option",
+          "id": 2
+        }
+      },
+      "nested": {
+        "Option": {
+          "values": {
+            "ENABLE": 0,
+            "DISABLE": 1
+          }
+        }
+      }
+    },
+    "CreateVideoCategory": {
+      "fields": {
+        "name": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "parentCategoryId": {
+          "type": "string",
+          "id": 3
+        }
+      }
+    },
+    "MakeChannelPayment": {
+      "oneofs": {
+        "paymentContext": {
+          "oneof": [
+            "videoId"
+          ]
+        }
+      },
+      "fields": {
+        "rationale": {
+          "type": "string",
+          "id": 1
+        },
+        "videoId": {
+          "type": "uint64",
+          "id": 2
+        }
+      }
+    },
+    "AppMetadata": {
+      "fields": {
+        "websiteUrl": {
+          "type": "string",
+          "id": 2
+        },
+        "useUri": {
+          "type": "string",
+          "id": 3
+        },
+        "smallIcon": {
+          "type": "string",
+          "id": 4
+        },
+        "mediumIcon": {
+          "type": "string",
+          "id": 5
+        },
+        "bigIcon": {
+          "type": "string",
+          "id": 6
+        },
+        "oneLiner": {
+          "type": "string",
+          "id": 7
+        },
+        "description": {
+          "type": "string",
+          "id": 8
+        },
+        "termsOfService": {
+          "type": "string",
+          "id": 9
+        },
+        "authKey": {
+          "type": "string",
+          "id": 10
+        },
+        "platforms": {
+          "rule": "repeated",
+          "type": "string",
+          "id": 11
+        },
+        "category": {
+          "type": "string",
+          "id": 12
+        }
+      }
+    },
+    "CreateApp": {
+      "fields": {
+        "name": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        },
+        "appMetadata": {
+          "type": "AppMetadata",
+          "id": 2
+        }
+      }
+    },
+    "UpdateApp": {
+      "fields": {
+        "appId": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        },
+        "appMetadata": {
+          "type": "AppMetadata",
+          "id": 2
+        }
+      }
+    },
+    "MemberRemarked": {
+      "oneofs": {
+        "memberRemarked": {
+          "oneof": [
+            "reactVideo",
+            "reactComment",
+            "createComment",
+            "editComment",
+            "deleteComment",
+            "createVideoCategory",
+            "createApp",
+            "updateApp",
+            "makeChannelPayment"
+          ]
+        }
+      },
+      "fields": {
+        "reactVideo": {
+          "type": "ReactVideo",
+          "id": 1
+        },
+        "reactComment": {
+          "type": "ReactComment",
+          "id": 2
+        },
+        "createComment": {
+          "type": "CreateComment",
+          "id": 3
+        },
+        "editComment": {
+          "type": "EditComment",
+          "id": 4
+        },
+        "deleteComment": {
+          "type": "DeleteComment",
+          "id": 5
+        },
+        "createVideoCategory": {
+          "type": "CreateVideoCategory",
+          "id": 6
+        },
+        "createApp": {
+          "type": "CreateApp",
+          "id": 7
+        },
+        "updateApp": {
+          "type": "UpdateApp",
+          "id": 8
+        },
+        "makeChannelPayment": {
+          "type": "MakeChannelPayment",
+          "id": 10
+        }
+      }
+    },
+    "ChannelModeratorRemarked": {
+      "oneofs": {
+        "channelModeratorRemarked": {
+          "oneof": [
+            "moderateComment"
+          ]
+        }
+      },
+      "fields": {
+        "moderateComment": {
+          "type": "ModerateComment",
+          "id": 1
+        }
+      }
+    },
+    "ChannelOwnerRemarked": {
+      "oneofs": {
+        "channelOwnerRemarked": {
+          "oneof": [
+            "pinOrUnpinComment",
+            "banOrUnbanMemberFromChannel",
+            "videoReactionsPreference",
+            "moderateComment"
+          ]
+        }
+      },
+      "fields": {
+        "pinOrUnpinComment": {
+          "type": "PinOrUnpinComment",
+          "id": 1
+        },
+        "banOrUnbanMemberFromChannel": {
+          "type": "BanOrUnbanMemberFromChannel",
+          "id": 2
+        },
+        "videoReactionsPreference": {
+          "type": "VideoReactionsPreference",
+          "id": 3
+        },
+        "moderateComment": {
+          "type": "ModerateComment",
+          "id": 5
+        }
+      }
+    },
+    "PersonMetadata": {
+      "fields": {
+        "firstName": {
+          "type": "string",
+          "id": 1
+        },
+        "middleName": {
+          "type": "string",
+          "id": 2
+        },
+        "lastName": {
+          "type": "string",
+          "id": 3
+        },
+        "about": {
+          "type": "string",
+          "id": 4
+        },
+        "coverPhoto": {
+          "type": "uint32",
+          "id": 5
+        },
+        "avatarPhoto": {
+          "type": "uint32",
+          "id": 6
+        }
+      }
+    },
+    "ProposalsDiscussionPostMetadata": {
+      "fields": {
+        "text": {
+          "type": "string",
+          "id": 1
+        },
+        "repliesTo": {
+          "type": "uint32",
+          "id": 2
+        }
+      }
+    },
+    "SeriesMetadata": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "coverPhoto": {
+          "type": "uint32",
+          "id": 3
+        },
+        "persons": {
+          "rule": "repeated",
+          "type": "uint64",
+          "id": 4
+        }
+      }
+    },
+    "SeasonMetadata": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "coverPhoto": {
+          "type": "uint32",
+          "id": 3
+        },
+        "persons": {
+          "rule": "repeated",
+          "type": "uint64",
+          "id": 4
+        }
+      }
+    },
+    "GeoCoordiantes": {
+      "fields": {
+        "latitude": {
+          "type": "float",
+          "id": 3
+        },
+        "longitude": {
+          "type": "float",
+          "id": 4
+        }
+      }
+    },
+    "NodeLocationMetadata": {
+      "fields": {
+        "countryCode": {
+          "type": "string",
+          "id": 1
+        },
+        "city": {
+          "type": "string",
+          "id": 2
+        },
+        "coordinates": {
+          "type": "GeoCoordiantes",
+          "id": 3
+        }
+      }
+    },
+    "StorageBucketOperatorMetadata": {
+      "fields": {
+        "endpoint": {
+          "type": "string",
+          "id": 1
+        },
+        "location": {
+          "type": "NodeLocationMetadata",
+          "id": 2
+        },
+        "extra": {
+          "type": "string",
+          "id": 3
+        }
+      }
+    },
+    "DistributionBucketOperatorMetadata": {
+      "fields": {
+        "endpoint": {
+          "type": "string",
+          "id": 1
+        },
+        "location": {
+          "type": "NodeLocationMetadata",
+          "id": 2
+        },
+        "extra": {
+          "type": "string",
+          "id": 3
+        }
+      }
+    },
+    "GeographicalArea": {
+      "oneofs": {
+        "code": {
+          "oneof": [
+            "continent",
+            "countryCode",
+            "subdivisionCode"
+          ]
+        }
+      },
+      "fields": {
+        "continent": {
+          "type": "Continent",
+          "id": 1
+        },
+        "countryCode": {
+          "type": "string",
+          "id": 2
+        },
+        "subdivisionCode": {
+          "type": "string",
+          "id": 3
+        }
+      },
+      "nested": {
+        "Continent": {
+          "values": {
+            "AF": 1,
+            "NA": 2,
+            "OC": 3,
+            "AN": 4,
+            "AS": 5,
+            "EU": 6,
+            "SA": 7
+          }
+        }
+      }
+    },
+    "DistributionBucketFamilyMetadata": {
+      "fields": {
+        "region": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "areas": {
+          "rule": "repeated",
+          "type": "GeographicalArea",
+          "id": 3
+        },
+        "latencyTestTargets": {
+          "rule": "repeated",
+          "type": "string",
+          "id": 4
+        }
+      }
+    },
+    "CreatorTokenIssuerRemarked": {
+      "oneofs": {
+        "creatorTokenIssuerRemarked": {
+          "oneof": [
+            "updateTokenMetadata"
+          ]
+        }
+      },
+      "fields": {
+        "updateTokenMetadata": {
+          "type": "UpdateTokenMetadata",
+          "id": 1
+        }
+      }
+    },
+    "UpdateTokenMetadata": {
+      "fields": {
+        "newMetadata": {
+          "type": "TokenMetadata",
+          "id": 1
+        }
+      }
+    },
+    "TokenMetadata": {
+      "oneofs": {
+        "avatar": {
+          "oneof": [
+            "avatarObject",
+            "avatarUri"
+          ]
+        }
+      },
+      "fields": {
+        "name": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "avatarObject": {
+          "type": "uint32",
+          "id": 3
+        },
+        "avatarUri": {
+          "type": "string",
+          "id": 4
+        },
+        "benefits": {
+          "rule": "repeated",
+          "type": "Benefit",
+          "id": 5
+        },
+        "whitelistApplicationNote": {
+          "type": "string",
+          "id": 6
+        },
+        "whitelistApplicationApplyLink": {
+          "type": "string",
+          "id": 7
+        },
+        "trailerVideoId": {
+          "type": "uint64",
+          "id": 8
+        }
+      }
+    },
+    "Benefit": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "emoji": {
+          "type": "string",
+          "id": 3
+        },
+        "displayOrder": {
+          "type": "uint32",
+          "id": 4
+        }
+      }
+    },
+    "SaleMetadata": {
+      "fields": {
+        "termsAndConditions": {
+          "type": "string",
+          "id": 1
+        }
+      }
+    },
+    "PublishedBeforeJoystream": {
+      "fields": {
+        "isPublished": {
+          "type": "bool",
+          "id": 1
+        },
+        "date": {
+          "type": "string",
+          "id": 2
+        }
+      }
+    },
+    "License": {
+      "fields": {
+        "code": {
+          "type": "uint32",
+          "id": 1
+        },
+        "attribution": {
+          "type": "string",
+          "id": 2
+        },
+        "customText": {
+          "type": "string",
+          "id": 3
+        }
+      }
+    },
+    "MediaType": {
+      "fields": {
+        "codecName": {
+          "type": "string",
+          "id": 1
+        },
+        "container": {
+          "type": "string",
+          "id": 2
+        },
+        "mimeMediaType": {
+          "type": "string",
+          "id": 3
+        }
+      }
+    },
+    "SubtitleMetadata": {
+      "fields": {
+        "type": {
+          "rule": "required",
+          "type": "string",
+          "id": 1
+        },
+        "newAsset": {
+          "type": "uint32",
+          "id": 2
+        },
+        "language": {
+          "rule": "required",
+          "type": "string",
+          "id": 3
+        },
+        "mimeType": {
+          "rule": "required",
+          "type": "string",
+          "id": 4
+        }
+      }
+    },
+    "VideoMetadata": {
+      "fields": {
+        "title": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "video": {
+          "type": "uint32",
+          "id": 3
+        },
+        "thumbnailPhoto": {
+          "type": "uint32",
+          "id": 4
+        },
+        "duration": {
+          "type": "uint32",
+          "id": 5
+        },
+        "mediaPixelHeight": {
+          "type": "uint32",
+          "id": 6
+        },
+        "mediaPixelWidth": {
+          "type": "uint32",
+          "id": 7
+        },
+        "mediaType": {
+          "type": "MediaType",
+          "id": 8
+        },
+        "language": {
+          "type": "string",
+          "id": 9
+        },
+        "license": {
+          "type": "License",
+          "id": 10
+        },
+        "publishedBeforeJoystream": {
+          "type": "PublishedBeforeJoystream",
+          "id": 11
+        },
+        "hasMarketing": {
+          "type": "bool",
+          "id": 12
+        },
+        "isPublic": {
+          "type": "bool",
+          "id": 13
+        },
+        "isExplicit": {
+          "type": "bool",
+          "id": 14
+        },
+        "persons": {
+          "rule": "repeated",
+          "type": "uint64",
+          "id": 15
+        },
+        "category": {
+          "type": "string",
+          "id": 16
+        },
+        "subtitles": {
+          "rule": "repeated",
+          "type": "SubtitleMetadata",
+          "id": 17
+        },
+        "enableComments": {
+          "type": "bool",
+          "id": 18
+        },
+        "clearSubtitles": {
+          "type": "bool",
+          "id": 19
+        }
+      }
+    },
+    "ContentMetadata": {
+      "oneofs": {
+        "contentMetadata": {
+          "oneof": [
+            "videoMetadata"
+          ]
+        }
+      },
+      "fields": {
+        "videoMetadata": {
+          "type": "VideoMetadata",
+          "id": 1
+        }
+      }
+    },
+    "OpeningMetadata": {
+      "fields": {
+        "shortDescription": {
+          "type": "string",
+          "id": 1
+        },
+        "description": {
+          "type": "string",
+          "id": 2
+        },
+        "hiringLimit": {
+          "type": "uint32",
+          "id": 3
+        },
+        "expectedEndingTimestamp": {
+          "type": "uint32",
+          "id": 4
+        },
+        "applicationDetails": {
+          "type": "string",
+          "id": 5
+        },
+        "applicationFormQuestions": {
+          "rule": "repeated",
+          "type": "ApplicationFormQuestion",
+          "id": 6
+        },
+        "title": {
+          "type": "string",
+          "id": 7
+        }
+      },
+      "nested": {
+        "ApplicationFormQuestion": {
+          "fields": {
+            "question": {
+              "type": "string",
+              "id": 1
+            },
+            "type": {
+              "type": "InputType",
+              "id": 2
+            }
+          },
+          "nested": {
+            "InputType": {
+              "values": {
+                "TEXTAREA": 0,
+                "TEXT": 1
+              }
+            }
+          }
+        }
+      }
+    },
+    "UpcomingOpeningMetadata": {
+      "fields": {
+        "expectedStart": {
+          "type": "uint32",
+          "id": 1
+        },
+        "rewardPerBlock": {
+          "type": "uint64",
+          "id": 2
+        },
+        "minApplicationStake": {
+          "type": "uint64",
+          "id": 3
+        },
+        "metadata": {
+          "type": "OpeningMetadata",
+          "id": 4
+        }
+      }
+    },
+    "ApplicationMetadata": {
+      "fields": {
+        "answers": {
+          "rule": "repeated",
+          "type": "string",
+          "id": 1
+        }
+      }
+    },
+    "WorkingGroupMetadata": {
+      "fields": {
+        "description": {
+          "type": "string",
+          "id": 1
+        },
+        "about": {
+          "type": "string",
+          "id": 2
+        },
+        "status": {
+          "type": "string",
+          "id": 3
+        },
+        "statusMessage": {
+          "type": "string",
+          "id": 4
+        }
+      }
+    },
+    "SetGroupMetadata": {
+      "fields": {
+        "newMetadata": {
+          "type": "WorkingGroupMetadata",
+          "id": 1
+        }
+      }
+    },
+    "AddUpcomingOpening": {
+      "fields": {
+        "metadata": {
+          "type": "UpcomingOpeningMetadata",
+          "id": 1
+        }
+      }
+    },
+    "RemoveUpcomingOpening": {
+      "fields": {
+        "id": {
+          "type": "string",
+          "id": 1
+        }
+      }
+    },
+    "WorkingGroupMetadataAction": {
+      "oneofs": {
+        "action": {
+          "oneof": [
+            "setGroupMetadata",
+            "addUpcomingOpening",
+            "removeUpcomingOpening"
+          ]
+        }
+      },
+      "fields": {
+        "setGroupMetadata": {
+          "type": "SetGroupMetadata",
+          "id": 1
+        },
+        "addUpcomingOpening": {
+          "type": "AddUpcomingOpening",
+          "id": 2
+        },
+        "removeUpcomingOpening": {
+          "type": "RemoveUpcomingOpening",
+          "id": 3
+        }
+      }
+    },
+    "ModeratePost": {
+      "fields": {
+        "postId": {
+          "rule": "required",
+          "type": "uint64",
+          "id": 1
+        },
+        "rationale": {
+          "rule": "required",
+          "type": "string",
+          "id": 2
+        }
+      }
+    },
+    "RemarkMetadataAction": {
+      "oneofs": {
+        "action": {
+          "oneof": [
+            "moderatePost"
+          ]
+        }
+      },
+      "fields": {
+        "moderatePost": {
+          "type": "ModeratePost",
+          "id": 1
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/node_modules/@joystream/metadata-protobuf/src/licenses.ts b/node_modules/@joystream/metadata-protobuf/src/licenses.ts
new file mode 100644
index 0000000..04eb5f1
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/licenses.ts
@@ -0,0 +1,64 @@
+// Helper methods to handle joystream defined license types
+// This should be factored out into a separate package
+
+import LICENSES from './KnownLicenses.json'
+import { License } from '../compiled/index'
+
+export type LicenseCode = number
+export const CUSTOM_LICENSE_CODE: LicenseCode = 1000
+
+type KnownLicense = {
+  code: LicenseCode
+  name: string
+  longName: string
+  description: string
+  url: string
+  attributionRequired: boolean
+}
+
+export const KnownLicenses = new Map<LicenseCode, KnownLicense>()
+
+LICENSES.forEach((license: KnownLicense) => {
+  KnownLicenses.set(license.code, license)
+})
+
+export function getLicenseCodeByName(name: string): LicenseCode | undefined {
+  for (const [code, license] of KnownLicenses) {
+    if (license.name === name) return code
+  }
+}
+
+export function createKnownLicenseFromCode(code: LicenseCode, attribution?: string): License {
+  if (code === CUSTOM_LICENSE_CODE) {
+    throw new Error('Use createCustomLicense() instead')
+  }
+
+  const knownLicense = KnownLicenses.get(code)
+
+  if (!knownLicense) {
+    throw new Error('Unknown License Code')
+  }
+
+  const license = new License({ code })
+
+  if (knownLicense.attributionRequired) {
+    if (attribution === undefined) {
+      throw new Error('Attribution required for selected license')
+    }
+    license.attribution = attribution
+  }
+
+  return license
+}
+
+export function createCustomKnownLicense(customText: string): License {
+  return new License({ code: CUSTOM_LICENSE_CODE, customText })
+}
+
+export default {
+  CUSTOM_LICENSE_CODE,
+  KnownLicenses,
+  createCustomKnownLicense,
+  createKnownLicenseFromCode,
+  getLicenseCodeByName,
+}
diff --git a/node_modules/@joystream/metadata-protobuf/src/types.ts b/node_modules/@joystream/metadata-protobuf/src/types.ts
new file mode 100644
index 0000000..f946972
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/types.ts
@@ -0,0 +1,26 @@
+import { Long } from 'long'
+import { IConversionOptions } from 'protobufjs'
+
+export type AnyMessage<T> = T & {
+  toJSON(): Record<string, unknown>
+}
+
+export type AnyMetadataClass<T> = {
+  new (): T
+  name: string
+  decode(binary: Uint8Array): AnyMessage<T>
+  encode(obj: T): { finish(): Uint8Array }
+  toObject(obj: AnyMessage<T>, options?: IConversionOptions): Record<string, unknown>
+  verify(message: { [k: string]: unknown }): null | string
+  fromObject(object: { [k: string]: unknown }): AnyMessage<T>
+}
+
+export type DecodedMetadataObject<T> = {
+  [K in keyof T]: T[K] extends Long | null | undefined
+    ? Exclude<T[K], Long> | string
+    : T[K] extends string | number | boolean | Uint8Array | null | undefined
+    ? T[K]
+    : T[K] extends Array<infer S>
+    ? DecodedMetadataObject<S>[]
+    : DecodedMetadataObject<T[K]>
+}
diff --git a/node_modules/@joystream/metadata-protobuf/src/utils.ts b/node_modules/@joystream/metadata-protobuf/src/utils.ts
new file mode 100644
index 0000000..3adf1b5
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/src/utils.ts
@@ -0,0 +1,50 @@
+import { AnyMessage, AnyMetadataClass, DecodedMetadataObject } from './types'
+import countries from 'i18n-iso-countries'
+import langs from 'iso-639-1'
+import subdivisions from 'iso-3166-2'
+
+export function isSet<T>(v: T | null | undefined): v is T {
+  return v !== null && v !== undefined
+}
+
+export function isEmptyObject<T>(object: T): boolean {
+  return Object.keys(object).length === 0
+}
+
+export function integrateMeta<
+  T,
+  Props extends readonly (keyof T & keyof M & string)[],
+  M extends { [K in Props[number]]?: T[K] | null }
+>(object: T, meta: M, props: Props): void {
+  props.forEach((prop) => {
+    const metaPropVal = meta[prop] as T[Props[number]] | null | undefined
+    if (isSet(metaPropVal)) {
+      object[prop] = metaPropVal
+    }
+  })
+}
+
+export function encodeDecode<T>(metaClass: AnyMetadataClass<T>, value: T): DecodedMetadataObject<T> {
+  const encoded = metaClass.encode(value).finish()
+  return metaToObject(metaClass, metaClass.decode(encoded))
+}
+
+export function metaToObject<T>(metaClass: AnyMetadataClass<T>, value: AnyMessage<T>): DecodedMetadataObject<T> {
+  // Default conversion options - use Strings for "Long" values and ignore unset "repeated" fields
+  return metaClass.toObject(value, { arrays: false, longs: String }) as DecodedMetadataObject<T>
+}
+
+// Checks if the provided code is valid according to ISO 3166-1 alpha-2 standard
+export function isValidCountryCode(code: string): boolean {
+  return countries.getAlpha2Codes()[code] !== undefined
+}
+
+// Checks if the provided code is valid according to ISO 639-1 standard
+export function isValidLanguageCode(code: string): boolean {
+  return langs.validate(code)
+}
+
+// According to ISO 3166-2 standard
+export function isValidSubdivisionCode(code: string): boolean {
+  return !!subdivisions.subdivision(code)
+}
diff --git a/node_modules/@joystream/metadata-protobuf/test/channel.ts b/node_modules/@joystream/metadata-protobuf/test/channel.ts
new file mode 100644
index 0000000..95f5324
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/test/channel.ts
@@ -0,0 +1,21 @@
+import { ChannelMetadata } from '../src'
+import { assert } from 'chai'
+import { encodeDecode, metaToObject } from '../src/utils'
+import Long from 'long'
+
+describe('Channel Metadata', () => {
+  it('Message', () => {
+    const channel = {
+      title: 'title',
+      description: 'description',
+      isPublic: false,
+      language: 'fr',
+      avatarPhoto: 0,
+      coverPhoto: 1,
+    }
+    const channelMessage = new ChannelMetadata(channel)
+
+    assert.deepEqual(metaToObject(ChannelMetadata, channelMessage), channel)
+    assert.deepEqual(encodeDecode(ChannelMetadata, channel), channel)
+  })
+})
diff --git a/node_modules/@joystream/metadata-protobuf/test/forum-tags.ts b/node_modules/@joystream/metadata-protobuf/test/forum-tags.ts
new file mode 100644
index 0000000..9a73ecf
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/test/forum-tags.ts
@@ -0,0 +1,13 @@
+import { ForumThreadMetadata } from '../src'
+import { assert } from 'chai'
+import { encodeDecode, metaToObject } from '../src/utils'
+
+describe('Forum tags', () => {
+  it('Skip vs unsetting', () => {
+    const messageSkip = new ForumThreadMetadata()
+    const messageUnset = new ForumThreadMetadata({ tags: [''] })
+
+    assert.equal(metaToObject(ForumThreadMetadata, messageSkip).tags, undefined)
+    assert.deepEqual(encodeDecode(ForumThreadMetadata, messageUnset).tags, [''])
+  })
+})
diff --git a/node_modules/@joystream/metadata-protobuf/test/license-codes.ts b/node_modules/@joystream/metadata-protobuf/test/license-codes.ts
new file mode 100644
index 0000000..cc9b2df
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/test/license-codes.ts
@@ -0,0 +1,48 @@
+import {
+  KnownLicenses,
+  CUSTOM_LICENSE_CODE,
+  getLicenseCodeByName,
+  createKnownLicenseFromCode,
+  createCustomKnownLicense,
+} from '../src/licenses'
+import { License } from '../src/index'
+import { assert } from 'chai'
+
+describe('Known License Codes', () => {
+  it('Excludes default value 0', () => {
+    assert(!KnownLicenses.has(0))
+  })
+
+  it('Pre-defined Joystream license codes', () => {
+    // Make sure we have correct known custom license
+    assert(KnownLicenses.has(CUSTOM_LICENSE_CODE))
+    assert.equal(KnownLicenses.get(CUSTOM_LICENSE_CODE)?.name, 'CUSTOM')
+
+    assert(KnownLicenses.has(1001))
+    assert(KnownLicenses.has(1002))
+    assert(KnownLicenses.has(1003))
+    assert(KnownLicenses.has(1004))
+    assert(KnownLicenses.has(1005))
+    assert(KnownLicenses.has(1006))
+    assert(KnownLicenses.has(1007))
+    assert(KnownLicenses.has(1008))
+  })
+
+  it('createCustomKnownLicense(): uses correct code', () => {
+    const TEXT = 'custom text'
+    const license = createCustomKnownLicense(TEXT)
+    assert.equal(license.code, CUSTOM_LICENSE_CODE)
+    assert.equal(license.customText, TEXT)
+    License.verify(license)
+  })
+
+  it('createKnownLicenseFromCode(): License can be created by name', () => {
+    const NAME = 'CC_BY'
+    const ATTRIBUTION = 'Attribution: Joystream'
+    const licenseCode = getLicenseCodeByName(NAME) as number
+    const license = createKnownLicenseFromCode(licenseCode, ATTRIBUTION)
+    assert.isDefined(license.code)
+    assert.equal(license.attribution, ATTRIBUTION)
+    License.verify(license)
+  })
+})
diff --git a/node_modules/@joystream/metadata-protobuf/test/tsconfig.json b/node_modules/@joystream/metadata-protobuf/test/tsconfig.json
new file mode 100644
index 0000000..8427ccb
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/test/tsconfig.json
@@ -0,0 +1,14 @@
+{
+  "compilerOptions": {
+    "target": "esnext",
+    "module": "commonjs",
+    "noEmit": true,
+    "strict": true,
+    "declaration": true,
+    "esModuleInterop": true,
+    "forceConsistentCasingInFileNames": true,
+    "skipLibCheck": true,
+    "resolveJsonModule": true
+  },
+  "include": ["./*", "../src/*"]
+}
diff --git a/node_modules/@joystream/metadata-protobuf/test/video.ts b/node_modules/@joystream/metadata-protobuf/test/video.ts
new file mode 100644
index 0000000..3769555
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/test/video.ts
@@ -0,0 +1,87 @@
+import { VideoMetadata, MediaType } from '../src'
+import { assert, expect } from 'chai'
+import { isSet, encodeDecode, metaToObject } from '../src/utils'
+import Long from 'long'
+
+describe('Video Metadata', () => {
+  it('Message', () => {
+    const video = {
+      title: 'Video Title',
+      description: 'Video Description',
+      duration: 100,
+      mediaPixelHeight: 1,
+      mediaPixelWidth: 2,
+      mediaType: {},
+      language: 'en',
+      license: {},
+      publishedBeforeJoystream: {},
+      hasMarketing: true,
+      isPublic: true,
+      isExplicit: false,
+      video: 0,
+      thumbnailPhoto: 1,
+      category: '101',
+    }
+    const videoMessage = new VideoMetadata(video)
+
+    assert.deepEqual(metaToObject(VideoMetadata, videoMessage), { ...video, category: '101' })
+    assert.deepEqual(encodeDecode(VideoMetadata, video), { ...video, category: '101' })
+  })
+
+  it('Message: PublishedBeforeJoystream', () => {
+    const meta = new VideoMetadata()
+
+    expect(isSet(metaToObject(VideoMetadata, meta).publishedBeforeJoystream)).equals(
+      false,
+      'PublishedBeforeJoystream field should NOT be set'
+    )
+
+    const published = {
+      isPublished: true,
+      date: '1950-12-24',
+    }
+    meta.publishedBeforeJoystream = published
+
+    // Field should now be set
+    expect(isSet(metaToObject(VideoMetadata, meta).publishedBeforeJoystream)).equals(
+      true,
+      'PublishedBeforeJoystream field should be set'
+    )
+
+    assert.deepEqual(metaToObject(VideoMetadata, meta).publishedBeforeJoystream, published)
+    assert.deepEqual(encodeDecode(VideoMetadata, meta).publishedBeforeJoystream, meta.publishedBeforeJoystream)
+  })
+
+  it('Message: License', () => {
+    const license = {
+      code: 1000,
+      attribution: 'Attribution Text',
+      customText: 'Custom License Details',
+    }
+    const meta = new VideoMetadata({ license })
+    assert.deepEqual(metaToObject(VideoMetadata, meta).license, license)
+    assert.deepEqual(encodeDecode(VideoMetadata, meta).license, license)
+
+    // Empty object check
+    meta.license = {}
+    assert.deepEqual(metaToObject(VideoMetadata, meta).license, {})
+    assert.deepEqual(encodeDecode(VideoMetadata, meta).license, {})
+
+    // Unset check
+    meta.license = undefined
+    assert.deepEqual(metaToObject(VideoMetadata, meta).license, undefined)
+    assert.deepEqual(encodeDecode(VideoMetadata, meta).license, undefined)
+  })
+
+  it('Message: MediaType', () => {
+    const mediaType = {
+      codecName: 'mpeg4',
+      container: 'avi',
+      mimeMediaType: 'videp/mp4',
+    }
+    const mediaTypeMessage = new MediaType(mediaType)
+
+    assert.deepEqual(metaToObject(MediaType, mediaTypeMessage), mediaType)
+    assert.deepEqual(encodeDecode(MediaType, mediaType), mediaType)
+  })
+})
diff --git a/node_modules/@joystream/metadata-protobuf/tsconfig.json b/node_modules/@joystream/metadata-protobuf/tsconfig.json
new file mode 100644
index 0000000..aed6b01
--- /dev/null
+++ b/node_modules/@joystream/metadata-protobuf/tsconfig.json
@@ -0,0 +1,15 @@
+{
+  "compilerOptions": {
+    "target": "es2017",
+    "module": "commonjs",
+    "outDir": "lib",
+    "strict": true,
+    "declaration": true,
+    "esModuleInterop": true,
+    "forceConsistentCasingInFileNames": true,
+    "skipLibCheck": true,
+    "resolveJsonModule": true,
+  },
+  "include": ["src"],
+  "exclude": ["node_modules", "test"]
+}
