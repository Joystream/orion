type User @entity {
  "Unique identifier (32-byte string, securely random)"
  id: ID!

  "Whether the user has root (gateway operator) privileges"
  isRoot: Boolean!

  "The account associated with the user (if any)"
  account: Account @derivedFrom(field: "user")
}

type EncryptionArtifacts @entity {
  "ID / lookupKey"
  id: ID!

  "The IV used to encrypt the wallet seed with user credentials"
  cipherIv: String!

  "Wallet seed encrypted with user credentials"
  encryptedSeed: String!
}

type SessionEncryptionArtifacts @entity {
  "Unique identifier"
  id: ID!

  "The session the encryption artifacts are associated with"
  session: Session! @unique

  "The IV used to encrypt the seed with cipherKey"
  cipherIv: String!

  "cipherKey used to encrypt the seed stored client-side for the duration of the session"
  cipherKey: String!
}

type Session @entity {
  "Unique identifier (32-byte string, securely random)"
  id: ID!

  "Browser (as deterimned based on user-agent header)"
  browser: String!

  "Operating system (as deterimned based on user-agent header)"
  os: String!

  "Device (as deterimned based on user-agent header)"
  device: String!

  "Device type (as deterimned based on user-agent header)"
  deviceType: String

  "User associated with the session"
  user: User!

  "Account associated with the session (if any)"
  account: Account

  "IP address associated with the session"
  ip: String! @index

  "Time when the session started"
  startedAt: DateTime!

  "Time when the session expires or did expire"
  expiry: DateTime!
}

type Account @entity {
  "Unique identifier (can be sequential)"
  id: ID!

  "The user associated with the account (the account owner)"
  user: User! @unique

  "Account's e-mail address"
  email: String! @unique

  """
  Indicates whether the account's e-mail has been confirmed or not.
  """
  isEmailConfirmed: Boolean!

  "Indicates whether the access to the user account is blocked"
  isBlocked: Boolean!

  "Time when the account was registered"
  registeredAt: DateTime!

  "List of Joystream accounts connected to the user account"
  connectedAccounts: [ConnectedAccount!]! @derivedFrom(field: "account")
}

type ConnectedAccount @entity {
  "Unique identifier: Joystream account's address"
  id: ID!

  "The user account the Joystream account is connected to"
  account: Account!

  "Time at which the Joystream account was connected to the user account"
  connectedAt: DateTime!

  """
  Indicates whether the user can log in to their user account
  by providing a signature generated by this connected account
  """
  isLoginAllowed: Boolean!

  "Proof that the user account is the owner of the Joystream account"
  proof: ConnectedAccountProof! @unique
}

type ConnectedAccountProof @entity {
  "Unique identifier"
  id: ID!

  "Connected account for which the proof was generated"
  connectedAccount: ConnectedAccount @derivedFrom(field: "proof")

  "The timestamp as provided in the proof"
  timestamp: DateTime!

  "The name of the gateway as specified in the gateway's configuration at the time the proof was generated"
  gatewayAppName: String!

  """
  The signature of the proof
  The payload is a JSON-encoded object with the following properties:
  - `gatewayAppName`: The name of the gateway (gatewayAppName)
  - `gatewayAccountId`: The ID of the gateway account (connectedAccount.account.id)
  - `joystreamAccountId`: The address of the Joystream account (connectedAccount.id)
  - `timestamp`: The unix timestamp at which the proof was generated (timestamp)
  """
  signature: String!
}

enum TokenType {
  EMAIL_CONFIRMATION
}

type Token @entity {
  "The token itself (32-byte string, securely random)"
  id: ID!

  "Type of the token (its intended purpose)"
  type: TokenType!

  "When was the token issued"
  issuedAt: DateTime!

  "When does the token expire or when has it expired"
  expiry: DateTime!

  "The account the token was issued for"
  issuedFor: Account!
}
