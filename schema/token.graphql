enum TokenStatus {
  SALE
  MARKET
  IDLE
}

type Token @entity {
  "runtime token identifier"
  id: ID!

  "status sale / market / idle"
  status: TokenStatus!

  "total supply"
  totalSupply: BigInt!

  "Whether a sale is ongoing"
  sale: [Sale!] @derivedFrom(field: "token")

  "symbol for the token uniqueness guaranteed by runtime"
  symbol: String! @index @unique

  "access status invite only vs anyone"
  isInviteOnly: Boolean!

  "creator annual revenue percent (minted)"
  patronageRatePercent: Int!

  "revenue share ratio between creator and holder"
  revenueShareRatioPercent: Int!

  "current revenue share id if any"
  revenueShare: [RevenueShare!] @derivedFrom(field: "token")

  "amm curve setup for token"
  ammCurve: [AmmCurve!] @derivedFrom(field: "token")

  "block in which this token was created"
  createdIn: Int!

  "channel from which the token is issued uniqueness guaranteed by runtime"
  channel: Channel! @index @unique

  "video for the token presentation page"
  trailerVideo: Video

  "about information displayed under the presentation video"
  description: String

  "list of benefits for the token"
  benefits: [Benefit!] @derivedFrom(field: "token")

  "whitelisted members"
  whitelistedAccounts: [TokenAccount!] @derivedFrom(field: "token")

  "note from creator to member interested in joining the whitelist"
  whitelistApplicantNote: String

  "link for creator to member interested in joining the whitelist"
  whitelisteApplicantLink: String

  "initial allocation for users"
  holdersAllocations: [Allocation!] @derivedFrom(field: "token")

  "cliff blocks before allocation vesting starts"
  alloactionCliff: Int!

  "duration for the vesting period after the cliff"
  allocationVestingDuration: Int!

  "% of allocation released right after the cliff to the creator"
  firstPayoutPercent: Int!

  "holders having some amount of this token"
  accounts: [TokenAccount!] @derivedFrom(field: "token")

  "creator account for faster lookup"
  creatorAccount: TokenAccount!
}

type RevenueShare @entity {
  "tokenId ++ runtime id for revenue split"
  id: ID!

  "token which this revenue share is for"
  token: Token!

  "list of participating members"
  stakers: [RevenueShareParticipation!] @derivedFrom(field: "revenueShare")

  "block at which the revenue share was issued"
  createdIn: Int!

  "starting block"
  startingAt: Int!

  "duration"
  duration: Int!
}

type Benefit @entity {
  "counter"
  id: ID!

  "token the benefit is for"
  token: Token!

  "emoji for the benefit"
  emojiCode: Int

  "title for the benefit"
  title: String!

  "description for the benefit"
  description: String!

  "order in which the benefits is displayed"
  displayOrder: Int!
}

type Sale @entity @index(fields: ["token", "createdIn"], unique: true) {
  "runtime TokenId ++ runtime sale nonce"
  id: ID!

  "token for which the sale is issued"
  token: Token!

  "constant price in HAPI for each token"
  pricePerUnit: BigInt!

  "total amount of token on sale"
  tokenSaleallocation: BigInt!

  "amount of tokens that has been sold"
  tokensSold: BigInt!

  "creation block"
  createdIn: Int!

  "sale start block"
  startBlock: Int!

  "sale duration"
  durationInBlocks: Int!

  "vesting schedule configuration"
  vesting: VestedSale @derivedFrom(field: "sale")

  "terms and conditions text"
  termsAndConditions: String!

  "max amount that member can purchase"
  maxAmountPerMember: BigInt

  "transactions references"
  transactions: [SaleTransaction!] @derivedFrom(field: "sale")
}

type Allocation @entity @index(fields: ["token", "account"], unique: true) {
  "counter"
  id: ID!

  "token issued"
  token: Token! @unique

  "creator token account"
  account: TokenAccount! @unique

  "allocation for the creator"
  amount: BigInt!

  "vesting schedule configuration"
  vesting: VestedAllocation @derivedFrom(field: "allocation")
}

type VestedSale @entity @index(fields: ["vesting", "sale"], unique: true) {
  "counter"
  id: ID!

  "vesting schedule reference"
  vesting: VestingSchedule! @unique

  "sale reference"
  sale: Sale! @unique
}

type VestedAllocation @entity @index(fields: ["vesting", "allocation"], unique: true) {
  "counter"
  id: ID!

  "vesting schedule reference"
  vesting: VestingSchedule! @unique

  "sale reference"
  allocation: Allocation! @unique
}
type VestingSchedule @entity {
  "counter "
  id: ID!

  "the schedule might refers to a sale"
  sale: VestedSale @derivedFrom(field: "vesting")

  "the schedule might refer to an initial allocation vesting"
  allocation: VestedAllocation @derivedFrom(field: "vesting")

  "% of amount vested immediately after cliff period"
  cliffPercent: Int!

  "vesting duration in blocks"
  vestingDurationBlocks: Int!

  "cliff duration in blocks"
  cliffDurationBlocks: Int!
}

type SaleTransaction @entity @index(fields: ["sale", "account"], unique: true) {
  "counter"
  id: ID!

  "amount of token bought"
  quantity: BigInt!

  "total HAPI paid for the quantity"
  pricePaid: BigInt!

  "sale"
  sale: Sale!

  "buyer account"
  account: TokenAccount!
}

type AmmCurve @entity {
  "counter"
  id: ID!

  "token this Amm is for"
  token: Token!

  "quantity bought on the market by the amm"
  burnedByAmm: BigInt!

  "quantity sold to the market"
  mintedByAmm: BigInt!

  "the amm slope parameter a in the formula a * x + b"
  ammSlopeParameter: BigInt!

  "the amm intercept parameter b in the formula a * x + b"
  ammInitPrice: BigInt!

  "transaction for this amm"
  transactions: [AmmTransaction!] @derivedFrom(field: "amm")
}

type AmmTransaction @entity @index(fields: ["account", "amm"], unique: true) {
  "counter"
  id: ID!

  "amount of token bought"
  quantity: BigInt!

  "total HAPI paid for the quantity"
  pricePaid: BigInt!

  "sale"
  amm: AmmCurve!

  "buyer account"
  account: TokenAccount!

  "price per unit in HAPI"
  pricePerUnit: BigInt!

  "was it bought (or sold)"
  transactionType: AmmTransactionType!
}

enum AmmTransactionType {
  BUY
  SELL
}

type TokenAccount @entity @index(fields: ["token", "member"], unique: true) {
  "runtime token id ++ runtime member id"
  id: ID!

  "member id"
  member: Membership!

  "token for which the account is created"
  token: Token!

  "bloat bond payed at account creation"
  tokenAccountBloatBond: BigInt!

  "total token amount (not necessarely liqud) for the account"
  totalAmount: BigInt!

  "amount allocated at token creation"
  allocation: Allocation @derivedFrom(field: "account")

  "percentage of supply owned by this account TODO(move this to BigDecimal)"
  supplyPercent: BigInt!

  "sale transactions for this account"
  saleTransactions: [SaleTransaction!] @derivedFrom(field: "account")

  "amm transactions for this account"
  ammTransactions: [AmmTransaction!] @derivedFrom(field: "account")

  "information for token accounts participating in revenue share"
  revenueShareParticipation: [RevenueShareParticipation!] @derivedFrom(field: "account")
}

type RevenueShareParticipation @entity @index(fields: ["account", "revenueShare"], unique: true) {
  "counter"
  id: ID!

  "participating Account"
  account: TokenAccount!

  "revenue share the account is participating in"
  revenueShare: RevenueShare!

  "staked amount"
  stakedAmount: BigInt!

  "eearned joy amounts"
  earnings: BigInt!
}
