enum TokenStatus {
  SALE
  MARKET
  IDLE
}

type TokenAvatarObject @variant {
  "The avatar data object"
  avatarObject: StorageDataObject!
}

type TokenAvatarUri @variant {
  "The avatar URL"
  avatarUri: String!
}

union TokenAvatar = TokenAvatarObject | TokenAvatarUri

type Token @entity {
  "runtime token identifier"
  id: ID!

  "status sale / market / idle"
  status: TokenStatus!

  "avatar object (profile picture)"
  avatar: TokenAvatar

  "total supply"
  totalSupply: BigInt!

  "Whether a sale is ongoing"
  sale: [Sale!] @derivedFrom(field: "token")

  "symbol for the token uniqueness guaranteed by runtime"
  symbol: String! @index @unique

  "access status invite only vs anyone"
  isInviteOnly: Boolean!

  "creator annual revenue percent (minted)"
  annualCreatorReward: BigInt!

  "revenue share ratio between creator and holder"
  revenueShareRatioPercent: Int!

  "current revenue share id if any"
  revenueShare: [RevenueShare!] @derivedFrom(field: "token")

  "amm curve setup for token"
  ammCurve: [AmmCurve!] @derivedFrom(field: "token")

  "block in which this token was created"
  createdAt: DateTime!

  "channel from which the token is issued uniqueness guaranteed by runtime"
  channel: TokenChannel @derivedFrom(field: "token")

  "video for the token presentation page"
  trailerVideo: Video

  "about information displayed under the presentation video"
  description: String

  "list of benefits for the token"
  benefits: [Benefit!] @derivedFrom(field: "token")

  "note from creator to member interested in joining the whitelist"
  whitelistApplicantNote: String

  "link for creator to member interested in joining the whitelist"
  whitelistApplicantLink: String

  "holders having some amount of this token"
  accounts: [TokenAccount!] @derivedFrom(field: "token")

  "number of accounts to avoid aggregate COUNT"
  accountsNum: Int!

  "number of completed Amm Sales"
  ammNonce: Int!

  "number of revenue shares issued"
  revenueShareNonce: Int!

  "whether it has been deissued or not"
  deissued: Boolean!
}

type TokenChannel @entity @index(fields: ["token", "channel"], unique: true) {
  "token reference"
  token: Token! @unique

  "channel reference"
  channel: Channel! @unique
}

type RevenueShare @entity {
  "tokenId ++ runtime id for revenue split"
  id: ID!

  "token which this revenue share is for"
  token: Token!

  "list of participating members"
  stakers: [RevenueShareParticipation!] @derivedFrom(field: "revenueShare")

  "block at which the revenue share was issued"
  createdIn: Int!

  "starting block"
  startingAt: Int!

  "duration"
  duration: Int!

  "ending block"
  endsAt: Int!

  "Number of participant to aggregating COUNT on stackers"
  participantsNum: Int!

  "total number of HAPI allocated"
  allocation: BigInt!

  "amounts claimed so far in order to avoid SUM aggregations"
  claimed: BigInt!

  "finalized"
  finalized: Boolean!
}

type Benefit @entity {
  "counter"
  id: ID!

  "token the benefit is for"
  token: Token!

  "emoji for the benefit"
  emojiCode: String

  "title for the benefit"
  title: String!

  "description for the benefit"
  description: String!

  "order in which the benefits is displayed"
  displayOrder: Int!
}

type Sale @entity @index(fields: ["token", "createdIn"], unique: true) {
  "runtime TokenId ++ runtime sale nonce"
  id: ID!

  "token for which the sale is issued"
  token: Token!

  "constant price in HAPI for each token"
  pricePerUnit: BigInt!

  "total amount of token on sale"
  tokenSaleAllocation: BigInt!

  "amount of tokens that has been sold"
  tokensSold: BigInt!

  "creation block"
  createdIn: Int!

  "sale start block"
  startBlock: Int!

  "sale duration"
  durationInBlocks: Int!

  "ending block"
  endsAt: Int!

  "terms and conditions text"
  termsAndConditions: String!

  "max amount that member can purchase"
  maxAmountPerMember: BigInt

  "transactions references"
  transactions: [SaleTransaction!] @derivedFrom(field: "sale")

  "finalized"
  finalized: Boolean!

  "vesting schedule for sale"
  vestedSale: VestedSale @derivedFrom(field: "sale")

  "sale funds source"
  fundsSourceAccount: TokenAccount!
}

type VestedSale @entity @index(fields: ["sale", "vesting"], unique: true) {
  "Sale.id ++ VestingSchedule.id"
  id: ID!

  "Sale reference"
  sale: Sale! @unique

  "vesting schedule reference"
  vesting: VestingSchedule! @unique
}

type SaleTransaction @entity @index(fields: ["sale", "account"], unique: true) {
  "counter"
  id: ID!

  "amount of token bought"
  quantity: BigInt!

  "total HAPI paid for the quantity"
  pricePaid: BigInt!

  "sale"
  sale: Sale!

  "buyer account"
  account: TokenAccount!

  "block"
  createdIn: Int!
}

type AmmCurve @entity {
  "token.ammNonce"
  id: ID!

  "token this Amm is for"
  token: Token!

  "quantity bought on the market by the amm"
  burnedByAmm: BigInt!

  "quantity sold to the market"
  mintedByAmm: BigInt!

  "the amm slope parameter a in the formula a * x + b"
  ammSlopeParameter: BigInt!

  "the amm intercept parameter b in the formula a * x + b"
  ammInitPrice: BigInt!

  "transaction for this amm"
  transactions: [AmmTransaction!] @derivedFrom(field: "amm")

  "finalized (i.e. closed)"
  finalized: Boolean!
}

type AmmTransaction @entity @index(fields: ["account", "amm"], unique: true) {
  "counter"
  id: ID!

  "amount of token bought"
  quantity: BigInt!

  "total HAPI paid for the quantity"
  pricePaid: BigInt!

  "sale"
  amm: AmmCurve!

  "buyer account"
  account: TokenAccount!

  "price per unit in HAPI"
  pricePerUnit: BigInt!

  "was it bought (or sold)"
  transactionType: AmmTransactionType!

  "block"
  createdIn: Int!
}

enum AmmTransactionType {
  BUY
  SELL
}

type TokenAccount @entity @index(fields: ["token", "member"], unique: true) {
  "runtime token id ++ runtime member id"
  id: ID!

  "member id ref"
  member: Membership!

  "token for which the account is created"
  token: Token!

  "staked amount, to avoid walking to split participations"
  stakedAmount: BigInt!

  "total token amount (not necessarely liqud) for the account"
  totalAmount: BigInt!

  "sale transactions for this account"
  saleTransactions: [SaleTransaction!] @derivedFrom(field: "account")

  "amm transactions for this account"
  ammTransactions: [AmmTransaction!] @derivedFrom(field: "account")

  "information for token accounts participating in revenue share"
  revenueShareParticipation: [RevenueShareParticipation!] @derivedFrom(field: "account")

  "vesting schedule info, it can be empty if no vesting schedules are pending"
  vestingSchedules: [VestedAccount!]! @derivedFrom(field: "account")

  "whether the account belongs to the account whitelist (if mode is invite only)"
  whitelisted: Boolean

  "has been deleted or not"
  deleted: Boolean!
}

type VestedAccount @entity {
  "counter"
  id: ID!

  "vesting schedule reference"
  vesting: VestingSchedule!

  "account reference"
  account: TokenAccount!

  "amount vested"
  amount: BigInt!
}

type VestingSchedule @entity {
  "cliffBlock++vestingduration++cliffPercent is enough to identify a schedule"
  id: ID!

  "% of amount vested immediately after cliff period"
  cliffPercent: Int!

  "vesting duration in blocks"
  vestingDurationBlocks: Int!

  "cliff duration in blocks"
  cliffDurationBlocks: Int!

  "vesting ending block"
  endsAt: Int!

  "cliff block"
  cliffBlock: Int!

  "accounts reference"
  accounts: [VestedAccount!] @derivedFrom(field: "vesting")

  "vesting schedule for sale"
  vestedSale: VestedSale @derivedFrom(field: "vesting")
}

type RevenueShareParticipation @entity @index(fields: ["account", "revenueShare"], unique: true) {
  "counter"
  id: ID!

  "participating Account"
  account: TokenAccount!

  "revenue share the account is participating in"
  revenueShare: RevenueShare!

  "staked amount"
  stakedAmount: BigInt!

  "eearned joy amounts"
  earnings: BigInt!

  "block"
  createdIn: Int!
}
