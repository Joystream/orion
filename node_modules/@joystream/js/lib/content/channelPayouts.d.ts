import { ChannelPayoutsMetadata } from '@joystream/metadata-protobuf';
import { PalletCommonMerkleTreeProofElementRecord as ProofElement, PalletContentPullPaymentElement } from '@polkadot/types/lookup';
import { blake2AsU8a } from '@polkadot/util-crypto';
import { ChannelPayoutProof } from '../../typings/ChannelPayoutsPayload.schema';
import { ChannelPayoutsVector } from '../../typings/ChannelPayoutsVector.schema';
import { ReadFileContext } from '../utils';
export declare const hashFunc: typeof blake2AsU8a;
/**
 * Get Payout Proof for given channel from
 * remote source or file
 * @param context "PATH" | "URL"
 * @param pathOrUrl
 * @param channelId Id of the channel
 * @returns payout proof record for given channel Id
 */
export declare function channelPayoutProof(context: ReadFileContext, pathOrUrl: string, channelId: number): Promise<ChannelPayoutsMetadata.Body.ChannelPayoutProof>;
/**
 * Get Payout Proof for given channel from
 * remote source or file
 * @param channelId Id of the channel
 * @param payoutProof payoutProof record of given channel
 * @returns SCALE codec args for claimChannelReward extrinsic
 */
export declare function prepareClaimChannelRewardExtrinsicArgs(payoutProof: ChannelPayoutsMetadata.Body.ChannelPayoutProof): {
    pullPayment: PalletContentPullPaymentElement;
    proofElements: ProofElement[];
};
/**
 * Get serialized payload header from a local file.
 * @param context "PATH" | "URL"
 * @param pathOrUrl path to protobuf serialized payload file
 * @return bytes of payload header
 **/
export declare function serializedPayloadHeader(context: ReadFileContext, pathOrUrl: string): Promise<Uint8Array>;
/**
 * Get channel payout Proof from local serialized payload file.
 * @param context "PATH" | "URL"
 * @param pathOrUrl path to protobuf serialized payload file
 * @param byteOffset byte offset of channel payout Proof in serialized payload
 * @return channel payout Proof
 **/
export declare function channelPayoutProofAtByteOffset(context: ReadFileContext, pathOrUrl: string, byteOffset: number): Promise<ChannelPayoutsMetadata.Body.ChannelPayoutProof>;
/**
 * Generate merkle root from the serialized payload
 * @param context "PATH" | "URL"
 * @param pathOrUrl path to protobuf serialized payload file
 * @returns merkle root of the cashout vector
 */
export declare function generateCommitmentFromPayloadFile(context: ReadFileContext, pathOrUrl: string): Promise<string>;
/**
 * Generate merkle root from branch of a channel payout proof
 * @param proof channel payout proof record
 * @returns commitment (merkle root) of the cashout payload
 */
export declare function verifyChannelPayoutProof(proof: ChannelPayoutsMetadata.Body.ChannelPayoutProof): string;
export declare function generateJsonPayloadFromPayoutsVector(channelPayoutsVector: ChannelPayoutsVector): [string, ChannelPayoutProof[]];
/**
 * Generate serialized payload from JSON encoded channel payouts.
 * @param channelPayoutProofs JSON object containing channel payout proofs
 * @returns serialized channel payouts payload
 */
export declare function generateSerializedPayload(channelPayoutProofs: ChannelPayoutProof[]): Uint8Array;
