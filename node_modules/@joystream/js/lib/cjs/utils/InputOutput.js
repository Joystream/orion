"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateInput = exports.getInputJson = exports.readBytesFromFile = void 0;
const tslib_1 = require("tslib");
const ajv_1 = tslib_1.__importDefault(require("ajv"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs_1 = tslib_1.__importDefault(require("fs"));
/**
 * Read sequence of bytes from the file or remote host
 * provided path. Both `start` and `end` are inclusive
 * @param context path to the file
 * @param pathOrUrl
 * @param start starting index of the range
 * @param end ending index of the range
 * @returns byte sequence
 */
function readBytesFromFile(context, pathOrUrl, start, end) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            if (context === 'PATH') {
                return new Promise((resolve) => {
                    const a = fs_1.default.createReadStream(pathOrUrl, { start, end }).on('data', (data) => {
                        resolve(data);
                        a.close();
                    });
                });
            }
            const response = yield axios_1.default.get(pathOrUrl, {
                responseType: 'arraybuffer',
                headers: {
                    range: `bytes=${start}-${end}`,
                },
            });
            return new Uint8Array(response.data);
        }
        catch (error) {
            throw new Error(`Failed to read input stream`);
        }
    });
}
exports.readBytesFromFile = readBytesFromFile;
function getInputJson(inputPath, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let content, jsonObj;
        try {
            content = fs_1.default.readFileSync(inputPath).toString();
        }
        catch (e) {
            throw new Error(`Cannot access the input file at: ${inputPath}`);
        }
        try {
            jsonObj = JSON.parse(content);
        }
        catch (e) {
            throw new Error(`JSON parsing failed for file: ${inputPath}`);
        }
        if (schema) {
            yield validateInput(jsonObj, schema);
        }
        return jsonObj;
    });
}
exports.getInputJson = getInputJson;
function validateInput(input, schema) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const ajv = new ajv_1.default({ allErrors: true });
        const valid = ajv.validate(schema, input);
        if (!valid) {
            throw new Error(`Input JSON file is not valid:\n` +
                ((_a = ajv.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `${e.dataPath}: ${e.message} (${JSON.stringify(e.params)})`).join('\n')));
        }
    });
}
exports.validateInput = validateInput;
