"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSerializedPayload = exports.generateJsonPayloadFromPayoutsVector = exports.verifyChannelPayoutProof = exports.generateCommitmentFromPayloadFile = exports.channelPayoutProofAtByteOffset = exports.serializedPayloadHeader = exports.prepareClaimChannelRewardExtrinsicArgs = exports.channelPayoutProof = exports.hashFunc = void 0;
const tslib_1 = require("tslib");
const metadata_protobuf_1 = require("@joystream/metadata-protobuf");
const types_1 = require("@joystream/types");
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const bn_js_1 = tslib_1.__importDefault(require("bn.js"));
const long_1 = tslib_1.__importDefault(require("long"));
const merkletreejs_1 = require("merkletreejs");
const protobufjs_1 = require("protobufjs");
const utils_1 = require("../utils");
const buffer_1 = require("buffer");
exports.hashFunc = util_crypto_1.blake2AsU8a;
/**
 * Get Payout Proof for given channel from
 * remote source or file
 * @param context "PATH" | "URL"
 * @param pathOrUrl
 * @param channelId Id of the channel
 * @returns payout proof record for given channel Id
 */
function channelPayoutProof(context, pathOrUrl, channelId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const serializedHeader = yield serializedPayloadHeader(context, pathOrUrl);
        const header = metadata_protobuf_1.ChannelPayoutsMetadata.Header.decode(serializedHeader);
        const channelPayoutProofOffset = header.channelPayoutByteOffsets.find((o) => o.channelId === channelId);
        if (!channelPayoutProofOffset) {
            throw new Error(`No payout Proof exists for channel id ${channelId}`);
        }
        return channelPayoutProofAtByteOffset(context, pathOrUrl, Number(channelPayoutProofOffset.byteOffset));
    });
}
exports.channelPayoutProof = channelPayoutProof;
/**
 * Get Payout Proof for given channel from
 * remote source or file
 * @param channelId Id of the channel
 * @param payoutProof payoutProof record of given channel
 * @returns SCALE codec args for claimChannelReward extrinsic
 */
function prepareClaimChannelRewardExtrinsicArgs(payoutProof) {
    // Prepare extrinsic arguments
    const pullPayment = (0, types_1.createType)('PalletContentPullPaymentElement', {
        channelId: payoutProof.channelId,
        cumulativeRewardEarned: new bn_js_1.default(payoutProof.cumulativeRewardEarned),
        reason: (0, util_1.u8aToHex)(buffer_1.Buffer.from(payoutProof.reason, 'hex')),
    });
    const proofElements = [];
    payoutProof.merkleBranch.forEach((m) => {
        const proofElement = (0, types_1.createType)('PalletCommonMerkleTreeProofElementRecord', {
            hash_: (0, util_1.u8aToHex)(buffer_1.Buffer.from(m.hash, 'hex')),
            side: m.side ? { Right: null } : { Left: null },
        });
        proofElements.push(proofElement);
    });
    return { pullPayment, proofElements };
}
exports.prepareClaimChannelRewardExtrinsicArgs = prepareClaimChannelRewardExtrinsicArgs;
/**
 * PROTOBUF MESSAGE STRUCTURE
 *
 * ----------------------------------------
 * | Tag(key) | Size | Serialized Message |
 * ----------------------------------------
 * @tag Type info, and field number of message
 * @size Size of the message encoded as varint
 * @message Serialized message
 */
/**
 * calculates byte length of message `size` - encoded as varint. Protobuf encodes the
 * message as `varint_encoded_message_size+serialized_message` e.g., for serialized
 * message of 10 bytes, protobuf encoded message would look like: `0a+0b0c0d0e0f1a1b1c1d1e`.
 * Since `size` of example message is encoded in 1 byte so the function will return 1.
 * @param protobufMessageLength length of serialized message in number of bytes
 * @return length of varint encoded message size in number of bytes
 */
function lengthOfVarintEncodedMessageSize(protobufMessageLength) {
    return protobufjs_1.Writer.create().uint32(protobufMessageLength).finish().byteLength;
}
/**
 * We don't have any prior knowledge of how many bytes are used to encode the size information of the message,
 * so we arbitrary read `n` bytes from the payload based on the assumption that the size of the header CAN BE
 * encoded in `n` bytes. For reference, if serialized message is over 4 TB then its size information can be
 * encoded in just 6 bytes
 * @param context "PATH" | "URL"
 * @param pathOrUrl path to protobuf serialized payload file
 * @param messageOffset byte offset of message in serialized payload
 * @returns length of serialized message in number of bytes
 */
function lengthOfProtobufMessage(context, pathOrUrl, messageOffset) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // TODO: improve the implementation by reading size info byte by byte
        // TODO: and checking most significant bit (msb) of each byte.
        const arbitraryBytes = yield (0, utils_1.readBytesFromFile)(context, pathOrUrl, messageOffset, messageOffset + 10);
        const lengthOfMessage = protobufjs_1.Reader.create(arbitraryBytes).uint32();
        return lengthOfMessage;
    });
}
// calculates byte length of the serialized payload header
function lengthOfHeader(numberOfChannels) {
    // protobuf serializes fields in (key,value) pairs. Tag(key)
    // length will be one byte for all fields in this payload
    const byteLengthOfTag = 1;
    // P: byte length of entire payload
    // H: byte length of header
    // N: number of channels
    // N times: serialized c_i||offset_i
    const payloadLengthFieldSize = 8;
    const payloadHeaderLengthFieldSize = 8;
    const numberOfChannelsFieldSize = 4;
    const byteLengthOfByteOffsetsArray = numberOfChannels * (byteLengthOfTag + 4 + byteLengthOfTag + 8);
    return (payloadLengthFieldSize + payloadHeaderLengthFieldSize + numberOfChannelsFieldSize + byteLengthOfByteOffsetsArray);
}
/**
 * Get serialized payload header from a local file.
 * @param context "PATH" | "URL"
 * @param pathOrUrl path to protobuf serialized payload file
 * @return bytes of payload header
 **/
function serializedPayloadHeader(context, pathOrUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // skip the first byte which is the Tag(key) of `Header` message
        const lengthOfSerializedHeader = yield lengthOfProtobufMessage(context, pathOrUrl, 1);
        const lengthOfVarintEncodedHeaderSize = lengthOfVarintEncodedMessageSize(lengthOfSerializedHeader);
        const serializedHeader = yield (0, utils_1.readBytesFromFile)(context, pathOrUrl, 1 + lengthOfVarintEncodedHeaderSize, lengthOfVarintEncodedHeaderSize + lengthOfSerializedHeader);
        return serializedHeader;
    });
}
exports.serializedPayloadHeader = serializedPayloadHeader;
/**
 * Get channel payout Proof from local serialized payload file.
 * @param context "PATH" | "URL"
 * @param pathOrUrl path to protobuf serialized payload file
 * @param byteOffset byte offset of channel payout Proof in serialized payload
 * @return channel payout Proof
 **/
function channelPayoutProofAtByteOffset(context, pathOrUrl, byteOffset) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const lengthOfSerializedProof = yield lengthOfProtobufMessage(context, pathOrUrl, byteOffset);
        const lengthOfVarintEncodedProofSize = lengthOfVarintEncodedMessageSize(lengthOfSerializedProof);
        const serializedPayoutProof = yield (0, utils_1.readBytesFromFile)(context, pathOrUrl, byteOffset + lengthOfVarintEncodedProofSize, byteOffset + lengthOfSerializedProof + 1);
        const proof = metadata_protobuf_1.ChannelPayoutsMetadata.Body.ChannelPayoutProof.decode(serializedPayoutProof);
        return proof;
    });
}
exports.channelPayoutProofAtByteOffset = channelPayoutProofAtByteOffset;
/**
 * Generate merkle root from the serialized payload
 * @param context "PATH" | "URL"
 * @param pathOrUrl path to protobuf serialized payload file
 * @returns merkle root of the cashout vector
 */
function generateCommitmentFromPayloadFile(context, pathOrUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const serializedHeader = yield serializedPayloadHeader(context, pathOrUrl);
        const header = metadata_protobuf_1.ChannelPayoutsMetadata.Header.decode(serializedHeader);
        // Any payout Proof can be used to generate the merkle root,
        // here first Proof from channel payouts payload is used
        const ProofByteOffset = header.channelPayoutByteOffsets.shift().byteOffset.toNumber();
        const proof = yield channelPayoutProofAtByteOffset(context, pathOrUrl, ProofByteOffset);
        return verifyChannelPayoutProof(proof);
    });
}
exports.generateCommitmentFromPayloadFile = generateCommitmentFromPayloadFile;
/**
 * Generate merkle root from branch of a channel payout proof
 * @param proof channel payout proof record
 * @returns commitment (merkle root) of the cashout payload
 */
function verifyChannelPayoutProof(proof) {
    // item = c_i||p_i||m_i
    const item = (0, exports.hashFunc)(buffer_1.Buffer.concat([
        (0, types_1.createType)('u64', proof.channelId).toU8a(),
        (0, types_1.createType)('u128', new bn_js_1.default(proof.cumulativeRewardEarned)).toU8a(),
        buffer_1.Buffer.from(proof.reason, 'hex'),
    ]));
    const merkleRoot = proof.merkleBranch.reduce((res, proofElement) => {
        if (proofElement.side === metadata_protobuf_1.ChannelPayoutsMetadata.Body.ChannelPayoutProof.Side.Right) {
            return (0, exports.hashFunc)(buffer_1.Buffer.concat([res, buffer_1.Buffer.from(proofElement.hash, 'hex')]));
        }
        else {
            return (0, exports.hashFunc)(buffer_1.Buffer.concat([buffer_1.Buffer.from(proofElement.hash, 'hex'), res]));
        }
    }, item);
    return (0, util_1.u8aToHex)(merkleRoot);
}
exports.verifyChannelPayoutProof = verifyChannelPayoutProof;
function generateJsonPayloadFromPayoutsVector(channelPayoutsVector) {
    const generateLeaf = (p) => {
        return (0, exports.hashFunc)(buffer_1.Buffer.concat([
            (0, types_1.createType)('u64', p.channelId).toU8a(),
            (0, types_1.createType)('u128', new bn_js_1.default(p.cumulativeRewardEarned)).toU8a(),
            (0, exports.hashFunc)((0, types_1.createType)('Bytes', p.reason).toU8a()),
        ]));
    };
    const leaves = channelPayoutsVector.map(generateLeaf);
    const tree = new merkletreejs_1.MerkleTree(leaves, exports.hashFunc);
    const channelPayouts = channelPayoutsVector.map((p, i) => {
        // merkle proof for each Payout
        const merkleProof = tree.getProof(buffer_1.Buffer.from(leaves[i]));
        const merkleBranch = merkleProof.map(({ data, position }) => {
            return {
                hash: data.toString('hex'),
                side: position === 'left' ? 0 : 1,
            };
        });
        return {
            channelId: p.channelId,
            cumulativeRewardEarned: p.cumulativeRewardEarned,
            merkleBranch,
            reason: buffer_1.Buffer.from((0, exports.hashFunc)((0, types_1.createType)('Bytes', p.reason).toU8a())).toString('hex'),
        };
    });
    return [tree.getHexRoot(), channelPayouts];
}
exports.generateJsonPayloadFromPayoutsVector = generateJsonPayloadFromPayoutsVector;
/**
 * Generate serialized payload from JSON encoded channel payouts.
 * @param channelPayoutProofs JSON object containing channel payout proofs
 * @returns serialized channel payouts payload
 */
function generateSerializedPayload(channelPayoutProofs) {
    var _a;
    if (channelPayoutProofs.length === 0)
        throw new Error('payload is empty');
    const numberOfChannels = channelPayoutProofs.length;
    const headerLengthInBytes = long_1.default.fromNumber(lengthOfHeader(numberOfChannels));
    const channelPayoutByteOffsets = [];
    const body = (0, utils_1.asValidatedMetadata)(metadata_protobuf_1.ChannelPayoutsMetadata.Body, { channelPayouts: channelPayoutProofs });
    // Length of Header is known prior to serialization since its fields are fixed size, however the
    // length of the COMPLETE payload can only be known after it has been serialized since Body fields
    // are varint encoded.
    // So we can't set payload length & byte offsets, to resolve this issue payload will be serialized
    // with empty payload length & byte offsets, and once serialized both unknowns can be obtained
    // from payload
    (_a = body.channelPayouts) === null || _a === void 0 ? void 0 : _a.forEach(({ channelId }) => {
        channelPayoutByteOffsets.push({ channelId, byteOffset: long_1.default.fromNumber(0) });
    });
    const payload = {
        header: {
            payloadLengthInBytes: long_1.default.fromNumber(0),
            headerLengthInBytes,
            numberOfChannels,
            channelPayoutByteOffsets,
        },
        body,
    };
    const serializedPayloadWithEmptyHeaderFields = buffer_1.Buffer.from(metadata_protobuf_1.ChannelPayoutsMetadata.encode(payload).finish());
    const payloadLengthInBytes = long_1.default.fromNumber(serializedPayloadWithEmptyHeaderFields.byteLength);
    for (let i = 0; i < numberOfChannels; i++) {
        const channelPayoutProof = metadata_protobuf_1.ChannelPayoutsMetadata.Body.ChannelPayoutProof.encode(body.channelPayouts[i]).finish();
        const indexOfChannelPayoutProof = serializedPayloadWithEmptyHeaderFields.indexOf(channelPayoutProof);
        // set correct byteOffsets
        payload.header.channelPayoutByteOffsets[i].byteOffset = long_1.default.fromNumber(indexOfChannelPayoutProof - lengthOfVarintEncodedMessageSize(buffer_1.Buffer.from(channelPayoutProof).byteLength));
    }
    // set correct payload length
    payload.header.payloadLengthInBytes = payloadLengthInBytes;
    // serialize payload again
    const serializedPayload = metadata_protobuf_1.ChannelPayoutsMetadata.encode(payload).finish();
    return serializedPayload;
}
exports.generateSerializedPayload = generateSerializedPayload;
