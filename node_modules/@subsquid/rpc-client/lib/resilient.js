"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRetryableError = exports.isRateLimitError = exports.ResilientRpcClient = void 0;
const util_timeout_1 = require("@subsquid/util-timeout");
const client_1 = require("./client");
class ResilientRpcClient {
    constructor(options) {
        this.options = options;
        this.errors = 0;
        this.backoff = [100, 500, 2000, 5000, 10000, 20000];
        this.closed = false;
        this.client = Promise.resolve(new client_1.RpcClient(options.url));
    }
    async call(method, params) {
        while (true) {
            let epoch = this.client;
            let client = await epoch;
            try {
                let result = await this.addTimeout(client.call(method, params));
                this.errors = 0;
                return result;
            }
            catch (e) {
                if (isRetryableError(e)) {
                    if (this.client === epoch) {
                        client.close(e);
                        this.reconnect(e);
                    }
                }
                else {
                    throw e;
                }
            }
        }
    }
    reconnect(err) {
        if (this.closed)
            throw err;
        this.errors += 1;
        if (this.errors > (this.options.maxRetries ?? Infinity)) {
            err = new client_1.RpcConnectionError(`Got ${this.errors} connection errors in a row. Last error: ${err.message}`);
            this.close(err);
            throw err;
        }
        let backoff = this.backoff[Math.min(this.errors, this.backoff.length) - 1];
        if (isRateLimitError(err)) {
            backoff += backoff * 2 + 5000;
        }
        this.client = new Promise(resolve => {
            setTimeout(() => {
                resolve(new client_1.RpcClient(this.options.url));
            }, backoff);
        });
        this.options.onRetry?.(err, this.errors, backoff);
    }
    addTimeout(res) {
        let seconds = this.options.timeoutSeconds || 20;
        return (0, util_timeout_1.addTimeout)(res, seconds, () => new client_1.RpcConnectionError(`Request timed out in ${seconds} seconds`));
    }
    close(err) {
        if (this.closed)
            return;
        this.closed = true;
        this.client.catch(() => { }).then(client => client?.close(err));
        this.client = Promise.reject(err || new Error('Closed'));
        this.client.catch(() => { });
    }
}
exports.ResilientRpcClient = ResilientRpcClient;
function isRateLimitError(err) {
    return err instanceof client_1.RpcError && /rate limit/i.test(err.message);
}
exports.isRateLimitError = isRateLimitError;
function isRetryableError(err) {
    return err instanceof client_1.RpcConnectionError || isRateLimitError(err);
}
exports.isRetryableError = isRetryableError;
//# sourceMappingURL=resilient.js.map