"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcConnectionError = exports.RpcError = exports.RpcProtocolError = exports.RpcClient = void 0;
const websocket_1 = require("websocket");
const MEGABYTE = 1024 * 1024;
class RpcClient {
    constructor(url) {
        this.url = url;
        this.ids = 0;
        this.requests = {};
        this.sendQueue = [];
        this._connected = false;
        this.ws = new websocket_1.w3cwebsocket(this.url, undefined, undefined, undefined, undefined, {
            // default: true
            fragmentOutgoingMessages: true,
            // default: 16K (bump, the Node has issues with too many fragments, e.g. on setCode)
            fragmentationThreshold: MEGABYTE,
            // default: 1MiB (also align with maxReceivedMessageSize)
            maxReceivedFrameSize: 24 * MEGABYTE,
            // default: 8MB (however Polkadot api.query.staking.erasStakers.entries(356) is over that, 16M is ok there)
            maxReceivedMessageSize: 24 * MEGABYTE
        });
        this.connection = new Promise((resolve, reject) => {
            this.ws.onopen = () => {
                this._connected = true;
                for (let i = 0; i < this.sendQueue.length; i++) {
                    this.ws.send(this.sendQueue[i]);
                }
                this.sendQueue.length = 0;
                resolve();
            };
            this.ws.onerror = () => {
                this.setError(new RpcConnectionError('Socket error'));
                reject(this.error);
            };
            this.ws.onclose = () => {
                let err = this.error || new RpcConnectionError('Connection terminated');
                this.setError(err);
                reject(err);
                this.onclose?.(err);
            };
        });
        this.connection.catch(err => { });
        this.ws.onmessage = event => {
            try {
                this.onMessage(event.data);
            }
            catch (e) {
                this.close(e);
            }
        };
    }
    onMessage(data) {
        // https://github.com/Luka967/websocket-close-codes
        if (typeof data != 'string') {
            throw new RpcProtocolError(1003, 'Received non-text frame');
        }
        let msg;
        try {
            msg = JSON.parse(data);
        }
        catch (e) {
            throw new RpcProtocolError(1007, 'Received invalid JSON message');
        }
        if (Array.isArray(msg)) {
            for (let i = 0; i < msg.length; i++) {
                this.handleResponse(msg[i]);
            }
        }
        else {
            this.handleResponse(msg);
        }
    }
    handleResponse(res) {
        // TODO: more strictness, more validation
        let h = this.requests[res.id];
        if (h == null) {
            throw new RpcProtocolError(undefined, `Got response for unknown request ${res.id}`);
        }
        delete this.requests[res.id];
        if (res.error) {
            h.reject(new RpcError(res.error));
        }
        else {
            h.resolve(res.result);
        }
    }
    close(err) {
        if (this.error)
            return;
        err = err || new RpcConnectionError('Connection was closed');
        this.setError(err);
        let code;
        if (err instanceof RpcProtocolError) {
            code = err.code;
        }
        this.ws.close(code);
    }
    setError(err) {
        if (this.error)
            return;
        this.error = err;
        this.rejectRequests(err);
        this.sendQueue.length = 0;
    }
    rejectRequests(err) {
        for (let key in this.requests) {
            this.requests[key].reject(err);
        }
        this.requests = {};
    }
    connect() {
        if (this.error)
            return Promise.reject(this.error);
        return this.connection;
    }
    get isConnected() {
        return this._connected && this.error == null;
    }
    call(method, params) {
        return new Promise((resolve, reject) => {
            if (this.error)
                return reject(this.error);
            let id = this.ids++;
            let payload = JSON.stringify({
                id: String(id),
                jsonrpc: '2.0',
                method,
                params
            });
            this.requests[id] = { resolve, reject };
            this.send(payload);
        });
    }
    batch(calls) {
        return new Promise((resolve, reject) => {
            if (this.error)
                return reject(this.error);
            if (calls.length == 0)
                return resolve([]);
            let results = new Array(calls.length);
            let received = 0;
            let offset = this.ids;
            function receive(id, error, result) {
                results[id - offset] = error || result;
                received += 1;
                if (results.length == received) {
                    resolve(results);
                }
            }
            let requests = {};
            let msg = calls.map(call => {
                let method;
                let params;
                if (typeof call == 'string') {
                    method = call;
                }
                else {
                    method = call[0];
                    params = call[1];
                }
                let id = this.ids++;
                requests[id] = {
                    resolve(val) {
                        receive(id, undefined, val);
                    },
                    reject(err) {
                        receive(id, err);
                    }
                };
                return {
                    id,
                    jsonrpc: '2.0',
                    method,
                    params
                };
            });
            let payload = JSON.stringify(msg);
            Object.assign(this.requests, requests);
            this.send(payload);
        });
    }
    send(payload) {
        if (this.ws.readyState == websocket_1.w3cwebsocket.OPEN) {
            this.ws.send(payload);
        }
        else {
            this.sendQueue.push(payload);
        }
    }
}
exports.RpcClient = RpcClient;
/**
 * Server violated RPC protocol
 */
class RpcProtocolError extends Error {
    constructor(code, msg) {
        super(msg);
        this.code = code;
    }
}
exports.RpcProtocolError = RpcProtocolError;
/**
 * Received error message from server
 */
class RpcError extends Error {
    constructor(info) {
        super(info.message);
        this.code = info.code;
        this.data = info.data;
    }
}
exports.RpcError = RpcError;
/**
 * Problem with websocket connection
 */
class RpcConnectionError extends Error {
}
exports.RpcConnectionError = RpcConnectionError;
//# sourceMappingURL=client.js.map