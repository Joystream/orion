export declare type Result<T, E> = {
    __kind: 'Ok';
    value: T;
} | {
    __kind: 'Err';
    value: E;
};
export declare type Option<T> = {
    __kind: 'Some';
    value: T;
} | {
    __kind: 'None';
};
export interface Chain {
    getEventHash(eventName: string): string;
    decodeEvent(event: Event): any;
    getCallHash(name: string): string;
    decodeCall(call: Call): any;
    getStorageItemTypeHash(prefix: string, name: string): string | undefined;
    getStorage(blockHash: string, prefix: string, name: string, ...args: any[]): Promise<any>;
    queryStorage2(blockHash: string, prefix: string, name: string, keyList?: any[]): Promise<any[]>;
    getKeys(blockHash: string, prefix: string, name: string, ...args: any[]): Promise<any[]>;
    getPairs(blockHash: string, prefix: string, name: string, ...args: any[]): Promise<any[]>;
    getKeysPaged(pageSize: number, blockHash: string, prefix: string, name: string, ...args: any[]): AsyncIterable<any[]>;
    getPairsPaged(pageSize: number, blockHash: string, prefix: string, name: string, ...args: any[]): AsyncIterable<[key: any, value: any][]>;
    getConstantTypeHash(pallet: string, name: string): string | undefined;
    getConstant(pallet: string, name: string): any;
}
export interface ChainContext {
    _chain: Chain;
}
export interface Event {
    name: string;
    args: any;
}
export interface EventContext extends ChainContext {
    event: Event;
}
export interface Call {
    name: string;
    args: any;
}
export interface CallContext extends ChainContext {
    call: Call;
}
export interface BlockContext extends ChainContext {
    block: Block;
}
export interface Block {
    hash: string;
}
export declare class StorageBase {
    protected readonly _chain: Chain;
    protected readonly blockHash: string;
    constructor(ctx: BlockContext);
    constructor(ctx: ChainContext, block: Block);
    protected getPrefix(): string;
    protected getName(): string;
    protected getTypeHash(): string | undefined;
    /**
     * Checks whether the storage item is defined for the current chain version.
     */
    get isExists(): boolean;
    protected get(...args: any[]): Promise<any>;
    protected getMany(keyList: any[]): Promise<any[]>;
    protected getAll(): Promise<any[]>;
    protected getKeys(...args: any[]): Promise<any[]>;
    protected getKeysPaged(pageSize: number, ...args: any[]): AsyncIterable<any[]>;
    protected getPairs(...args: any[]): Promise<[k: any, v: any][]>;
    protected getPairsPaged(pageSize: number, ...args: any[]): AsyncIterable<[k: any, v: any][]>;
}
//# sourceMappingURL=support.d.ts.map