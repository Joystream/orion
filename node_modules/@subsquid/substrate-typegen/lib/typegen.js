"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Typegen = void 0;
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const eac = __importStar(require("@subsquid/substrate-metadata/lib/events-and-calls"));
const typesBundle_1 = require("@subsquid/substrate-metadata/lib/old/typesBundle");
const storage_1 = require("@subsquid/substrate-metadata/lib/storage");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_code_printer_1 = require("@subsquid/util-internal-code-printer");
const util_naming_1 = require("@subsquid/util-naming");
const ifs_1 = require("./ifs");
const names_1 = require("./names");
const util_1 = require("./util");
class Typegen {
    constructor(options) {
        this.options = options;
        this.interfaces = new Map();
        this.dir = new util_internal_code_printer_1.OutDir(options.outDir);
    }
    static generate(options) {
        new Typegen(options).generate();
    }
    generate() {
        this.dir.del();
        this.generateEnums('events');
        this.generateEnums('calls');
        this.generateStorage();
        this.generateConsts();
        this.interfaces.forEach((ifs, v) => {
            if (ifs.isEmpty())
                return;
            let fileName = (0, util_naming_1.toCamelCase)(this.getVersionName(v)) + '.ts';
            let file = this.dir.file(fileName);
            file.line(`import type {Result, Option} from './support'`);
            ifs.generate(file);
            file.write();
        });
        this.dir.add('support.ts', [__dirname, '../src/support.ts']);
    }
    generateEnums(kind) {
        let items = this.collectItems(this.options[kind], chain => Object.entries(chain[kind].definitions).map(([name, def]) => {
            return { name, def, chain };
        }), (chain, name) => chain[kind].getHash(name));
        if (items.size == 0)
            return;
        let out = this.dir.file(`${kind}.ts`);
        let fix = kind == 'events' ? 'Event' : 'Call';
        let ctx = kind == 'events' ? 'event' : 'call';
        let names = Array.from(items.keys()).sort();
        out.line(`import assert from 'assert'`);
        out.line(`import {Chain, ChainContext, ${fix}Context, ${fix}, Result, Option} from './support'`);
        let importedInterfaces = this.importInterfaces(out);
        names.forEach(name => {
            let versions = items.get(name);
            let { def: { pallet, name: unqualifiedName } } = versions[0];
            let className = (0, util_1.upperCaseFirst)((0, util_naming_1.toCamelCase)(`${pallet}_${unqualifiedName}`)) + fix;
            out.line();
            out.block(`export class ${className}`, () => {
                out.line(`private readonly _chain: Chain`);
                out.line(`private readonly ${ctx}: ${fix}`);
                out.line();
                out.line(`constructor(ctx: ${fix}Context)`);
                out.line(`constructor(ctx: ChainContext, ${ctx}: ${fix})`);
                out.block(`constructor(ctx: ${fix}Context, ${ctx}?: ${fix})`, () => {
                    out.line(`${ctx} = ${ctx} || ctx.${ctx}`);
                    out.line(`assert(${ctx}.name === '${name}')`);
                    out.line(`this._chain = ctx._chain`);
                    out.line(`this.${ctx} = ${ctx}`);
                });
                versions.forEach(v => {
                    let versionName = this.getVersionName(v.chain);
                    let ifs = this.getInterface(v.chain);
                    let unqualifiedTypeExp;
                    if (v.def.fields[0]?.name == null) {
                        unqualifiedTypeExp = ifs.makeTuple(v.def.fields.map(f => f.type));
                    }
                    else {
                        unqualifiedTypeExp = `{${v.def.fields.map(f => `${f.name}: ${ifs.use(f.type)}`).join(', ')}}`;
                    }
                    let typeExp = this.qualify(importedInterfaces, v.chain, unqualifiedTypeExp);
                    out.line();
                    out.blockComment(v.def.docs);
                    out.block(`get is${versionName}(): boolean`, () => {
                        let hash = v.chain[kind].getHash(name);
                        out.line(`return this._chain.get${fix}Hash('${name}') === '${hash}'`);
                    });
                    out.line();
                    out.blockComment(v.def.docs);
                    out.block(`get as${versionName}(): ${typeExp}`, () => {
                        out.line(`assert(this.is${versionName})`);
                        out.line(`return this._chain.decode${fix}(this.${ctx})`);
                    });
                });
            });
        });
        out.write();
    }
    generateConsts() {
        let items = this.collectItems(this.options.constants, chain => {
            let items = [];
            let consts = chain.description.constants;
            for (let prefix in consts) {
                for (let name in consts[prefix]) {
                    items.push({
                        chain,
                        name: prefix + '.' + name,
                        def: consts[prefix][name]
                    });
                }
            }
            return items;
        }, (chain, name) => {
            let [prefix, itemName] = name.split('.');
            let def = chain.description.constants[prefix][itemName];
            return (0, substrate_metadata_1.getTypeHash)(chain.description.types, def.type);
        });
        if (items.size == 0)
            return;
        let out = this.dir.file(`constants.ts`);
        let names = Array.from(items.keys()).sort();
        out.line(`import assert from 'assert'`);
        out.line(`import {Block, Chain, ChainContext, BlockContext, Result, Option} from './support'`);
        let importedInterfaces = this.importInterfaces(out);
        names.forEach(qualifiedName => {
            let versions = items.get(qualifiedName);
            let [pallet, name] = qualifiedName.split('.');
            out.line();
            out.block(`export class ${pallet}${name}Constant`, () => {
                out.line(`private readonly _chain: Chain`);
                out.line();
                out.block(`constructor(ctx: ChainContext)`, () => {
                    out.line(`this._chain = ctx._chain`);
                });
                versions.forEach(v => {
                    let versionName = this.getVersionName(v.chain);
                    let hash = (0, substrate_metadata_1.getTypeHash)(v.chain.description.types, v.def.type);
                    let ifs = this.getInterface(v.chain);
                    let type = ifs.use(v.def.type);
                    let qualifiedType = this.qualify(importedInterfaces, v.chain, type);
                    out.line();
                    out.blockComment(v.def.docs);
                    out.block(`get is${versionName}()`, () => {
                        out.line(`return this._chain.getConstantTypeHash('${pallet}', '${name}') === '${hash}'`);
                    });
                    out.line();
                    out.blockComment(v.def.docs);
                    out.block(`get as${versionName}(): ${qualifiedType}`, () => {
                        out.line(`assert(this.is${versionName})`);
                        out.line(`return this._chain.getConstant('${pallet}', '${name}')`);
                    });
                });
                out.line();
                out.blockComment([
                    'Checks whether the constant is defined for the current chain version.'
                ]);
                out.block(`get isExists(): boolean`, () => {
                    out.line(`return this._chain.getConstantTypeHash('${pallet}', '${name}') != null`);
                });
            });
        });
        out.write();
    }
    generateStorage() {
        let items = this.collectItems(this.options.storage, chain => {
            let items = [];
            let storage = chain.description.storage;
            for (let prefix in storage) {
                for (let name in storage[prefix]) {
                    items.push({
                        chain,
                        name: prefix + '.' + name,
                        def: storage[prefix][name]
                    });
                }
            }
            return items;
        }, (chain, name) => {
            let [prefix, itemName] = name.split('.');
            return (0, storage_1.getStorageItemTypeHash)(chain.description.types, chain.description.storage[prefix][itemName]);
        });
        if (items.size == 0)
            return;
        let out = this.dir.file('storage.ts');
        let names = Array.from(items.keys()).sort();
        out.line(`import assert from 'assert'`);
        out.line(`import {Block, BlockContext, Chain, ChainContext, Option, Result, StorageBase} from './support'`);
        let importedInterfaces = this.importInterfaces(out);
        names.forEach(qualifiedName => {
            let versions = items.get(qualifiedName);
            let [prefix, name] = qualifiedName.split('.');
            out.line();
            out.block(`export class ${prefix}${name}Storage extends StorageBase`, () => {
                out.block(`protected getPrefix()`, () => {
                    out.line(`return '${prefix}'`);
                });
                out.line();
                out.block(`protected getName()`, () => {
                    out.line(`return '${name}'`);
                });
                versions.forEach(v => {
                    let versionName = this.getVersionName(v.chain);
                    let hash = (0, storage_1.getStorageItemTypeHash)(v.chain.description.types, v.def);
                    out.line();
                    out.blockComment(v.def.docs);
                    out.block(`get is${versionName}(): boolean`, () => {
                        out.line(`return this.getTypeHash() === '${hash}'`);
                    });
                    if (isUnitStorageItem(v)) {
                        // Meaning storage item can't hold any value
                        // Let's just silently omit `asVxx` getter for this case
                    }
                    else {
                        out.line();
                        out.blockComment(v.def.docs);
                        out.block(`get as${versionName}(): ${prefix}${name}Storage${versionName}`, () => {
                            out.line(`assert(this.is${versionName})`);
                            out.line(`return this as any`);
                        });
                    }
                });
            });
            versions.forEach(v => {
                if (isUnitStorageItem(v))
                    return; // No asVxx getter
                let versionName = this.getVersionName(v.chain);
                let ifs = this.getInterface(v.chain);
                let types = v.def.keys.concat(v.def.value).map(ti => ifs.use(ti));
                let qualifiedTypes = types.map(texp => this.qualify(importedInterfaces, v.chain, texp));
                let valueType = qualifiedTypes.pop();
                let returnType = v.def.modifier == 'Optional' ? `(${valueType} | undefined)` : valueType;
                let keyTypes = qualifiedTypes;
                let keyArgs = keyTypes.map((texp, idx) => {
                    let name = keyTypes.length > 1 ? `key${idx + 1}` : 'key';
                    return name + ': ' + texp;
                });
                let keyTuple = keyTypes.length == 1 ? keyTypes[0] : `[${keyTypes.join(', ')}]`;
                let keyValueTuple = `[k: ${keyTuple}, v: ${valueType}]`;
                function* enumeratePartialKeyArgs(leading) {
                    let list = [];
                    if (leading) {
                        list.push(leading);
                    }
                    yield list.join(', ');
                    for (let arg of keyArgs) {
                        list.push(arg);
                        yield list.join(', ');
                    }
                }
                out.line();
                out.blockComment(v.def.docs);
                out.block(`export interface ${prefix}${name}Storage${versionName}`, () => {
                    out.line(`get(${keyArgs.join(', ')}): Promise<${returnType}>`);
                    if (keyArgs.length > 0) {
                        out.line(`getAll(): Promise<${valueType}[]>`);
                        out.line(`getMany(keys: ${keyTuple}[]): Promise<${returnType}[]>`);
                        if (isStorageKeyDecodable(v.def)) {
                            for (let args of enumeratePartialKeyArgs()) {
                                out.line(`getKeys(${args}): Promise<${keyTuple}[]>`);
                            }
                            for (let args of enumeratePartialKeyArgs('pageSize: number')) {
                                out.line(`getKeysPaged(${args}): AsyncIterable<${keyTuple}[]>`);
                            }
                            for (let args of enumeratePartialKeyArgs()) {
                                out.line(`getPairs(${args}): Promise<${keyValueTuple}[]>`);
                            }
                            for (let args of enumeratePartialKeyArgs('pageSize: number')) {
                                out.line(`getPairsPaged(${args}): AsyncIterable<${keyValueTuple}[]>`);
                            }
                        }
                    }
                });
            });
        });
        out.write();
    }
    /**
     * Create a mapping between qualified name and list of unique versions
     */
    collectItems(req, extract, hash) {
        if (!req)
            return new Map();
        let requested = Array.isArray(req) ? new Set(req) : undefined;
        if (requested?.size === 0)
            return new Map();
        let list = this.chain().flatMap((chain) => extract(chain));
        let items = (0, util_1.groupBy)(list, (i) => i.name);
        requested?.forEach((name) => {
            if (!items.has(name)) {
                throw new Error(`${name} is not defined by the chain metadata`);
            }
        });
        items.forEach((versions, name) => {
            if (requested == null || requested.has(name)) {
                let unique = [];
                versions.forEach((v) => {
                    let prev = (0, util_internal_1.maybeLast)(unique);
                    if (prev && hash(v.chain, name) === hash(prev.chain, name)) {
                    }
                    else {
                        unique.push(v);
                    }
                });
                items.set(name, unique);
            }
            else {
                items.delete(name);
            }
        });
        return items;
    }
    getVersionName(v) {
        if (this.specNameNotChanged() || (0, util_internal_1.last)(this.chain()).specName == v.specName) {
            return `V${v.specVersion}`;
        }
        else {
            let isName = (0, util_naming_1.toCamelCase)(`is-${v.specName}-v${v.specVersion}`);
            return isName.slice(2);
        }
    }
    specNameNotChanged() {
        return new Set(this.chain().map((v) => v.specName)).size < 2;
    }
    chain() {
        return this.options.specVersions.map((v) => {
            let metadata = (0, substrate_metadata_1.decodeMetadata)(v.metadata);
            let oldTypes;
            if ((0, substrate_metadata_1.isPreV14)(metadata)) {
                let typesBundle = (0, util_internal_1.assertNotNull)(this.options.typesBundle || (0, substrate_metadata_1.getOldTypesBundle)(v.specName), `types bundle is required for ${v.specName} chain`);
                oldTypes = (0, typesBundle_1.getTypesFromBundle)(typesBundle, v.specVersion, v.specName);
            }
            let d = (0, substrate_metadata_1.getChainDescriptionFromMetadata)(metadata, oldTypes);
            return {
                specName: v.specName,
                specVersion: v.specVersion,
                blockNumber: v.blockNumber,
                types: d.types,
                events: new eac.Registry(d.types, d.event),
                calls: new eac.Registry(d.types, d.call),
                description: d,
            };
        });
    }
    getInterface(version) {
        let ifs = this.interfaces.get(version);
        if (ifs)
            return ifs;
        ifs = new ifs_1.Interfaces(version.description.types, (0, names_1.assignNames)(version.description));
        this.interfaces.set(version, ifs);
        return ifs;
    }
    importInterfaces(out) {
        let set = new Set();
        out.lazy(() => {
            Array.from(set)
                .sort((a, b) => a.blockNumber - b.blockNumber)
                .forEach((v) => {
                let name = (0, util_naming_1.toCamelCase)(this.getVersionName(v));
                out.line(`import * as ${name} from './${name}'`);
            });
        });
        return set;
    }
    qualify(importedInterfaces, v, texp) {
        let ifs = this.getInterface(v);
        let prefix = (0, util_naming_1.toCamelCase)(this.getVersionName(v));
        let qualified = ifs.qualify(prefix, texp);
        if (qualified != texp) {
            importedInterfaces.add(v);
        }
        return qualified;
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], Typegen.prototype, "specNameNotChanged", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Typegen.prototype, "chain", null);
exports.Typegen = Typegen;
/**
 * Returns true when storage item actually can't hold any value
 */
function isUnitStorageItem(item) {
    return (0, util_1.isEmptyVariant)(item.chain.description.types[item.def.value]);
}
function isStorageKeyDecodable(item) {
    return item.hashers.every(hasher => {
        switch (hasher) {
            case 'Blake2_128Concat':
            case 'Twox64Concat':
            case 'Identity':
                return true;
            default:
                return false;
        }
    });
}
//# sourceMappingURL=typegen.js.map