"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.needsName = exports.deriveName = exports.Names = exports.assignNames = void 0;
const types_codec_1 = require("@subsquid/scale-codec/lib/types-codec");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("./util");
/**
 * Assign names to types
 */
function assignNames(d) {
    let names = new Names(d.types);
    // assign good names for events and calls
    names.assign(d.call, 'Call');
    names.assign(d.event, 'Event');
    forEachPallet(d.types, d.call, (pallet, ti) => {
        names.assign(ti, pallet + 'Call');
    });
    forEachPallet(d.types, d.event, (pallet, ti) => {
        names.assign(ti, pallet + 'Event');
    });
    return names.getAssignment();
}
exports.assignNames = assignNames;
function forEachPallet(types, ti, cb) {
    let type = types[ti];
    (0, assert_1.default)(type.kind == substrate_metadata_1.TypeKind.Variant);
    type.variants.forEach(v => {
        (0, assert_1.default)(v.fields.length == 1);
        let vi = v.fields[0].type;
        cb(v.name, vi);
    });
}
class Names {
    constructor(types) {
        this.types = types;
        this.assignment = new Map();
        this.assigned = new Map(); // Map<Name, TypeHash>
        this.reserved = new Set(['Result', 'Option']);
        this.aliases = new Map();
    }
    assign(ti, name) {
        (0, assert_1.default)(this.isValidAssignment(ti, name));
        this.assigned.set(name, (0, substrate_metadata_1.getTypeHash)(this.types, ti));
        this.assignment.set(ti, name);
    }
    isValidAssignment(ti, name) {
        if (this.reserved.has(name))
            return false;
        let hash = this.assigned.get(name);
        return hash == null || (0, substrate_metadata_1.getTypeHash)(this.types, ti) == hash;
    }
    reserve(name) {
        (0, assert_1.default)(!this.assigned.has(name));
        this.reserved.add(name);
    }
    alias(ti, name) {
        let aliases = this.aliases.get(ti);
        if (aliases) {
            aliases.add(name);
        }
        else {
            this.aliases.set(ti, new Set([name]));
        }
    }
    getAssignment() {
        this.types.forEach((type, ti) => {
            if (this.assignment.has(ti))
                return;
            if (!needsName(this.types, ti))
                return;
            let name = deriveName(type);
            if (name && this.isValidAssignment(ti, name)) {
                this.assign(ti, name);
                return;
            }
            for (let name of this.aliases.get(ti)?.values() || []) {
                if (this.isValidAssignment(ti, name)) {
                    this.assign(ti, name);
                    return;
                }
            }
            this.assign(ti, `Type_${ti}`);
        });
        this.types.forEach((type, ti) => {
            if (this.assignment.has(ti))
                return;
            let aliases = this.aliases.get(ti);
            if (aliases?.size !== 1)
                return;
            let name = Array.from(aliases)[0];
            if (this.isValidAssignment(ti, name)) {
                this.assign(ti, name);
            }
        });
        return this.assignment;
    }
}
exports.Names = Names;
/**
 * Derive "the best" name from a path.
 */
function deriveName(type) {
    if (!type.path?.length)
        return undefined;
    let version = type.path.find(name => /^v\d+$/i.test(name));
    let name = type.path[type.path.length - 1];
    if (version && version !== name) {
        return `V${version.slice(1)}${name}`;
    }
    else {
        return name;
    }
}
exports.deriveName = deriveName;
function needsName(types, ti) {
    let type = (0, types_codec_1.getUnwrappedType)(types, ti);
    switch (type.kind) {
        case substrate_metadata_1.TypeKind.Variant:
            return !((0, util_1.asResultType)(type) || (0, util_1.asOptionType)(type));
        case substrate_metadata_1.TypeKind.Composite:
            return true;
        default:
            return false;
    }
}
exports.needsName = needsName;
//# sourceMappingURL=names.js.map