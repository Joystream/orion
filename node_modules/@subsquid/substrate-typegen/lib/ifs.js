"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interfaces = void 0;
const types_codec_1 = require("@subsquid/scale-codec/lib/types-codec");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const util_internal_1 = require("@subsquid/util-internal");
const util_naming_1 = require("@subsquid/util-naming");
const assert_1 = __importDefault(require("assert"));
const names_1 = require("./names");
const util_1 = require("./util");
class Interfaces {
    constructor(types, nameAssignment) {
        this.types = types;
        this.nameAssignment = nameAssignment;
        this.generatedNames = new Set();
        this.queue = [];
        this.assignedNames = new Set(this.nameAssignment.values());
        this.generated = new Array(this.types.length);
    }
    use(ti) {
        let name = this.generated[ti];
        if (name != null)
            return name;
        name = this.makeType(ti);
        if (!(0, names_1.needsName)(this.types, ti) && this.nameAssignment.has(ti)) {
            let alias = this.nameAssignment.get(ti);
            if (!this.generatedNames.has(alias)) {
                this.generatedNames.add(alias);
                let typeExp = name;
                this.queue.push(out => {
                    out.line();
                    out.blockComment(this.types[ti].docs);
                    out.line(`export type ${alias} = ${typeExp}`);
                });
            }
            name = alias;
        }
        return this.generated[ti] = name;
    }
    makeType(ti) {
        let codecType = (0, types_codec_1.getCodecType)(this.types, ti);
        switch (codecType.kind) {
            case substrate_metadata_1.TypeKind.Primitive:
                return (0, util_1.toNativePrimitive)(codecType.primitive);
            case substrate_metadata_1.TypeKind.Compact:
                return (0, util_1.toNativePrimitive)(codecType.integer);
            case substrate_metadata_1.TypeKind.BitSequence:
            case substrate_metadata_1.TypeKind.Bytes:
            case substrate_metadata_1.TypeKind.BytesArray:
                return 'Uint8Array';
            case substrate_metadata_1.TypeKind.Sequence:
            case substrate_metadata_1.TypeKind.Array:
                return this.use(codecType.type) + '[]';
            case substrate_metadata_1.TypeKind.Tuple:
                return this.makeTuple(codecType.tuple);
            case substrate_metadata_1.TypeKind.Struct:
                return this.makeStruct(codecType, ti);
            case substrate_metadata_1.TypeKind.Variant: {
                let type = this.types[ti];
                (0, assert_1.default)(type.kind == substrate_metadata_1.TypeKind.Variant);
                let result = (0, util_1.asResultType)(this.types[ti]);
                if (result) {
                    return `Result<${this.use(result.ok)}, ${this.use(result.err)}>`;
                }
                let option = (0, util_1.asOptionType)(this.types[ti]);
                if (option) {
                    return `Option<${this.use(option.some)}>`;
                }
                return this.makeVariant(type, ti);
            }
            case substrate_metadata_1.TypeKind.Option:
                return `(${this.use(codecType.type)} | undefined)`;
            case substrate_metadata_1.TypeKind.BooleanOption:
                return `(boolean | undefined)`;
            case substrate_metadata_1.TypeKind.DoNotConstruct:
                return 'never';
            default:
                throw (0, util_internal_1.unexpectedCase)(codecType.kind);
        }
    }
    makeTuple(fields) {
        switch (fields.length) {
            case 0:
                return 'null';
            case 1:
                return this.use(fields[0]);
            default:
                return '[' + fields.map(f => this.use(f)).join(', ') + ']';
        }
    }
    makeStruct(type, ti) {
        let name = this.getName(ti);
        if (this.generatedNames.has(name))
            return name;
        this.generatedNames.add(name);
        this.queue.push(out => {
            out.line();
            out.blockComment(this.types[ti].docs);
            out.block(`export interface ${name}`, () => {
                this.printStructFields(out, type.fields);
            });
        });
        return name;
    }
    printStructFields(out, fields) {
        fields.forEach(f => {
            let name = (0, util_naming_1.toCamelCase)((0, util_internal_1.assertNotNull)(f.name));
            let type = this.use(f.type);
            out.blockComment(f.docs);
            out.line(`${name}: ${type}`);
        });
    }
    makeVariant(type, ti) {
        let name = this.getName(ti);
        if (this.generatedNames.has(name))
            return name;
        this.generatedNames.add(name);
        this.queue.push(out => {
            out.line();
            out.blockComment(type.docs);
            if (type.variants.length == 0) {
                out.line(`export type ${name} = never`);
                return;
            }
            out.line(`export type ${name} = ${type.variants.map(v => name + '_' + v.name).join(' | ')}`);
            type.variants.forEach(v => {
                out.line();
                out.blockComment(v.docs);
                out.block(`export interface ${name + '_' + v.name}`, () => {
                    out.line(`__kind: '${v.name}'`);
                    if (v.fields.length > 0) {
                        if (v.fields[0].name != null) {
                            this.printStructFields(out, v.fields);
                        }
                        else {
                            out.line(`value: ${this.makeTuple(v.fields.map(f => f.type))}`);
                        }
                    }
                });
            });
        });
        return name;
    }
    getName(ti) {
        return (0, util_internal_1.assertNotNull)(this.nameAssignment.get(ti));
    }
    isEmpty() {
        return this.queue.length == 0;
    }
    generate(out) {
        for (let i = 0; i < this.queue.length; i++) {
            this.queue[i](out);
        }
    }
    qualify(ns, typeExp) {
        let names = typeExp
            .split(/[<>&|,()\[\]{}:]/)
            .map((t) => t.trim())
            .filter((t) => !!t);
        let local = new Set(names.filter(name => this.assignedNames.has(name)));
        local.forEach(name => {
            typeExp = typeExp.replace(new RegExp(`\\b${name}\\b`, 'g'), ns + '.' + name);
        });
        return typeExp;
    }
}
exports.Interfaces = Interfaces;
//# sourceMappingURL=ifs.js.map