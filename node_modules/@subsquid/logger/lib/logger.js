"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const util_internal_json_1 = require("@subsquid/util-internal-json");
const level_1 = require("./level");
class Logger {
    constructor(sink, ns, attributes) {
        this.sink = sink;
        this.ns = ns;
        this.attributes = attributes;
    }
    get level() {
        return level_1.LEVELS.get(this.ns);
    }
    child(nsOrAttributes, attributes) {
        let ns = this.ns;
        if (typeof nsOrAttributes == 'string') {
            ns = ns ? `${ns}:${nsOrAttributes}` : nsOrAttributes;
        }
        else {
            attributes = nsOrAttributes;
        }
        if (this.attributes) {
            if (attributes) {
                attributes = { ...this.attributes, ...attributes };
            }
            else {
                attributes = this.attributes;
            }
        }
        return new Logger(this.sink, ns, attributes);
    }
    write(level, attributes, msg) {
        if (attributes == null)
            return;
        if (level < this.level)
            return;
        if (typeof attributes == 'string') {
            msg = attributes;
            attributes = null;
        }
        if (attributes instanceof Error) {
            attributes = { err: attributes };
        }
        else if (attributes instanceof Map || attributes instanceof Set) {
            attributes = (0, util_internal_json_1.toJSON)(attributes);
        }
        let rec = {
            level,
            time: Date.now(),
            ns: this.ns,
            msg
        };
        addAttributes(this.attributes, rec);
        addAttributes(attributes, rec);
        this.sink(rec);
    }
    trace(attributes, msg) {
        this.write(level_1.LogLevel.TRACE, attributes, msg);
    }
    debug(attributes, msg) {
        this.write(level_1.LogLevel.DEBUG, attributes, msg);
    }
    info(attributes, msg) {
        this.write(level_1.LogLevel.INFO, attributes, msg);
    }
    warn(attributes, msg) {
        this.write(level_1.LogLevel.WARN, attributes, msg);
    }
    error(attributes, msg) {
        this.write(level_1.LogLevel.ERROR, attributes, msg);
    }
    fatal(attributes, msg) {
        this.write(level_1.LogLevel.FATAL, attributes, msg);
    }
    isTrace() {
        return this.level <= level_1.LogLevel.TRACE;
    }
    isDebug() {
        return this.level <= level_1.LogLevel.DEBUG;
    }
    isInfo() {
        return this.level <= level_1.LogLevel.INFO;
    }
    isWarn() {
        return this.level <= level_1.LogLevel.WARN;
    }
    isError() {
        return this.level <= level_1.LogLevel.ERROR;
    }
    isFatal() {
        return this.level <= level_1.LogLevel.FATAL;
    }
}
exports.Logger = Logger;
function addAttributes(src, target) {
    for (let key in src) {
        let val = src[key];
        switch (key) {
            case 'time':
            case 'level':
            case 'ns':
            case 'msg':
                break;
            default:
                target[key] = val;
        }
    }
}
//# sourceMappingURL=logger.js.map