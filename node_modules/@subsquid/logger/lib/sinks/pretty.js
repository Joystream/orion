"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prettyStderrSink = exports.Printer = void 0;
const util_internal_hex_1 = require("@subsquid/util-internal-hex");
const util_internal_json_1 = require("@subsquid/util-internal-json");
const assert_1 = __importDefault(require("assert"));
const supports_color_1 = require("supports-color");
const level_1 = require("../level");
class Printer {
    constructor(out, hasColor) {
        this.out = out;
        this.hasColor = hasColor;
    }
    applyColor(s) {
        if (this.hasColor && this.color && s) {
            return `\u001b[${this.color}m${s}\u001b[0m`;
        }
        else {
            return s;
        }
    }
    style(style, s) {
        if (this.hasColor && style && s) {
            s = style + s + '\u001b[0m';
            if (this.color) {
                s = `\u001b[0m` + s + `\u001b[${this.color}m`;
            }
        }
        return s;
    }
    line(s) {
        s = this.applyColor(s);
        if (this.prefix) {
            this.out(this.prefix.prepend(s));
        }
        else {
            this.out(s);
        }
    }
    text(text) {
        for (let line of text.split(/\r?\n/)) {
            this.line(line);
        }
    }
    begin(prefix, width) {
        width = width == null ? prefix.length : width;
        this.prefix = new Prefix(this.applyColor(prefix), width, this.prefix);
    }
    end() {
        (0, assert_1.default)(this.prefix != null);
        this.prefix = this.prefix.prev;
    }
    property(prefix, val) {
        switch (typeof val) {
            case "symbol":
            case "string":
                this.begin(prefix);
                this.text(val.toString());
                this.end();
                break;
            case "boolean":
            case "bigint":
            case "number":
                this.line(`${prefix} ${val}`);
                break;
            case "object":
                if (val instanceof Uint8Array) {
                    this.line(`${prefix} ${(0, util_internal_hex_1.toHex)(val)}`);
                }
                else if (val instanceof Date) {
                    this.line(`${prefix} ${val}`);
                }
                else if (typeof val?.toJSON == 'function') {
                    this.property(prefix, val.toJSON());
                }
                else if (val == null) {
                    this.line(`${prefix} null`);
                }
                else {
                    let text;
                    try {
                        text = JSON.stringify((0, util_internal_json_1.toJSON)(val));
                    }
                    catch (e) {
                        text = this.style('\u001b[31m', `failed to serialize logged value: ${e}`);
                    }
                    this.line(`${prefix} ${text}`);
                }
                break;
        }
    }
    print(rec) {
        this.begin(this.formatHead(rec), 14 + (rec.ns ? rec.ns.length + 1 : 0));
        if (rec.msg) {
            this.text(rec.msg);
        }
        this.color = '2'; // dim
        if (rec.err instanceof Error) {
            this.text(rec.err.stack || rec.err.toString());
            for (let k in rec.err) {
                this.property(`    ${k}:`, rec.err[k]);
            }
        }
        for (let key in rec) {
            switch (key) {
                case 'time':
                case 'ns':
                case 'level':
                case 'msg':
                    break;
                default:
                    if (key == 'err' && rec.err instanceof Error) {
                        // already printed under the stack trace above
                    }
                    else {
                        this.property(key + ':', rec[key]);
                    }
            }
        }
        this.end();
    }
    formatHead(rec) {
        let time = formatTime(rec.time);
        let level = level_1.LogLevel[rec.level].padEnd(5, ' ');
        let ns = rec.ns;
        if (this.hasColor) {
            level = `\u001b[1m\u001b[${getLevelColor(rec.level)}m${level}\u001b[0m`;
            ns = `\u001b[1m\u001b[34m${ns}\u001b[0m`;
        }
        let head = time + ' ' + level;
        if (rec.ns) {
            head += ' ' + ns;
        }
        return head;
    }
    reset() {
        this.prefix = undefined;
        this.color = undefined;
    }
}
exports.Printer = Printer;
function getLevelColor(level) {
    switch (level) {
        case level_1.LogLevel.TRACE:
            return 35;
        case level_1.LogLevel.DEBUG:
            return 32;
        case level_1.LogLevel.INFO:
            return 36;
        case level_1.LogLevel.WARN:
            return 33;
        case level_1.LogLevel.ERROR:
        case level_1.LogLevel.FATAL:
            return 31;
        default:
            return 0;
    }
}
function formatTime(time) {
    let date = new Date(time);
    let hour = date.getHours().toString().padStart(2, '0');
    let minutes = date.getMinutes().toString().padStart(2, '0');
    let seconds = date.getSeconds().toString().padStart(2, '0');
    return `${hour}:${minutes}:${seconds}`;
}
class Prefix {
    constructor(value, width, prev) {
        this.value = value;
        this.prev = prev;
        this.indent = '';
        this.offset = (this.prev?.offset || 0) + width + 1;
    }
    prepend(s) {
        if (this.value) {
            let val = this.value;
            if (this.prev) {
                val = this.prev.prepend(val);
            }
            this.value = '';
            return s ? val + ' ' + s : val;
        }
        else if (s) {
            this.indent = this.indent || ''.padEnd(this.offset, ' ');
            return this.indent + s;
        }
        else {
            return s;
        }
    }
}
const PRINTER = new Printer(line => {
    process.stderr.write(line + '\n');
}, !!supports_color_1.stderr);
function prettyStderrSink(rec) {
    try {
        PRINTER.print(rec);
    }
    catch (e) {
        PRINTER.reset();
        PRINTER.print({
            ns: 'sys',
            level: level_1.LogLevel.ERROR,
            time: Date.now(),
            msg: e.stack || e.toString()
        });
    }
    finally {
        PRINTER.reset();
    }
}
exports.prettyStderrSink = prettyStderrSink;
//# sourceMappingURL=pretty.js.map