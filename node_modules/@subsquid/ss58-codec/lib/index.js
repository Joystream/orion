"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = exports.decode = void 0;
const assert_1 = __importDefault(require("assert"));
const base_x_1 = __importDefault(require("base-x"));
const blake2b_1 = __importDefault(require("blake2b"));
const base58 = (0, base_x_1.default)('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const HASH_PREFIX = Buffer.from('SS58PRE');
const HASH_BUF = Buffer.alloc(64);
/**
 * Decode SS58 address string.
 *
 * This function follows [Ss58Codec trait](https://github.com/paritytech/substrate/blob/ded44948e2d5a398abcb4e342b0513cb690961bb/primitives/core/src/crypto.rs#L245)
 */
function decode(s) {
    let buf = base58.decodeUnsafe(s);
    if (buf == null || buf.length < 3)
        throw invalidAddress(s);
    let b0 = buf[0];
    let offset;
    let prefix;
    if (b0 < 64) {
        prefix = b0;
        offset = 1;
    }
    else if (b0 < 128) {
        let b1 = buf[1];
        let lower = ((b0 << 2) | (b1 >> 6)) & 0b11111111;
        let upper = b1 & 0b00111111;
        prefix = lower | (upper << 8);
        offset = 2;
    }
    else {
        throw invalidAddress(s);
    }
    let hashLen;
    switch (buf.length - offset) {
        case 34:
        case 35:
            hashLen = 2;
            break;
        case 9:
        case 5:
        case 3:
        case 2:
            hashLen = 1;
            break;
        default:
            throw invalidAddress(s);
    }
    computeHash(buf, hashLen);
    for (let i = 0; i < hashLen; i++) {
        if (HASH_BUF[i] != buf[buf.length - hashLen + i]) {
            throw invalidAddress(s);
        }
    }
    return {
        prefix,
        bytes: buf.subarray(offset, buf.length - hashLen)
    };
}
exports.decode = decode;
/**
 * Encode SS58 address into canonical string format
 */
function encode(address) {
    let prefix = address.prefix;
    (0, assert_1.default)(Number.isInteger(prefix) && prefix >= 0 && prefix < 16384, 'invalid prefix');
    let len = address.bytes.length;
    let hashLen;
    switch (len) {
        case 1:
        case 2:
        case 4:
        case 8:
            hashLen = 1;
            break;
        case 32:
        case 33:
            hashLen = 2;
            break;
        default:
            (0, assert_1.default)(false, 'invalid address length');
    }
    let buf;
    let offset;
    if (prefix < 64) {
        buf = Buffer.allocUnsafe(1 + hashLen + len);
        buf[0] = prefix;
        offset = 1;
    }
    else {
        buf = Buffer.allocUnsafe(2 + hashLen + len);
        buf[0] = ((prefix & 252) >> 2) | 0b01000000;
        buf[1] = (prefix >> 8) | ((prefix & 0b11) << 6);
        offset = 2;
    }
    buf.set(address.bytes, offset);
    computeHash(buf, hashLen);
    for (let i = 0; i < hashLen; i++) {
        buf[offset + len + i] = HASH_BUF[i];
    }
    return base58.encode(buf);
}
exports.encode = encode;
function computeHash(buf, len) {
    let hash = (0, blake2b_1.default)(64);
    hash.update(HASH_PREFIX);
    hash.update(buf.subarray(0, buf.length - len));
    hash.digest(HASH_BUF);
}
function invalidAddress(s) {
    return new Error('Invalid ss58 address: ' + s);
}
//# sourceMappingURL=index.js.map