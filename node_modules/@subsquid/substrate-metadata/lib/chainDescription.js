"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChainDescriptionFromMetadata = void 0;
const types_codec_1 = require("@subsquid/scale-codec/lib/types-codec");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const typeRegistry_1 = require("./old/typeRegistry");
const types_1 = require("./types");
const util_1 = require("./util");
function getChainDescriptionFromMetadata(metadata, oldTypes) {
    switch (metadata.__kind) {
        case "V9":
        case "V10":
        case "V11":
        case "V12":
        case "V13":
            (0, assert_1.default)(oldTypes, `Type definitions are required for metadata ${metadata.__kind}`);
            return new FromOld(metadata, oldTypes).convert();
        case "V14":
            return new FromV14(metadata.value).convert();
        default:
            throw new Error(`Unsupported metadata version: ${metadata.__kind}`);
    }
}
exports.getChainDescriptionFromMetadata = getChainDescriptionFromMetadata;
class FromV14 {
    constructor(metadata) {
        this.metadata = metadata;
    }
    convert() {
        return {
            types: this.types(),
            call: this.call(),
            digest: this.digest(),
            digestItem: this.digestItem(),
            event: this.event(),
            eventRecord: this.eventRecord(),
            eventRecordList: this.eventRecordList(),
            signature: this.signature(),
            storage: this.storage(),
            constants: this.constants()
        };
    }
    digest() {
        return this.getStorageItem('System', 'Digest').value;
    }
    digestItem() {
        let digest = this.types()[this.digest()];
        (0, assert_1.default)(digest.kind == types_1.TypeKind.Composite);
        for (let field of digest.fields) {
            if (field.name == 'logs') {
                let seq = this.types()[field.type];
                (0, assert_1.default)(seq.kind == types_1.TypeKind.Sequence);
                return seq.type;
            }
        }
        (0, assert_1.default)(false, `Can't extract DigestItem from Digest`);
    }
    event() {
        let rec = this.types()[this.eventRecord()];
        (0, assert_1.default)(rec.kind == types_1.TypeKind.Composite);
        let eventField = rec.fields.find(f => f.name == 'event');
        (0, assert_1.default)(eventField != null);
        return eventField.type;
    }
    eventRecord() {
        let types = this.types();
        let eventRecordList = this.eventRecordList();
        let seq = types[eventRecordList];
        (0, assert_1.default)(seq.kind == types_1.TypeKind.Sequence);
        return seq.type;
    }
    eventRecordList() {
        return this.getStorageItem('System', 'Events').value;
    }
    signature() {
        let types = this.types();
        let signedExtensionsType = {
            kind: types_1.TypeKind.Composite,
            fields: this.metadata.extrinsic.signedExtensions.map(ext => {
                return {
                    name: ext.identifier,
                    type: ext.type
                };
            }).filter(f => {
                return !(0, util_1.isUnitType)((0, types_codec_1.getUnwrappedType)(types, f.type));
            }),
            path: ['SignedExtensions']
        };
        let signedExtensions = types.push(signedExtensionsType) - 1;
        let signatureType = {
            kind: types_1.TypeKind.Composite,
            fields: [
                {
                    name: "address",
                    type: this.address(),
                },
                {
                    name: "signature",
                    type: this.extrinsicSignature(),
                },
                {
                    name: 'signedExtensions',
                    type: signedExtensions
                }
            ],
            path: ['ExtrinsicSignature']
        };
        return types.push(signatureType) - 1;
    }
    address() {
        return this.getTypeParameter(this.uncheckedExtrinsic(), 0);
    }
    call() {
        return this.getTypeParameter(this.uncheckedExtrinsic(), 1);
    }
    extrinsicSignature() {
        return this.getTypeParameter(this.uncheckedExtrinsic(), 2);
    }
    uncheckedExtrinsic() {
        let candidates = [];
        for (let i = 0; i < this.metadata.lookup.types.length; i++) {
            let def = this.metadata.lookup.types[i].type;
            if (def.path[0] == 'sp_runtime' && (0, util_internal_1.last)(def.path) == 'UncheckedExtrinsic') {
                candidates.push(i);
            }
        }
        switch (candidates.length) {
            case 0: throw new Error(`Failed to find UncheckedExtrinsic type in metadata`);
            case 1: return candidates[0];
            default:
                return candidates.includes(this.metadata.extrinsic.type)
                    ? this.metadata.extrinsic.type
                    : candidates[0];
        }
    }
    getTypeParameter(ti, idx) {
        let def = this.metadata.lookup.types[ti];
        if (def.type.params.length <= idx) {
            let name = def.type.path.length ? def.type.path.join('::') : '' + ti;
            throw new Error(`Type ${name} should have at least ${idx + 1} type parameter${idx > 0 ? 's' : ''}`);
        }
        return (0, util_internal_1.assertNotNull)(def.type.params[idx].type);
    }
    getStorageItem(prefix, name) {
        let storage = this.storage();
        let item = storage[prefix]?.[name];
        return (0, util_internal_1.assertNotNull)(item, `Can't find ${prefix}.${name} storage item`);
    }
    storage() {
        let storage = {};
        this.metadata.pallets.forEach(pallet => {
            if (pallet.storage == null)
                return;
            let items = storage[pallet.storage.prefix] = {};
            pallet.storage.items.forEach(e => {
                let hashers;
                let keys;
                switch (e.type.__kind) {
                    case 'Plain':
                        hashers = [];
                        keys = [];
                        break;
                    case 'Map':
                        hashers = e.type.hashers.map(h => h.__kind);
                        if (hashers.length == 1) {
                            keys = [e.type.key];
                        }
                        else {
                            let keyDef = this.types()[e.type.key];
                            (0, assert_1.default)(keyDef.kind == types_1.TypeKind.Tuple);
                            (0, assert_1.default)(keyDef.tuple.length == hashers.length);
                            keys = keyDef.tuple;
                        }
                        break;
                    default:
                        throw (0, util_internal_1.unexpectedCase)();
                }
                items[e.name] = {
                    modifier: e.modifier.__kind,
                    hashers,
                    keys,
                    value: e.type.value,
                    fallback: e.fallback,
                    docs: e.docs
                };
            });
        });
        return storage;
    }
    constants() {
        let constants = {};
        this.metadata.pallets.forEach(pallet => {
            pallet.constants.forEach(c => {
                let pc = constants[pallet.name] || (constants[pallet.name] = {});
                pc[c.name] = {
                    type: c.type,
                    value: c.value,
                    docs: c.docs
                };
            });
        });
        return constants;
    }
    types() {
        let types = this.metadata.lookup.types.map(t => {
            let info = {
                path: t.type.path,
                docs: t.type.docs
            };
            let def = t.type.def;
            switch (def.__kind) {
                case 'Primitive':
                    return {
                        kind: types_1.TypeKind.Primitive,
                        primitive: def.value.__kind,
                        ...info
                    };
                case "Compact":
                    return {
                        kind: types_1.TypeKind.Compact,
                        type: def.value.type,
                        ...info
                    };
                case "Sequence":
                    return {
                        kind: types_1.TypeKind.Sequence,
                        type: def.value.type,
                        ...info
                    };
                case "BitSequence":
                    return {
                        kind: types_1.TypeKind.BitSequence,
                        bitStoreType: def.value.bitStoreType,
                        bitOrderType: def.value.bitOrderType,
                        ...info
                    };
                case "Array":
                    return {
                        kind: types_1.TypeKind.Array,
                        type: def.value.type,
                        len: def.value.len,
                        ...info
                    };
                case "Tuple":
                    return {
                        kind: types_1.TypeKind.Tuple,
                        tuple: def.value,
                        ...info
                    };
                case "Composite":
                    return {
                        kind: types_1.TypeKind.Composite,
                        fields: def.value.fields,
                        ...info
                    };
                case "Variant":
                    return {
                        kind: types_1.TypeKind.Variant,
                        variants: def.value.variants,
                        ...info
                    };
                default:
                    throw (0, util_internal_1.unexpectedCase)(def.__kind);
            }
        });
        return (0, util_1.normalizeMetadataTypes)(types);
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "digest", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "digestItem", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "event", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "eventRecord", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "eventRecordList", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "signature", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "address", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "call", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "extrinsicSignature", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromV14.prototype, "uncheckedExtrinsic", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], FromV14.prototype, "storage", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], FromV14.prototype, "constants", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], FromV14.prototype, "types", null);
class FromOld {
    constructor(metadata, oldTypes) {
        this.metadata = metadata;
        this.oldTypes = oldTypes;
        this.registry = new typeRegistry_1.OldTypeRegistry(oldTypes);
        this.defineGenericExtrinsicEra();
        this.defineGenericLookupSource();
        this.defineOriginCaller();
        this.defineGenericCall();
        this.defineGenericEvent();
        this.defineGenericSignature();
    }
    convert() {
        let signature = this.registry.use('GenericSignature');
        let call = this.registry.use('GenericCall');
        let digest = this.registry.use('Digest');
        let digestItem = this.registry.use('DigestItem');
        let event = this.registry.use('GenericEvent');
        let eventRecord = this.registry.use('EventRecord');
        let eventRecordList = this.registry.use('Vec<EventRecord>');
        let storage = this.storage();
        let constants = this.constants();
        return {
            types: this.registry.getTypes(),
            call,
            digest,
            digestItem,
            event,
            eventRecord,
            eventRecordList,
            signature,
            storage,
            constants
        };
    }
    defineGenericSignature() {
        this.registry.define("GenericSignature", () => {
            return {
                kind: types_1.TypeKind.Composite,
                fields: [
                    {
                        name: "address",
                        type: this.registry.use("Address")
                    },
                    {
                        name: "signature",
                        type: this.registry.use("ExtrinsicSignature")
                    },
                    {
                        name: 'signedExtensions',
                        type: this.signedExtensions()
                    }
                ]
            };
        });
    }
    signedExtensions() {
        let fields = [];
        switch (this.metadata.__kind) {
            case "V9":
            case "V10":
                this.addSignedExtensionField(fields, 'CheckEra');
                this.addSignedExtensionField(fields, 'CheckNonce');
                this.addSignedExtensionField(fields, 'ChargeTransactionPayment');
                break;
            case "V11":
            case "V12":
            case "V13":
                this.metadata.value.extrinsic.signedExtensions.forEach(name => {
                    this.addSignedExtensionField(fields, name);
                });
                break;
            default:
                throw (0, util_internal_1.unexpectedCase)(this.metadata.__kind);
        }
        return this.registry.add({
            kind: types_1.TypeKind.Composite,
            fields
        });
    }
    addSignedExtensionField(fields, name) {
        let type = this.getSignedExtensionType(name);
        if (type == null)
            return;
        fields.push({ name, type });
    }
    getSignedExtensionType(name) {
        let def = this.oldTypes.signedExtensions?.[name];
        if (def)
            return this.registry.use(def);
        switch (name) {
            case 'ChargeTransactionPayment':
                return this.registry.use('Compact<Balance>');
            case 'CheckMortality':
            case 'CheckEra':
                return this.registry.use('ExtrinsicEra');
            case 'CheckNonce':
                return this.registry.use('Compact<Index>');
            case 'CheckBlockGasLimit':
            case 'CheckGenesis':
            case 'CheckNonZeroSender':
            case 'CheckSpecVersion':
            case 'CheckTxVersion':
            case 'CheckVersion':
            case 'CheckWeight':
            case 'LockStakingStatus':
            case 'ValidateEquivocationReport':
                return undefined;
            default:
                throw new Error('Unknown signed extension: ' + name);
        }
    }
    defineGenericExtrinsicEra() {
        this.registry.define('GenericExtrinsicEra', () => {
            let variants = [];
            variants.push({
                name: 'Immortal',
                fields: [],
                index: 0
            });
            for (let index = 1; index < 256; index++) {
                variants.push({
                    name: 'Mortal' + index,
                    fields: [
                        { type: this.registry.use('U8') }
                    ],
                    index
                });
            }
            return {
                kind: types_1.TypeKind.Variant,
                variants
            };
        });
    }
    defineGenericCall() {
        this.registry.define('GenericCall', () => {
            let variants = [];
            this.forEachPallet(mod => mod.calls, (mod, index) => {
                variants.push({
                    name: mod.name,
                    index,
                    fields: [{
                            type: this.makeCallEnum(mod.name, mod.calls)
                        }]
                });
            });
            return {
                kind: types_1.TypeKind.Variant,
                variants: variants
            };
        });
    }
    defineGenericEvent() {
        this.registry.define('GenericEvent', () => {
            let variants = [];
            this.forEachPallet(mod => mod.events?.length, (mod, index) => {
                variants.push({
                    name: mod.name,
                    index,
                    fields: [{
                            type: this.makeEventEnum(mod.name, mod.events)
                        }]
                });
            });
            return {
                kind: types_1.TypeKind.Variant,
                variants
            };
        });
    }
    makeEventEnum(palletName, events) {
        let variants = events.map((e, index) => {
            let fields = e.args.map(arg => {
                return {
                    type: this.registry.use(arg, palletName)
                };
            });
            return {
                index,
                name: e.name,
                fields,
                docs: e.docs
            };
        });
        return this.registry.add({
            kind: types_1.TypeKind.Variant,
            variants
        });
    }
    makeCallEnum(palletName, calls) {
        let variants = calls.map((call, index) => {
            let fields = call.args.map(arg => {
                return {
                    name: arg.name,
                    type: this.registry.use(arg.type, palletName)
                };
            });
            return {
                index,
                name: call.name,
                fields,
                docs: call.docs
            };
        });
        return this.registry.add({
            kind: types_1.TypeKind.Variant,
            variants
        });
    }
    defineGenericLookupSource() {
        this.registry.define('GenericLookupSource', () => {
            let variants = [];
            for (let i = 0; i < 0xef; i++) {
                variants.push({
                    name: 'Idx' + i,
                    fields: [],
                    index: i
                });
            }
            variants.push({
                name: 'IdxU16',
                fields: [{ type: this.registry.use('U16') }],
                index: 0xfc
            });
            variants.push({
                name: 'IdxU32',
                fields: [{ type: this.registry.use('U32') }],
                index: 0xfd
            });
            variants.push({
                name: 'IdxU64',
                fields: [{ type: this.registry.use('U64') }],
                index: 0xfe
            });
            variants.push({
                name: 'AccountId',
                fields: [{ type: this.registry.use('AccountId') }],
                index: 0xff
            });
            return {
                kind: types_1.TypeKind.Variant,
                variants
            };
        });
    }
    storage() {
        let storage = {};
        this.forEachPallet(null, mod => {
            if (mod.storage == null)
                return;
            let items = storage[mod.storage.prefix] || {};
            mod.storage.items.forEach(e => {
                let hashers;
                let keys;
                switch (e.type.__kind) {
                    case 'Plain':
                        hashers = [];
                        keys = [];
                        break;
                    case 'Map':
                        hashers = [e.type.hasher.__kind];
                        keys = [this.registry.use(e.type.key, mod.name)];
                        break;
                    case 'DoubleMap':
                        hashers = [
                            e.type.hasher.__kind,
                            e.type.key2Hasher.__kind
                        ];
                        keys = [
                            this.registry.use(e.type.key1, mod.name),
                            this.registry.use(e.type.key2, mod.name)
                        ];
                        break;
                    case 'NMap':
                        hashers = e.type.hashers.map(h => h.__kind);
                        keys = e.type.keyVec.map(k => this.registry.use(k, mod.name));
                        break;
                    default:
                        throw (0, util_internal_1.unexpectedCase)();
                }
                items[e.name] = {
                    modifier: e.modifier.__kind,
                    hashers,
                    keys,
                    value: this.registry.use(e.type.value, mod.name),
                    fallback: e.fallback,
                    docs: e.docs
                };
            });
            storage[mod.storage.prefix] = items;
        });
        return storage;
    }
    constants() {
        let constants = {};
        this.forEachPallet(null, mod => {
            mod.constants.forEach(c => {
                let pc = constants[mod.name] || (constants[mod.name] = {});
                pc[c.name] = {
                    type: this.registry.use(c.type, mod.name),
                    value: c.value,
                    docs: c.docs
                };
            });
        });
        return constants;
    }
    defineOriginCaller() {
        this.registry.define('OriginCaller', () => {
            let variants = [];
            this.forEachPallet(null, (mod, index) => {
                let name = mod.name;
                let type;
                switch (mod.name) {
                    case 'Authority':
                        type = 'AuthorityOrigin';
                        break;
                    case 'Council':
                    case 'TechnicalCommittee':
                    case 'GeneralCouncil':
                        type = 'CollectiveOrigin';
                        break;
                    case 'System':
                        type = 'SystemOrigin';
                        name = 'system';
                        break;
                    case 'Xcm':
                    case 'XcmPallet':
                        type = 'XcmOrigin';
                        break;
                    default:
                        return;
                }
                variants.push({
                    name: mod.name,
                    index,
                    fields: [{
                            type: this.registry.use(type)
                        }]
                });
            });
            return {
                kind: types_1.TypeKind.Variant,
                variants,
                path: ['OriginCaller']
            };
        });
    }
    forEachPallet(filter, cb) {
        switch (this.metadata.__kind) {
            case 'V9':
            case 'V10':
            case 'V11': {
                let index = 0;
                this.metadata.value.modules.forEach(mod => {
                    if (filter && !filter(mod))
                        return;
                    cb(mod, index);
                    index += 1;
                });
                return;
            }
            case 'V12':
            case 'V13': {
                this.metadata.value.modules.forEach(mod => {
                    if (filter && !filter(mod))
                        return;
                    cb(mod, mod.index);
                });
                return;
            }
        }
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], FromOld.prototype, "signedExtensions", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], FromOld.prototype, "storage", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], FromOld.prototype, "constants", null);
//# sourceMappingURL=chainDescription.js.map