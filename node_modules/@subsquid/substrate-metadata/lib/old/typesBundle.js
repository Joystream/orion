"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypesFromBundle = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const metadata_1 = require("./definitions/metadata");
const substrate_1 = require("./definitions/substrate");
function getTypesFromBundle(bundleOrSpecs, specVersion, specName) {
    let bundle;
    if (bundleOrSpecs.types == null) {
        let bundles = bundleOrSpecs;
        bundle = (0, util_internal_1.assertNotNull)(bundles[(0, util_internal_1.assertNotNull)(specName)], `Missing typesBundle for spec ${specName}@${specVersion}`);
    }
    else {
        bundle = bundleOrSpecs;
    }
    let types = {
        types: {
            ...metadata_1.types,
            ...substrate_1.substrateBundle.types,
            ...bundle.types
        },
        typesAlias: {
            ...substrate_1.substrateBundle.typesAlias,
            ...bundle.typesAlias
        },
        signedExtensions: {
            ...substrate_1.substrateBundle.signedExtensions,
            ...bundle.signedExtensions
        }
    };
    if (!bundle.versions?.length)
        return types;
    for (let i = 0; i < bundle.versions.length; i++) {
        let override = bundle.versions[i];
        if (isWithinRange(override.minmax, specVersion)) {
            Object.assign(types.types, override.types);
            Object.assign(types.typesAlias, override.typesAlias);
            Object.assign(types.signedExtensions, override.signedExtensions);
        }
    }
    return types;
}
exports.getTypesFromBundle = getTypesFromBundle;
function isWithinRange(range, version) {
    let beg = range[0] ?? 0;
    let end = range[1] ?? Infinity;
    return beg <= version && version <= end;
}
//# sourceMappingURL=typesBundle.js.map