"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.print = void 0;
function print(type) {
    switch (type.kind) {
        case 'array':
            return `[${print(type.item)}; ${type.len}]`;
        case 'tuple':
            return `(${type.params.map(t => print(t)).join(', ')})`;
        case 'named': {
            if (type.params.length == 0) {
                return type.name;
            }
            else {
                return `${type.name}<${type.params.map(t => typeof t == 'number' ? '' + t : print(t)).join(', ')}>`;
            }
        }
    }
}
exports.print = print;
function parse(typeExp) {
    return new TypeExpParser(typeExp).parse();
}
exports.parse = parse;
class TypeExpParser {
    constructor(typeExp) {
        this.typeExp = typeExp;
        this.idx = 0;
        this.tokens = tokenize(typeExp);
    }
    eof() {
        return this.idx >= this.tokens.length;
    }
    tok(tok) {
        if (this.eof())
            return null;
        let current = this.tokens[this.idx];
        let match = tok instanceof RegExp
            ? !!current && tok.test(current)
            : current === tok;
        if (match) {
            this.idx += 1;
            return current;
        }
        else {
            return null;
        }
    }
    assertTok(tok) {
        return this.assert(this.tok(tok));
    }
    nat() {
        let tok = this.tok(/^\d+$/);
        return tok == null ? null : Number.parseInt(tok);
    }
    assertNat() {
        return this.assert(this.nat());
    }
    name() {
        return this.tok(/^[a-zA-Z]\w*$/);
    }
    assertName() {
        return this.assert(this.name());
    }
    list(sep, p) {
        let item = p();
        if (item == null)
            return [];
        let result = [item];
        while (this.tok(sep)) {
            item = p();
            if (item == null) {
                break;
            }
            else {
                result.push(item);
            }
        }
        return result;
    }
    tuple() {
        if (!this.tok('('))
            return null;
        let params = this.list(',', () => this.anyType());
        this.assertTok(')');
        return {
            kind: 'tuple',
            params
        };
    }
    array() {
        if (!this.tok('['))
            return null;
        let item = this.assert(this.anyType());
        this.assertTok(';');
        let len = this.assertNat();
        if (this.tok(';')) {
            this.assertName();
        }
        this.assertTok(']');
        return {
            kind: 'array',
            item,
            len
        };
    }
    namedType() {
        let name;
        let trait;
        let item;
        if (this.tok('<')) {
            name = this.assertNamedType().name;
            this.assertTok('as');
            trait = this.assertNamedType().name;
            this.assertTok('>');
        }
        else {
            let nameTok = this.name();
            if (nameTok == null)
                return null;
            name = nameTok;
        }
        while (this.tok('::') && (item = this.name())) { }
        if (name == 'InherentOfflineReport' && name == trait && item == 'Inherent') {
        }
        else if (name == 'exec' && item == 'StorageKey') {
            name = 'ContractStorageKey';
        }
        else if (name == 'Lookup' && item == 'Source') {
            name = 'LookupSource';
        }
        else if (name == 'Lookup' && item == 'Target') {
            name = 'LookupTarget';
        }
        else if (item) {
            this.assert(trait != 'HasCompact');
            name = item;
        }
        else if (trait == 'HasCompact') {
            return {
                kind: 'named',
                name: 'Compact',
                params: [{
                        kind: 'named',
                        name,
                        params: this.typeParameters()
                    }]
            };
        }
        return {
            kind: 'named',
            name,
            params: this.typeParameters()
        };
    }
    assertNamedType() {
        return this.assert(this.namedType());
    }
    typeParameters() {
        let params;
        if (this.tok('<')) {
            params = this.list(',', () => this.nat() || this.anyType());
            this.assertTok('>');
        }
        else {
            params = [];
        }
        return params;
    }
    pointerBytes() {
        if (!this.tok('&'))
            return null;
        this.tok("'") && this.assertTok('static');
        this.assertTok('[');
        this.assertTok('u8');
        this.assertTok(']');
        return {
            kind: 'named',
            name: 'Vec',
            params: [{
                    kind: 'named',
                    name: 'u8',
                    params: []
                }]
        };
    }
    anyType() {
        return this.tuple() || this.array() || this.namedType() || this.pointerBytes();
    }
    parse() {
        let type = this.assert(this.anyType());
        if (!this.eof()) {
            throw this.abort();
        }
        return type;
    }
    abort() {
        return new Error(`Invalid type expression: ${this.typeExp}`);
    }
    assert(val) {
        if (val == null || val === false) {
            throw this.abort();
        }
        else {
            return val;
        }
    }
}
function tokenize(typeExp) {
    let tokens = [];
    let word = '';
    for (let i = 0; i < typeExp.length; i++) {
        let c = typeExp[i];
        if (/\w/.test(c)) {
            word += c;
        }
        else {
            if (word) {
                tokens.push(word);
                word = '';
            }
            c = c.trim();
            if (c == ':' && typeExp[i + 1] == ':') {
                i += 1;
                tokens.push('::');
            }
            else if (c) {
                tokens.push(c);
            }
        }
    }
    if (word) {
        tokens.push(word);
    }
    return tokens;
}
//# sourceMappingURL=typeExp.js.map