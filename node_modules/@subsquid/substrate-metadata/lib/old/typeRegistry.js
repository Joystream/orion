"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OldTypeRegistry = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_naming_1 = require("@subsquid/util-naming");
const assert_1 = __importDefault(require("assert"));
const types_1 = require("../types");
const util_1 = require("../util");
const texp = __importStar(require("./typeExp"));
class OldTypeRegistry {
    constructor(oldTypes) {
        this.oldTypes = oldTypes;
        this.types = [];
        this.lookup = new Map();
        this.definitions = {};
    }
    getTypes() {
        this.replaceAliases();
        return (0, util_1.normalizeMetadataTypes)(this.types);
    }
    replaceAliases() {
        let types = this.types;
        let seen = new Set();
        function replace(ti) {
            let a = types[ti];
            if (a.kind != -1)
                return a;
            if (seen.has(ti)) {
                throw new Error(`Cycle of non-constructable types involving ${a.name}`);
            }
            else {
                seen.add(ti);
            }
            let type = { ...replace(a.alias) };
            type.path = [a.name];
            return types[ti] = type;
        }
        for (let ti = 0; ti < types.length; ti++) {
            replace(ti);
        }
    }
    define(typeName, fn) {
        this.definitions[typeName] = fn;
    }
    use(typeExp, pallet) {
        let type;
        if (typeof typeExp == 'string') {
            type = texp.parse(typeExp);
            type = this.normalizeType(type, pallet);
        }
        else {
            type = typeExp;
        }
        let key = texp.print(type);
        let ti = this.lookup.get(key);
        if (ti == null) {
            ti = this.types.push({ kind: types_1.TypeKind.DoNotConstruct }) - 1;
            this.lookup.set(key, ti);
            this.types[ti] = this.buildScaleType(type);
        }
        return ti;
    }
    normalizeType(type, pallet) {
        switch (type.kind) {
            case "array":
                return {
                    kind: "array",
                    item: this.normalizeType(type.item, pallet),
                    len: type.len
                };
            case "tuple":
                return {
                    kind: "tuple",
                    params: type.params.map(item => this.normalizeType(item, pallet))
                };
            case "named":
                return this.normalizeNamedType(type, pallet);
        }
    }
    normalizeNamedType(type, pallet) {
        if (pallet != null && this.oldTypes.typesAlias) {
            let sectionAliases = this.oldTypes.typesAlias[pallet] || this.oldTypes.typesAlias[(0, util_naming_1.toCamelCase)(pallet)];
            let alias = sectionAliases?.[type.name];
            if (alias) {
                return { kind: 'named', name: alias, params: [] };
            }
        }
        if (this.oldTypes.types[type.name])
            return {
                kind: 'named',
                name: type.name,
                params: []
            };
        let primitive = asPrimitive(type.name);
        if (primitive) {
            assertNoParams(type);
            return {
                kind: 'named',
                name: primitive,
                params: []
            };
        }
        switch (type.name) {
            case 'Null':
                return {
                    kind: 'tuple',
                    params: []
                };
            case 'UInt':
                return {
                    kind: 'named',
                    name: convertGenericIntegerToPrimitive('U', type),
                    params: []
                };
            case 'Int':
                return {
                    kind: 'named',
                    name: convertGenericIntegerToPrimitive('I', type),
                    params: []
                };
            case 'Box':
                return this.normalizeType(assertOneParam(type), pallet);
            case 'Bytes':
                assertNoParams(type);
                return {
                    kind: 'named',
                    name: 'Vec',
                    params: [{ kind: 'named', name: 'U8', params: [] }]
                };
            case 'Vec':
            case 'VecDeque':
            case 'WeakVec':
            case 'BoundedVec':
            case 'WeakBoundedVec': {
                let param = this.normalizeType(assertOneParam(type), pallet);
                return {
                    kind: 'named',
                    name: 'Vec',
                    params: [param]
                };
            }
            case 'BTreeMap':
            case 'BoundedBTreeMap': {
                let [key, val] = assertTwoParams(type);
                return this.normalizeType({
                    kind: 'named',
                    name: 'Vec',
                    params: [
                        {
                            kind: 'tuple',
                            params: [key, val]
                        }
                    ]
                }, pallet);
            }
            case 'BTreeSet':
            case 'BoundedBTreeSet':
                return this.normalizeType({
                    kind: 'named',
                    name: 'Vec',
                    params: [assertOneParam(type)]
                }, pallet);
            case 'RawAddress':
                return this.normalizeType({
                    kind: 'named',
                    name: 'Address',
                    params: []
                }, pallet);
            case 'PairOf':
            case 'Range':
            case 'RangeInclusive': {
                let param = this.normalizeType(assertOneParam(type), pallet);
                return {
                    kind: 'tuple',
                    params: [param, param]
                };
            }
            default:
                return {
                    kind: 'named',
                    name: type.name,
                    params: type.params.map(p => typeof p == 'number' ? p : this.normalizeType(p, pallet))
                };
        }
    }
    buildScaleType(type) {
        switch (type.kind) {
            case 'named':
                return this.buildNamedType(type);
            case 'array':
                return this.buildArray(type);
            case 'tuple':
                return this.buildTuple(type);
            default:
                throw (0, util_internal_1.unexpectedCase)(type.kind);
        }
    }
    buildNamedType(type) {
        if (this.definitions[type.name])
            return this.definitions[type.name]();
        let def = this.oldTypes.types[type.name];
        if (def)
            return this.buildFromDefinition(type.name, def);
        let primitive = asPrimitive(type.name);
        if (primitive) {
            assertNoParams(type);
            return {
                kind: types_1.TypeKind.Primitive,
                primitive
            };
        }
        switch (type.name) {
            case 'DoNotConstruct':
                return {
                    kind: types_1.TypeKind.DoNotConstruct
                };
            case 'Vec': {
                let param = this.use(assertOneParam(type));
                return {
                    kind: types_1.TypeKind.Sequence,
                    type: param
                };
            }
            case 'BitVec':
                return {
                    kind: types_1.TypeKind.BitSequence,
                    bitStoreType: this.use('U8'),
                    bitOrderType: -1
                };
            case 'Option': {
                let param = this.use(assertOneParam(type));
                return {
                    kind: types_1.TypeKind.Option,
                    type: param
                };
            }
            case 'Result': {
                let [ok, error] = assertTwoParams(type);
                return {
                    kind: types_1.TypeKind.Variant,
                    variants: [
                        {
                            index: 0,
                            name: 'Ok',
                            fields: [
                                { type: this.use(ok) }
                            ]
                        },
                        {
                            index: 1,
                            name: 'Err',
                            fields: [
                                { type: this.use(error) }
                            ]
                        }
                    ]
                };
            }
            case 'Compact':
                return {
                    kind: types_1.TypeKind.Compact,
                    type: this.use(assertOneParam(type))
                };
        }
        throw new Error(`Type ${type.name} is not defined`);
    }
    buildFromDefinition(typeName, def) {
        let result;
        if (typeof def == 'string') {
            return { kind: -1, alias: this.use(def), name: typeName };
        }
        else if (def._enum) {
            result = this.buildEnum(def);
        }
        else if (def._set) {
            return this.types[this.buildSet(def)];
        }
        else {
            result = this.buildStruct(def);
        }
        result.path = [typeName];
        return result;
    }
    buildSet(def) {
        let len = def._set._bitLength || 8;
        switch (len) {
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
                return this.use('U' + len);
            default:
                (0, assert_1.default)(len % 8 == 0, 'bit length must me aligned');
                return this.use(`[u8; ${len / 8}]`);
        }
    }
    buildEnum(def) {
        let variants = [];
        if (Array.isArray(def._enum)) {
            variants = def._enum.map((name, index) => {
                return {
                    name,
                    index,
                    fields: []
                };
            });
        }
        else if (isIndexedEnum(def)) {
            variants = Object.entries(def._enum).map(([name, index]) => {
                return {
                    name,
                    index,
                    fields: []
                };
            });
        }
        else {
            let index = 0;
            for (let name in def._enum) {
                let type = def._enum[name];
                let fields = [];
                if (typeof type == 'string') {
                    fields.push({
                        type: this.use(type)
                    });
                }
                else if (type != null) {
                    (0, assert_1.default)(typeof type == 'object');
                    for (let key in type) {
                        fields.push({
                            name: key,
                            type: this.use(type[key])
                        });
                    }
                }
                variants.push({
                    name,
                    index,
                    fields
                });
                index += 1;
            }
        }
        return {
            kind: types_1.TypeKind.Variant,
            variants
        };
    }
    buildStruct(def) {
        let fields = [];
        for (let name in def) {
            fields.push({
                name,
                type: this.use(def[name])
            });
        }
        return {
            kind: types_1.TypeKind.Composite,
            fields
        };
    }
    buildArray(type) {
        return {
            kind: types_1.TypeKind.Array,
            type: this.use(type.item),
            len: type.len
        };
    }
    buildTuple(type) {
        return {
            kind: types_1.TypeKind.Tuple,
            tuple: type.params.map(p => this.use(p))
        };
    }
    add(type) {
        return this.types.push(type) - 1;
    }
    get(ti) {
        return (0, util_internal_1.assertNotNull)(this.types[ti]);
    }
}
exports.OldTypeRegistry = OldTypeRegistry;
function isIndexedEnum(def) {
    if (Array.isArray(def._enum))
        return false;
    for (let key in def._enum) {
        if (typeof def._enum[key] != 'number')
            return false;
    }
    return true;
}
function assertOneParam(type) {
    if (type.params.length == 0) {
        throw new Error(`Invalid type ${texp.print(type)}: one type parameter expected`);
    }
    let param = type.params[0];
    if (typeof param == 'number') {
        throw new Error(`Invalid type ${texp.print(type)}: type parameter should refer to a type, not to bit size`);
    }
    return param;
}
function assertTwoParams(type) {
    if (type.params.length < 2) {
        throw new Error(`Invalid type ${texp.print(type)}: two type parameters expected`);
    }
    let param1 = type.params[0];
    if (typeof param1 == 'number') {
        throw new Error(`Invalid type ${texp.print(type)}: first type parameter should refer to a type, not to bit size`);
    }
    let param2 = type.params[1];
    if (typeof param2 == 'number') {
        throw new Error(`Invalid type ${texp.print(type)}: second type parameter should refer to a type, not to bit size`);
    }
    return [param1, param2];
}
function assertNoParams(type) {
    if (type.params.length != 0) {
        throw new Error(`Invalid type ${texp.print(type)}: no type parameters expected for ${type.name}`);
    }
}
function convertGenericIntegerToPrimitive(kind, type) {
    if (type.params.length == 0) {
        throw new Error(`Invalid type ${texp.print(type)}: bit size is not specified`);
    }
    let size = type.params[0];
    if (typeof size != 'number') {
        throw new Error(`Invalid type ${texp.print(type)}: bit size expected as a first type parameter, e.g. ${type.name}<32>`);
    }
    switch (size) {
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
            return `${kind}${size}`;
        default:
            throw new Error(`Invalid type ${texp.print(type)}: invalid bit size ${size}`);
    }
}
function asPrimitive(name) {
    switch (name.toLowerCase()) {
        case 'i8':
            return 'I8';
        case 'u8':
            return 'U8';
        case 'i16':
            return 'I16';
        case 'u16':
            return 'U16';
        case 'i32':
            return 'I32';
        case 'u32':
            return 'U32';
        case 'i64':
            return 'I64';
        case 'u64':
            return 'U64';
        case 'i128':
            return 'I128';
        case 'u128':
            return 'U128';
        case 'i256':
            return 'I256';
        case 'u256':
            return 'U256';
        case 'bool':
            return 'Bool';
        case 'str':
        case 'text':
            return 'Str';
        default:
            return undefined;
    }
}
//# sourceMappingURL=typeRegistry.js.map