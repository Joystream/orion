"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Registry = void 0;
const assert_1 = __importDefault(require("assert"));
const types_1 = require("./types");
const types_hashing_1 = require("./types-hashing");
const util_1 = require("./util");
class Registry {
    constructor(types, ti) {
        this.types = types;
        this.definitions = {};
        this.hashes = {};
        let pallets = types[ti];
        (0, assert_1.default)(pallets.kind == types_1.TypeKind.Variant);
        pallets.variants.forEach(pallet => {
            (0, assert_1.default)(pallet.fields.length == 1);
            let palletType = types[pallet.fields[0].type];
            (0, assert_1.default)(palletType.kind == types_1.TypeKind.Variant);
            palletType.variants.forEach(def => {
                this.definitions[`${pallet.name}.${def.name}`] = {
                    ...def,
                    pallet: pallet.name
                };
            });
        });
    }
    get(name) {
        let def = this.definitions[name];
        if (def == null)
            throw new Error(`${name} not found`);
        return def;
    }
    getHash(name) {
        let hash = this.hashes[name];
        if (hash == null) {
            return this.hashes[name] = this.computeHash(name);
        }
        else {
            return hash;
        }
    }
    computeHash(name) {
        let def = this.get(name);
        let fields = def.fields.map(f => {
            return {
                name: f.name,
                type: (0, types_hashing_1.getTypeHash)(this.types, f.type)
            };
        });
        return (0, util_1.sha256)({
            fields
        });
    }
}
exports.Registry = Registry;
//# sourceMappingURL=events-and-calls.js.map