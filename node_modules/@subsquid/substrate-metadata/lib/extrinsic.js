"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeExtrinsic = exports.decodeExtrinsic = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const assert_1 = __importDefault(require("assert"));
function decodeExtrinsic(rawExtrinsic, chainDescription, codec) {
    codec = codec || new scale_codec_1.Codec(chainDescription.types);
    let src = new scale_codec_1.Src(rawExtrinsic);
    src.compact();
    let meta = src.u8();
    let signed = meta & 0b10000000;
    let version = meta & 0b01111111;
    (0, assert_1.default)(version == 4, 'unsupported extrinsic version');
    if (signed) {
        let signature = codec.decode(chainDescription.signature, src);
        let call = codec.decode(chainDescription.call, src);
        return {
            version: 4,
            signature,
            call
        };
    }
    else {
        return {
            version: 4,
            call: codec.decode(chainDescription.call, src)
        };
    }
}
exports.decodeExtrinsic = decodeExtrinsic;
function encodeExtrinsic(extrinsic, chainDescription, codec) {
    (0, assert_1.default)(extrinsic.version == 4, 'unsupported extrinsic version');
    codec = codec || new scale_codec_1.Codec(chainDescription.types);
    let sink = new scale_codec_1.ByteSink();
    let meta = 4;
    if (extrinsic.signature) {
        meta |= 0b10000000;
    }
    sink.u8(meta);
    if (extrinsic.signature) {
        codec.encode(chainDescription.signature, extrinsic.signature, sink);
    }
    codec.encode(chainDescription.call, extrinsic.call, sink);
    let bytes = sink.toBytes();
    sink = new scale_codec_1.ByteSink();
    sink.compact(bytes.length);
    sink.bytes(bytes);
    return sink.toBytes();
}
exports.encodeExtrinsic = encodeExtrinsic;
function encodeToSink(sink, extrinsic, chainDescription, codec) {
    (0, assert_1.default)(extrinsic.version == 4, 'unsupported extrinsic version');
    codec = codec || new scale_codec_1.Codec(chainDescription.types);
    let meta = 4;
    if (extrinsic.signature) {
        meta |= 0b10000000;
    }
    sink.u8(meta);
    if (extrinsic.signature) {
        codec.encode(chainDescription.signature, extrinsic.signature, sink);
    }
    codec.encode(chainDescription.call, extrinsic.call, sink);
}
//# sourceMappingURL=extrinsic.js.map