"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoolOpenreaderContext = exports.PgDatabase = void 0;
const subscription_1 = require("./subscription");
const error_handling_1 = require("./util/error-handling");
const lazy_transaction_1 = require("./util/lazy-transaction");
class PgDatabase {
    constructor(client) {
        this.client = client;
    }
    query(sql, parameters) {
        return this.client.query({ text: sql, rowMode: 'array' }, parameters)
            .then(result => result.rows)
            .catch((0, error_handling_1.withErrorContext)({ sql, parameters }));
    }
}
exports.PgDatabase = PgDatabase;
class PoolOpenreaderContext {
    constructor(dialect, pool, subscriptionPool, subscriptionPollInterval = 1000) {
        this.dialect = dialect;
        this.subscriptionPollInterval = subscriptionPollInterval;
        this.tx = new lazy_transaction_1.LazyTransaction(cb => transact(pool, cb));
        this.subscriptionPool = subscriptionPool || pool;
    }
    close() {
        return this.tx.close();
    }
    async executeQuery(query) {
        let db = await this.tx.get();
        let result = await db.query(query.sql, query.params);
        return query.map(result);
    }
    subscription(query) {
        return new subscription_1.Subscription(this.subscriptionPollInterval, () => transact(this.subscriptionPool, async (db) => {
            let result = await db.query(query.sql, query.params);
            return query.map(result);
        }));
    }
}
exports.PoolOpenreaderContext = PoolOpenreaderContext;
async function transact(pool, cb) {
    let client = await pool.connect();
    try {
        await client.query('START TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY');
        try {
            let db = new PgDatabase(client);
            return await cb(db);
        }
        finally {
            await client.query('COMMIT').catch(() => { });
        }
    }
    finally {
        client.release();
    }
}
//# sourceMappingURL=db.js.map