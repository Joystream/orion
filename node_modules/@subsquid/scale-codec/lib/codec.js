"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Codec = void 0;
const assert_1 = __importDefault(require("assert"));
const sink_1 = require("./sink");
const src_1 = require("./src");
const types_1 = require("./types");
const types_codec_1 = require("./types-codec");
const util_1 = require("./util");
class Codec {
    constructor(types) {
        this.types = (0, types_codec_1.toCodecTypes)(types);
    }
    decodeBinary(type, data) {
        let src = new src_1.Src(data);
        let val = this.decode(type, src);
        src.assertEOF();
        return val;
    }
    encodeToHex(type, val) {
        let sink = new sink_1.HexSink();
        this.encode(type, val, sink);
        return sink.toHex();
    }
    encodeToBinary(type, val) {
        let sink = new sink_1.ByteSink();
        this.encode(type, val, sink);
        return sink.toBytes();
    }
    decode(type, src) {
        let def = this.types[type];
        switch (def.kind) {
            case types_1.TypeKind.Primitive:
                return decodePrimitive(def.primitive, src);
            case types_1.TypeKind.Compact:
                return decodeCompact(def, src);
            case types_1.TypeKind.BitSequence:
                return decodeBitSequence(src);
            case types_1.TypeKind.Array:
                return this.decodeArray(def, src);
            case types_1.TypeKind.Sequence:
                return this.decodeSequence(def, src);
            case types_1.TypeKind.Tuple:
                return this.decodeTuple(def, src);
            case types_1.TypeKind.Struct:
                return this.decodeStruct(def, src);
            case types_1.TypeKind.Variant:
                return this.decodeVariant(def, src);
            case types_1.TypeKind.Option:
                return this.decodeOption(def, src);
            case types_1.TypeKind.BooleanOption:
                return decodeBooleanOption(src);
            case types_1.TypeKind.Bytes:
                return decodeBytes(src);
            case types_1.TypeKind.BytesArray:
                return src.bytes(def.len);
            case types_1.TypeKind.DoNotConstruct:
                (0, util_1.throwUnexpectedCase)('DoNotConstruct type reached');
            default:
                (0, util_1.throwUnexpectedCase)(def.kind);
        }
    }
    decodeArray(def, src) {
        let { len, type } = def;
        let result = new Array(len);
        for (let i = 0; i < len; i++) {
            result[i] = this.decode(type, src);
        }
        return result;
    }
    decodeSequence(def, src) {
        let len = src.compactLength();
        let result = new Array(len);
        for (let i = 0; i < len; i++) {
            result[i] = this.decode(def.type, src);
        }
        return result;
    }
    decodeTuple(def, src) {
        if (def.tuple.length == 0)
            return null;
        let result = new Array(def.tuple.length);
        for (let i = 0; i < def.tuple.length; i++) {
            result[i] = this.decode(def.tuple[i], src);
        }
        return result;
    }
    decodeStruct(def, src) {
        let result = {};
        for (let i = 0; i < def.fields.length; i++) {
            let f = def.fields[i];
            result[f.name] = this.decode(f.type, src);
        }
        return result;
    }
    decodeVariant(def, src) {
        let idx = src.u8();
        let variant = def.variants[idx];
        if (variant == null)
            (0, util_1.throwUnexpectedCase)(`unknown variant index: ${idx}`);
        switch (variant.kind) {
            case 'empty':
                return {
                    __kind: variant.name
                };
            case 'tuple':
                return {
                    __kind: variant.name,
                    value: this.decodeTuple(variant.def, src)
                };
            case 'value':
                return {
                    __kind: variant.name,
                    value: this.decode(variant.type, src)
                };
            case 'struct': {
                let value = this.decodeStruct(variant.def, src);
                value.__kind = variant.name;
                return value;
            }
            default:
                (0, util_1.throwUnexpectedCase)();
        }
    }
    decodeOption(def, src) {
        let byte = src.u8();
        switch (byte) {
            case 0:
                return undefined;
            case 1:
                return this.decode(def.type, src);
            default:
                (0, util_1.throwUnexpectedCase)(byte.toString());
        }
    }
    encode(type, val, sink) {
        let def = this.types[type];
        switch (def.kind) {
            case types_1.TypeKind.Primitive:
                encodePrimitive(def.primitive, val, sink);
                break;
            case types_1.TypeKind.Compact:
                sink.compact(val);
                break;
            case types_1.TypeKind.BitSequence:
                encodeBitSequence(val, sink);
                break;
            case types_1.TypeKind.Array:
                this.encodeArray(def, val, sink);
                break;
            case types_1.TypeKind.Sequence:
                this.encodeSequence(def, val, sink);
                break;
            case types_1.TypeKind.Tuple:
                this.encodeTuple(def, val, sink);
                break;
            case types_1.TypeKind.Struct:
                this.encodeStruct(def, val, sink);
                break;
            case types_1.TypeKind.Variant:
                this.encodeVariant(def, val, sink);
                break;
            case types_1.TypeKind.BytesArray:
                encodeBytesArray(def, val, sink);
                break;
            case types_1.TypeKind.Bytes:
                encodeBytes(val, sink);
                break;
            case types_1.TypeKind.BooleanOption:
                encodeBooleanOption(val, sink);
                break;
            case types_1.TypeKind.Option:
                this.encodeOption(def, val, sink);
                break;
            default:
                (0, util_1.throwUnexpectedCase)(def.kind);
        }
    }
    encodeArray(def, val, sink) {
        (0, assert_1.default)(Array.isArray(val) && val.length == def.len);
        for (let i = 0; i < val.length; i++) {
            this.encode(def.type, val[i], sink);
        }
    }
    encodeSequence(def, val, sink) {
        (0, assert_1.default)(Array.isArray(val));
        sink.compact(val.length);
        for (let i = 0; i < val.length; i++) {
            this.encode(def.type, val[i], sink);
        }
    }
    encodeTuple(def, val, sink) {
        if (def.tuple.length == 0) {
            (0, assert_1.default)(val == null);
            return;
        }
        (0, assert_1.default)(Array.isArray(val) && def.tuple.length == val.length);
        for (let i = 0; i < val.length; i++) {
            this.encode(def.tuple[i], val[i], sink);
        }
    }
    encodeStruct(def, val, sink) {
        for (let i = 0; i < def.fields.length; i++) {
            let f = def.fields[i];
            this.encode(f.type, val[f.name], sink);
        }
    }
    encodeVariant(def, val, sink) {
        (0, assert_1.default)(typeof val?.__kind == 'string', 'not a variant type value');
        let variant = def.variantsByName[val.__kind];
        if (variant == null)
            throw new Error(`Unknown variant: ${val.__kind}`);
        sink.u8(variant.index);
        switch (variant.kind) {
            case 'empty':
                break;
            case 'value':
                this.encode(variant.type, val.value, sink);
                break;
            case 'tuple':
                this.encodeTuple(variant.def, val.value, sink);
                break;
            case 'struct':
                this.encodeStruct(variant.def, val, sink);
                break;
            default:
                (0, util_1.throwUnexpectedCase)();
        }
    }
    encodeOption(def, val, sink) {
        if (val === undefined) {
            sink.u8(0);
        }
        else {
            sink.u8(1);
            this.encode(def.type, val, sink);
        }
    }
}
exports.Codec = Codec;
function decodeBytes(src) {
    let len = src.compactLength();
    return src.bytes(len);
}
function encodeBytes(val, sink) {
    (0, assert_1.default)(val instanceof Uint8Array);
    sink.compact(val.length);
    sink.bytes(val);
}
function encodeBytesArray(def, val, sink) {
    (0, assert_1.default)(val instanceof Uint8Array && val.length == def.len);
    sink.bytes(val);
}
function decodeBitSequence(src) {
    let len = Math.ceil(src.compactLength() / 8);
    return src.bytes(len);
}
function encodeBitSequence(bits, sink) {
    (0, assert_1.default)(bits instanceof Uint8Array);
    sink.compact(bits.length * 8);
    sink.bytes(bits);
}
function decodeBooleanOption(src) {
    let byte = src.u8();
    switch (byte) {
        case 0:
            return null;
        case 1:
            return true;
        case 2:
            return false;
        default:
            (0, util_1.throwUnexpectedCase)(byte.toString());
    }
}
function encodeBooleanOption(val, sink) {
    if (val == null) {
        sink.u8(0);
    }
    else {
        (0, assert_1.default)(typeof val == 'boolean');
        sink.u8(val ? 1 : 2);
    }
}
function decodeCompact(type, src) {
    let n = src.compact();
    switch (type.integer) {
        case "U8":
        case "U16":
        case "U32":
            return n;
        default:
            return BigInt(n);
    }
}
function decodePrimitive(type, src) {
    switch (type) {
        case 'I8':
            return src.i8();
        case 'U8':
            return src.u8();
        case 'I16':
            return src.i16();
        case 'U16':
            return src.u16();
        case 'I32':
            return src.i32();
        case 'U32':
            return src.u32();
        case 'I64':
            return src.i64();
        case 'U64':
            return src.u64();
        case 'I128':
            return src.i128();
        case 'U128':
            return src.u128();
        case 'I256':
            return src.i256();
        case 'U256':
            return src.u256();
        case 'Bool':
            return src.bool();
        case 'Str':
            return src.str();
        default:
            (0, util_1.throwUnexpectedCase)(type);
    }
}
function encodePrimitive(type, val, sink) {
    switch (type) {
        case 'I8':
            sink.i8(val);
            break;
        case 'U8':
            sink.u8(val);
            break;
        case 'I16':
            sink.i16(val);
            break;
        case 'U16':
            sink.u16(val);
            break;
        case 'I32':
            sink.i32(val);
            break;
        case 'U32':
            sink.u32(val);
            break;
        case 'I64':
            sink.i64(val);
            break;
        case 'U64':
            sink.u64(val);
            break;
        case 'I128':
            sink.i128(val);
            break;
        case 'U128':
            sink.u128(val);
            break;
        case 'I256':
            sink.i256(val);
            break;
        case 'U256':
            sink.u256(val);
            break;
        case 'Bool':
            sink.bool(val);
            break;
        case 'Str':
            sink.str(val);
            break;
        default:
            (0, util_1.throwUnexpectedCase)(type);
    }
}
//# sourceMappingURL=codec.js.map