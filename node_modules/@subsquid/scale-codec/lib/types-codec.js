"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toCodecTypes = exports.getCodecType = exports.getUnwrappedType = void 0;
const assert_1 = __importDefault(require("assert"));
const types_1 = require("./types");
const util_1 = require("./util");
function getUnwrappedType(types, ti) {
    let def = types[ti];
    switch (def.kind) {
        case types_1.TypeKind.Tuple:
        case types_1.TypeKind.Composite:
            return unwrap(def, types);
        default:
            return def;
    }
}
exports.getUnwrappedType = getUnwrappedType;
function unwrap(def, types, visited) {
    let next;
    switch (def.kind) {
        case types_1.TypeKind.Tuple:
            if (def.tuple.length == 1) {
                next = def.tuple[0];
                break;
            }
            else {
                return def;
            }
        case types_1.TypeKind.Composite:
            if (def.fields[0]?.name == null) {
                let tuple = def.fields.map(t => {
                    (0, assert_1.default)(t.name == null);
                    return t.type;
                });
                if (tuple.length == 1) {
                    next = tuple[0];
                    break;
                }
                else {
                    return {
                        kind: types_1.TypeKind.Tuple,
                        tuple
                    };
                }
            }
            else {
                return def;
            }
        default:
            return def;
    }
    if (visited?.has(next)) {
        throw new Error(`Cycle of tuples involving ${next}`);
    }
    visited = visited || new Set();
    visited.add(next);
    return unwrap(types[next], types, visited);
}
function getCodecType(types, ti) {
    let def = getUnwrappedType(types, ti);
    switch (def.kind) {
        case types_1.TypeKind.Sequence:
            if (isPrimitive('U8', types, def.type)) {
                return { kind: types_1.TypeKind.Bytes };
            }
            else {
                return def;
            }
        case types_1.TypeKind.Array:
            if (isPrimitive('U8', types, def.type)) {
                return { kind: types_1.TypeKind.BytesArray, len: def.len };
            }
            else {
                return def;
            }
        // https://github.com/substrate-developer-hub/substrate-docs/issues/1061
        // case TypeKind.Option:
        //     if (isPrimitive('Bool', types, def.type)) {
        //         return {kind: TypeKind.BooleanOption}
        //     } else {
        //         return def
        //     }
        case types_1.TypeKind.Compact: {
            let type = getUnwrappedType(types, def.type);
            switch (type.kind) {
                case types_1.TypeKind.Tuple:
                    (0, assert_1.default)(type.tuple.length == 0);
                    return type;
                case types_1.TypeKind.Primitive:
                    (0, assert_1.default)(type.primitive[0] == 'U');
                    return { kind: types_1.TypeKind.Compact, integer: type.primitive };
                case types_1.TypeKind.Composite: {
                    (0, assert_1.default)(type.fields.length == 1);
                    let num = getUnwrappedType(types, type.fields[0].type);
                    // FIXME: as far as I understand, CompactAs chain can be arbitrary long
                    (0, assert_1.default)(num.kind == types_1.TypeKind.Primitive);
                    (0, assert_1.default)(num.primitive[0] == 'U');
                    return { kind: types_1.TypeKind.Compact, integer: num.primitive };
                }
                default:
                    (0, util_1.throwUnexpectedCase)(type.kind);
            }
        }
        case types_1.TypeKind.Composite:
            return {
                kind: types_1.TypeKind.Struct,
                fields: def.fields.map(f => {
                    let name = (0, util_1.assertNotNull)(f.name);
                    return { name, type: f.type };
                })
            };
        case types_1.TypeKind.Variant: {
            let variants = def.variants.filter(v => v != null);
            let variantsByName = {};
            let uniqueIndexes = new Set(variants.map(v => v.index));
            if (uniqueIndexes.size != variants.length) {
                throw new Error(`Variant type ${ti} has duplicate case indexes`);
            }
            let len = variants.reduce((len, v) => Math.max(len, v.index), 0) + 1;
            let placedVariants = new Array(len);
            variants.forEach(v => {
                let cv;
                if (v.fields[0]?.name == null) {
                    switch (v.fields.length) {
                        case 0:
                            cv = { kind: 'empty', name: v.name, index: v.index };
                            break;
                        case 1:
                            cv = { kind: 'value', name: v.name, index: v.index, type: v.fields[0].type };
                            break;
                        default:
                            cv = {
                                kind: 'tuple',
                                name: v.name,
                                index: v.index,
                                def: {
                                    kind: types_1.TypeKind.Tuple,
                                    tuple: v.fields.map(f => {
                                        (0, assert_1.default)(f.name == null);
                                        return f.type;
                                    })
                                }
                            };
                    }
                }
                else {
                    cv = {
                        kind: 'struct',
                        name: v.name,
                        index: v.index,
                        def: {
                            kind: types_1.TypeKind.Struct,
                            fields: v.fields.map(f => {
                                let name = (0, util_1.assertNotNull)(f.name);
                                return { name, type: f.type };
                            })
                        }
                    };
                }
                placedVariants[v.index] = cv;
                variantsByName[cv.name] = cv;
            });
            return {
                kind: types_1.TypeKind.Variant,
                variants: placedVariants,
                variantsByName
            };
        }
        default:
            return def;
    }
}
exports.getCodecType = getCodecType;
function isPrimitive(primitive, types, ti) {
    let type = getUnwrappedType(types, ti);
    return type.kind == types_1.TypeKind.Primitive && type.primitive == primitive;
}
function toCodecTypes(types) {
    let codecTypes = new Array(types.length);
    for (let i = 0; i < types.length; i++) {
        codecTypes[i] = getCodecType(types, i);
    }
    return codecTypes;
}
exports.toCodecTypes = toCodecTypes;
//# sourceMappingURL=types-codec.js.map