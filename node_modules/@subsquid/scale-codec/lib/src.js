"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Src = void 0;
const util_internal_hex_1 = require("@subsquid/util-internal-hex");
const assert_1 = __importDefault(require("assert"));
const util_1 = require("./util");
class Src {
    constructor(buf) {
        this.idx = 0;
        if (typeof buf == 'string') {
            this.buf = (0, util_internal_hex_1.decodeHex)(buf);
        }
        else {
            this.buf = buf;
        }
    }
    byte() {
        let b = this.buf[this.idx];
        if (b === undefined) {
            throw eof();
        }
        this.idx += 1;
        return b;
    }
    i8() {
        let b = this.byte();
        return b | (b & 2 ** 7) * 0x1fffffe;
    }
    u8() {
        return this.byte();
    }
    i16() {
        let val = this.u16();
        return val | (val & 2 ** 15) * 0x1fffe;
    }
    u16() {
        let first = this.byte();
        let last = this.byte();
        return first + last * 2 ** 8;
    }
    i32() {
        return this.byte() + this.byte() * 2 ** 8 + this.byte() * 2 ** 16 + (this.byte() << 24);
    }
    u32() {
        return this.byte() + this.byte() * 2 ** 8 + this.byte() * 2 ** 16 + this.byte() * 2 ** 24;
    }
    i64() {
        let lo = this.u32();
        let hi = this.i32();
        return BigInt(lo) + (BigInt(hi) << 32n);
    }
    u64() {
        let lo = this.u32();
        let hi = this.u32();
        return BigInt(lo) + (BigInt(hi) << 32n);
    }
    i128() {
        let lo = this.u64();
        let hi = this.i64();
        return lo + (hi << 64n);
    }
    u128() {
        let lo = this.u64();
        let hi = this.u64();
        return lo + (hi << 64n);
    }
    i256() {
        let lo = this.u128();
        let hi = this.i128();
        return lo + (hi << 128n);
    }
    u256() {
        let lo = this.u128();
        let hi = this.u128();
        return lo + (hi << 128n);
    }
    compact() {
        let b = this.byte();
        let mode = b & 3;
        switch (mode) {
            case 0:
                return b >> 2;
            case 1:
                return (b >> 2) + this.byte() * 2 ** 6;
            case 2:
                return (b >> 2) + this.byte() * 2 ** 6 + this.byte() * 2 ** 14 + this.byte() * 2 ** 22;
            case 3:
                return this.bigCompact(b >> 2);
            default:
                throw new Error('Reached unreachable statement');
        }
    }
    bigCompact(len) {
        let i = this.u32();
        switch (len) {
            case 0:
                return i;
            case 1:
                return i + this.byte() * 2 ** 32;
            case 2:
                return i + this.byte() * 2 ** 32 + this.byte() * 2 ** 40;
        }
        let n = BigInt(i);
        let base = 32n;
        while (len--) {
            n += BigInt(this.byte()) << base;
            base += 8n;
        }
        return n;
    }
    compactLength() {
        let len = this.compact();
        (0, assert_1.default)(typeof len == 'number');
        return len;
    }
    str() {
        let len = this.compactLength();
        let buf = this.bytes(len);
        return util_1.UTF8_DECODER.decode(buf);
    }
    bytes(len) {
        let beg = this.idx;
        let end = this.idx += len;
        if (this.buf.length < end) {
            throw eof();
        }
        return this.buf.subarray(beg, end);
    }
    skip(len) {
        this.idx += len;
    }
    bool() {
        return !!this.byte();
    }
    hasBytes() {
        return this.buf.length > this.idx;
    }
    assertEOF() {
        if (this.hasBytes()) {
            throw new Error('Unprocessed data left');
        }
    }
}
exports.Src = Src;
function eof() {
    return new Error('Unexpected EOF');
}
//# sourceMappingURL=src.js.map