"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBinaryArray = exports.JsonCodec = void 0;
const util_internal_hex_1 = require("@subsquid/util-internal-hex");
const util_internal_json_1 = require("@subsquid/util-internal-json");
const assert_1 = __importDefault(require("assert"));
const types_1 = require("./types");
const types_codec_1 = require("./types-codec");
const util_1 = require("./util");
class JsonCodec {
    constructor(types) {
        this.types = (0, types_codec_1.toCodecTypes)(types);
    }
    static encode(val) {
        return (0, util_internal_json_1.toJSON)(val);
    }
    decode(type, val) {
        let def = this.types[type];
        switch (def.kind) {
            case types_1.TypeKind.Primitive:
                return decodePrimitive(def.primitive, val);
            case types_1.TypeKind.Compact:
                return decodePrimitive(def.integer, val);
            case types_1.TypeKind.BitSequence:
                return (0, util_internal_hex_1.decodeHex)(val);
            case types_1.TypeKind.Array:
                return this.decodeArray(def, val);
            case types_1.TypeKind.Sequence:
                return this.decodeSequence(def, val);
            case types_1.TypeKind.Tuple:
                return this.decodeTuple(def, val);
            case types_1.TypeKind.Struct:
                return this.decodeStruct(def, val);
            case types_1.TypeKind.Variant:
                return this.decodeVariant(def, val);
            case types_1.TypeKind.Option:
                return this.decodeOption(def, val);
            case types_1.TypeKind.BooleanOption:
                return decodeBooleanOption(val);
            case types_1.TypeKind.Bytes:
                return (0, util_internal_hex_1.decodeHex)(val);
            case types_1.TypeKind.BytesArray:
                return decodeBinaryArray(def.len, val);
            case types_1.TypeKind.DoNotConstruct:
                (0, util_1.throwUnexpectedCase)('DoNotConstruct type reached');
            default:
                (0, util_1.throwUnexpectedCase)();
        }
    }
    decodeArray(def, val) {
        let { len, type } = def;
        (0, assert_1.default)(Array.isArray(val));
        (0, assert_1.default)(val.length == len);
        let result = new Array(len);
        for (let i = 0; i < len; i++) {
            result[i] = this.decode(type, val[i]);
        }
        return result;
    }
    decodeSequence(def, val) {
        (0, assert_1.default)(Array.isArray(val));
        let result = new Array(val.length);
        for (let i = 0; i < val.length; i++) {
            result[i] = this.decode(def.type, val[i]);
        }
        return result;
    }
    decodeTuple(def, value) {
        let items = def.tuple;
        if (items.length == 0) {
            (0, assert_1.default)(value == null || Array.isArray(value) && value.length == 0);
            return null;
        }
        else {
            (0, assert_1.default)(Array.isArray(value));
            (0, assert_1.default)(value.length == items.length);
            let result = new Array(items.length);
            for (let i = 0; i < items.length; i++) {
                result[i] = this.decode(items[i], value[i]);
            }
            return result;
        }
    }
    decodeStruct(def, value) {
        (0, assert_1.default)((0, util_1.isObject)(value));
        let result = {};
        for (let i = 0; i < def.fields.length; i++) {
            let f = def.fields[i];
            result[f.name] = this.decode(f.type, value[f.name]);
        }
        return result;
    }
    decodeVariant(def, val) {
        (0, assert_1.default)((0, util_1.isObject)(val));
        (0, assert_1.default)(typeof val.__kind == 'string');
        let variant = def.variantsByName[val.__kind];
        if (variant == null)
            throw new Error(`Unknown variant ${val.__kind}`);
        switch (variant.kind) {
            case "empty":
                return {
                    __kind: val.__kind
                };
            case "value":
                return {
                    __kind: val.__kind,
                    value: this.decode(variant.type, val.value)
                };
            case "tuple":
                return {
                    __kind: val.__kind,
                    value: this.decodeTuple(variant.def, val.value)
                };
            case "struct": {
                let s = this.decodeStruct(variant.def, val);
                s.__kind = val.__kind;
                return s;
            }
            default:
                (0, util_1.throwUnexpectedCase)(variant.kind);
        }
    }
    decodeOption(def, value) {
        return value == null ? undefined : this.decode(def.type, value);
    }
}
exports.JsonCodec = JsonCodec;
function decodePrimitive(type, value) {
    switch (type) {
        case "I8":
            (0, util_1.checkSignedInt)(value, 8);
            return value;
        case "I16":
            (0, util_1.checkSignedInt)(value, 16);
            return value;
        case "I32":
            (0, util_1.checkSignedInt)(value, 32);
            return value;
        case "I64":
            return (0, util_1.toSignedBigInt)(value, 64);
        case "I128":
            return (0, util_1.toSignedBigInt)(value, 128);
        case "I256":
            return (0, util_1.toSignedBigInt)(value, 256);
        case "U8":
            (0, util_1.checkUnsignedInt)(value, 8);
            return value;
        case "U16":
            (0, util_1.checkUnsignedInt)(value, 16);
            return value;
        case "U32":
            (0, util_1.checkUnsignedInt)(value, 32);
            return value;
        case "U64":
            return (0, util_1.toUnsignedBigInt)(value, 64);
        case "U128":
            return (0, util_1.toUnsignedBigInt)(value, 128);
        case "U256":
            return (0, util_1.toUnsignedBigInt)(value, 256);
        case "Bool":
            (0, assert_1.default)(typeof value == "boolean");
            return value;
        case "Str":
            (0, assert_1.default)(typeof value == "string");
            return value;
        default:
            (0, util_1.throwUnexpectedCase)(type);
    }
}
function decodeBooleanOption(value) {
    if (value == null)
        return undefined;
    (0, assert_1.default)(typeof value == 'boolean');
    return value;
}
function decodeBinaryArray(len, value) {
    let buf = (0, util_internal_hex_1.decodeHex)(value);
    (0, assert_1.default)(buf.length == len);
    return buf;
}
exports.decodeBinaryArray = decodeBinaryArray;
//# sourceMappingURL=codec-json.js.map