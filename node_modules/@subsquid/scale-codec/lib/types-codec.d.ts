import { ArrayType, BitSequenceType, DoNotConstructType, OptionType, Primitive, PrimitiveType, SequenceType, Ti, TupleType, Type, TypeKind } from './types';
export interface CodecStructType {
    kind: TypeKind.Struct;
    fields: {
        name: string;
        type: Ti;
    }[];
}
export interface CodecStructVariant {
    kind: 'struct';
    name: string;
    index: number;
    def: CodecStructType;
}
export interface CodecTupleVariant {
    kind: 'tuple';
    name: string;
    index: number;
    def: TupleType;
}
export interface CodecValueVariant {
    kind: 'value';
    name: string;
    index: number;
    type: Ti;
}
export interface CodecEmptyVariant {
    kind: 'empty';
    name: string;
    index: number;
}
export declare type CodecVariant = CodecStructVariant | CodecTupleVariant | CodecValueVariant | CodecEmptyVariant;
export interface CodecVariantType {
    kind: TypeKind.Variant;
    variants: (CodecVariant | undefined)[];
    variantsByName: Record<string, CodecVariant>;
}
export interface CodecBytesType {
    kind: TypeKind.Bytes;
}
export interface CodecBytesArrayType {
    kind: TypeKind.BytesArray;
    len: number;
}
export interface CodecBooleanOptionType {
    kind: TypeKind.BooleanOption;
}
export interface CodecCompactType {
    kind: TypeKind.Compact;
    integer: Primitive;
}
export declare type CodecType = PrimitiveType | SequenceType | BitSequenceType | ArrayType | TupleType | OptionType | DoNotConstructType | CodecCompactType | CodecStructType | CodecVariantType | CodecBytesType | CodecBytesArrayType | CodecBooleanOptionType;
export declare function getUnwrappedType(types: Type[], ti: Ti): Type;
export declare function getCodecType(types: Type[], ti: Ti): CodecType;
export declare function toCodecTypes(types: Type[]): CodecType[];
//# sourceMappingURL=types-codec.d.ts.map