"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findSpecVersions = void 0;
async function findSpecVersions(options) {
    let { fetch, progress } = options;
    let queue = [];
    let versions = new Map();
    function add(v) {
        versions.set(`${v.specName}@${v.specVersion}`, v);
    }
    let [beg, end] = await fetch([options.firstBlock, options.lastBlock]);
    add(beg);
    if (!equalSpecs(beg, end)) {
        add(end);
        queue.push([beg, end]);
    }
    let step = 0;
    while (queue.length) {
        let batch = queue.slice(0, 20);
        queue = queue.slice(20);
        step += 1;
        progress?.({ step, versions: versions.size });
        let heights = batch.map(([b, e]) => b.blockNumber + Math.floor((e.blockNumber - b.blockNumber) / 2));
        let newVersions = await fetch(heights);
        batch.forEach(([b, e], idx) => {
            let m = newVersions[idx];
            if (!equalSpecs(b, m)) {
                add(m);
            }
            if (!equalSpecs(b, m) && m.blockNumber - b.blockNumber > 1) {
                queue.push([b, m]);
            }
            if (!equalSpecs(m, e) && e.blockNumber - m.blockNumber > 1) {
                queue.push([m, e]);
            }
        });
    }
    return Array.from(versions.values()).sort((a, b) => a.blockNumber - b.blockNumber);
}
exports.findSpecVersions = findSpecVersions;
function equalSpecs(a, b) {
    return a.specName == b.specName && a.specVersion == b.specVersion;
}
//# sourceMappingURL=binarySearch.js.map