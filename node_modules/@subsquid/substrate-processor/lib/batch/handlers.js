"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataHandlers = void 0;
class DataHandlers {
    constructor() {
        this.pre = { handlers: [], data: { includeAllBlocks: false } };
        this.post = { handlers: [], data: { includeAllBlocks: false } };
        this.events = {};
        this.calls = {};
        this.evmLogs = {};
        this.ethereumTransactions = {};
        this.contractsContractEmitted = {};
        this.gearMessageEnqueued = {};
        this.gearUserMessageSent = {};
    }
    merge(other) {
        let res = new DataHandlers();
        res.pre = mergeBlockHandlerLists(this.pre, other.pre);
        res.post = mergeBlockHandlerLists(this.post, other.post);
        res.events = mergeMaps(this.events, other.events, mergeItemHandlerLists);
        res.calls = mergeMaps(this.calls, other.calls, mergeItemHandlerLists);
        res.evmLogs = mergeMaps(this.evmLogs, other.evmLogs, (ha, hb) => ha.concat(hb));
        res.ethereumTransactions = mergeMaps(this.ethereumTransactions, other.ethereumTransactions, (a, b) => mergeMaps(a, b, mergeItemHandlerLists));
        res.contractsContractEmitted = mergeMaps(this.contractsContractEmitted, other.contractsContractEmitted, mergeItemHandlerLists);
        res.gearMessageEnqueued = mergeMaps(this.gearMessageEnqueued, other.gearMessageEnqueued, mergeItemHandlerLists);
        res.gearUserMessageSent = mergeMaps(this.gearUserMessageSent, other.gearUserMessageSent, mergeItemHandlerLists);
        return res;
    }
    getIncludeAllBlocks() {
        return includeAllBlocks(this.pre) || includeAllBlocks(this.post);
    }
    getEvents() {
        let all = {};
        function add(name, data) {
            let current = all[name];
            if (current) {
                all[name] = mergeRequests(current, data || true);
            }
            else {
                all[name] = data;
            }
        }
        Object.entries(this.events).forEach(([name, hs]) => {
            if (hs.handlers.length > 0) {
                add(name, hs.data || true);
            }
        });
        function addBlock(req) {
            if (!req)
                return;
            if (req === true || req.items === true)
                return add('*', true);
            if (!req.items || !req.items.events)
                return;
            if (req.items.events === true)
                return add('*', true);
            for (let name in req.items.events) {
                let r = req.items.events[name];
                if (r) {
                    add(name, r);
                }
            }
        }
        if (this.pre.handlers.length > 0) {
            addBlock(this.pre.data);
        }
        if (this.post.handlers.length > 0) {
            addBlock(this.post.data);
        }
        return Object.entries(all).map(([name, data]) => {
            return {
                name,
                data: data === true ? undefined : data
            };
        });
    }
    getCalls() {
        let all = {};
        function add(name, data) {
            let current = all[name];
            if (current) {
                all[name] = mergeRequests(current, data || true);
            }
            else {
                all[name] = data;
            }
        }
        Object.entries(this.calls).forEach(([name, hs]) => {
            if (hs.handlers.length > 0) {
                add(name, hs.data || true);
            }
        });
        function addBlock(req) {
            if (!req)
                return;
            if (req === true || req.items === true)
                return add('*', true);
            if (!req.items || !req.items.calls)
                return;
            if (req.items.calls === true)
                return add('*', true);
            for (let name in req.items.calls) {
                let r = req.items.calls[name];
                if (r) {
                    add(name, r);
                }
            }
        }
        if (this.pre.handlers.length > 0) {
            addBlock(this.pre.data);
        }
        if (this.post.handlers.length > 0) {
            addBlock(this.post.data);
        }
        return Object.entries(all).map(([name, data]) => {
            return {
                name,
                data: data === true ? undefined : data
            };
        });
    }
    getEvmLogs() {
        return Object.entries(this.evmLogs).flatMap(([contract, hs]) => {
            return hs.map(h => {
                return {
                    contract,
                    filter: h.filter,
                    data: h.data
                };
            });
        });
    }
    getEthereumTransactions() {
        return Object.entries(this.ethereumTransactions).flatMap(([contract, sighashMap]) => {
            return Object.entries(sighashMap).map(([sighash, { data }]) => {
                return {
                    contract,
                    sighash: sighash == '*' ? undefined : sighash,
                    data
                };
            });
        });
    }
    getContractsEvents() {
        return Object.entries(this.contractsContractEmitted).map(([contract, { data }]) => {
            return {
                contract,
                data
            };
        });
    }
    getGearMessagesEnqueued() {
        return Object.entries(this.gearMessageEnqueued).map(([program, { data }]) => {
            return {
                program,
                data
            };
        });
    }
    getGearUserMessagesSent() {
        return Object.entries(this.gearUserMessageSent).map(([program, { data }]) => {
            return {
                program,
                data
            };
        });
    }
    getAcalaEvmExecuted() {
        return [];
    }
    getAcalaEvmExecutedFailed() {
        return [];
    }
}
exports.DataHandlers = DataHandlers;
function mergeBlockHandlerLists(a, b) {
    if (a.handlers.length == 0)
        return b;
    if (b.handlers.length == 0)
        return a;
    let includeAllBlocks = a.data == null ||
        b.data == null ||
        !!a.data.includeAllBlocks ||
        !!b.data.includeAllBlocks;
    return {
        data: {
            includeAllBlocks,
            items: mergeRequests(a.data?.items, b.data?.items)
        },
        handlers: a.handlers.concat(b.handlers)
    };
}
function mergeItemHandlerLists(a, b) {
    return {
        data: a.data == null || b.data == null ? undefined : mergeRequests(a.data, b.data),
        handlers: a.handlers.concat(b.handlers)
    };
}
function mergeRequests(a, b) {
    if (a === true || b === true)
        return true;
    if (!a)
        return b;
    if (!b)
        return a;
    return mergeMaps(a, b, mergeRequests);
}
function mergeMaps(a, b, mergeItems) {
    let result = {};
    for (let key in a) {
        if (b[key] == null) {
            result[key] = a[key];
        }
        else {
            result[key] = mergeItems(a[key], b[key]);
        }
    }
    for (let key in b) {
        if (!(key in a)) {
            result[key] = b[key];
        }
    }
    return result;
}
function includeAllBlocks(hs) {
    if (hs.handlers.length == 0)
        return false;
    return hs.data == null || !!hs.data.includeAllBlocks;
}
//# sourceMappingURL=handlers.js.map