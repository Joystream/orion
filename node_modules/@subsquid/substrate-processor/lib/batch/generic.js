"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBlocksCount = exports.applyRangeBound = exports.mergeBatches = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_binary_heap_1 = require("@subsquid/util-internal-binary-heap");
const range_1 = require("../util/range");
function mergeBatches(batches, mergeRequests) {
    if (batches.length <= 1)
        return batches;
    let union = [];
    let heap = new util_internal_binary_heap_1.Heap((a, b) => a.range.from - b.range.from);
    heap.init(batches.slice());
    let top = (0, util_internal_1.assertNotNull)(heap.pop());
    let batch;
    while (batch = heap.peek()) {
        let i = (0, range_1.rangeIntersection)(top.range, batch.range);
        if (i == null) {
            union.push(top);
            top = (0, util_internal_1.assertNotNull)(heap.pop());
        }
        else {
            heap.pop();
            (0, range_1.rangeDifference)(top.range, i).forEach(range => {
                heap.push({ range, request: top.request });
            });
            (0, range_1.rangeDifference)(batch.range, i).forEach(range => {
                heap.push({ range, request: batch.request });
            });
            heap.push({
                range: i,
                request: mergeRequests(top.request, batch.request)
            });
            top = (0, util_internal_1.assertNotNull)(heap.pop());
        }
    }
    union.push(top);
    return union;
}
exports.mergeBatches = mergeBatches;
function applyRangeBound(batches, range) {
    if (range == null)
        return batches;
    let result = [];
    for (let b of batches) {
        let i = (0, range_1.rangeIntersection)(range, b.range);
        if (i) {
            result.push({ range: i, request: b.request });
        }
    }
    return result;
}
exports.applyRangeBound = applyRangeBound;
function getBlocksCount(batches, from, to) {
    let count = 0;
    for (let i = 0; i < batches.length; i++) {
        let range = batches[i].range;
        if (to < range.from)
            return count;
        if (from > (range.to ?? Infinity))
            continue;
        let beg = Math.max(from, range.from);
        let end = Math.min(to, range.to ?? Infinity);
        count += end - beg + 1;
    }
    return count;
}
exports.getBlocksCount = getBlocksCount;
//# sourceMappingURL=generic.js.map