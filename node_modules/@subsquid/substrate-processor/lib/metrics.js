"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metrics = void 0;
const util_internal_counters_1 = require("@subsquid/util-internal-counters");
const util_internal_prometheus_server_1 = require("@subsquid/util-internal-prometheus-server");
const prom_client_1 = require("prom-client");
class Metrics {
    constructor() {
        this.chainHeight = -1;
        this.ingestSpeed = new util_internal_counters_1.Speed({ windowSize: 5 });
        this.mappingSpeed = new util_internal_counters_1.Speed({ windowSize: 5 });
        this.mappingItemSpeed = new util_internal_counters_1.Speed({ windowSize: 5 });
        this.blockProgress = new util_internal_counters_1.Progress({ initialValue: 0 });
        this.rpcSpeed = new util_internal_counters_1.Speed({ windowSize: 60, windowGranularitySeconds: 1 });
        this.registry = new prom_client_1.Registry();
        this.lastBlockGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_last_block',
            help: 'Last processed block',
            registers: [this.registry],
            aggregator: 'max'
        });
        this.chainHeightGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_chain_height',
            help: 'Chain height of the data source',
            registers: [this.registry],
            aggregator: 'max',
            collect: this.collect(() => this.chainHeight)
        });
        this.mappingSpeedGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_mapping_blocks_per_second',
            help: 'Mapping performance',
            registers: [this.registry],
            collect: this.collect(() => this.mappingSpeed.speed())
        });
        this.ingestSpeedGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_ingest_blocks_per_second',
            help: 'Data fetching speed',
            registers: [this.registry],
            collect: this.collect(() => this.ingestSpeed.speed())
        });
        this.syncEtaGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_sync_eta_seconds',
            help: 'Estimated time until all required blocks will be processed or until chain height will be reached',
            registers: [this.registry],
            collect: this.collect(() => this.blockProgress.eta())
        });
        this.syncRatioGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_sync_ratio',
            help: 'Percentage of processed blocks',
            registers: [this.registry],
            aggregator: 'max',
            collect: this.collect(() => this.blockProgress.ratio())
        });
        this.archiveHttpErrorsCounter = new prom_client_1.Counter({
            name: 'sqd_processor_archive_http_errors',
            help: 'Number of archive http connection errors',
            registers: [this.registry],
            aggregator: 'sum',
            labelNames: ['url']
        });
        this.archiveHttpErrorsInRowGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_archive_http_errors_in_row',
            help: 'Number of archive http connection errors happened in row, without single successful request',
            registers: [this.registry],
            aggregator: 'sum',
            labelNames: ['url']
        });
        this.chainRpcErrorsCounter = new prom_client_1.Counter({
            name: 'sqd_processor_chain_rpc_errors',
            help: 'Number of chain rpc connection errors',
            registers: [this.registry],
            aggregator: 'sum',
            labelNames: ['url']
        });
        this.chainRpcErrorsInRowGauge = new prom_client_1.Gauge({
            name: 'sqd_processor_chain_rpc_errors_in_row',
            help: 'Number of chain rpc connection errors happened in row, without single successful request',
            registers: [this.registry],
            aggregator: 'sum',
            labelNames: ['url']
        });
        this.chainRpcAvgResponseTime = new prom_client_1.Gauge({
            name: 'sqd_processor_chain_rpc_avg_response_time_seconds',
            help: 'Avg response time of chain RPC',
            registers: [this.registry],
            collect: this.collect(() => {
                let speed = this.rpcSpeed.speed();
                return speed == 0 ? 0 : 1 / speed;
            })
        });
        (0, prom_client_1.collectDefaultMetrics)({ register: this.registry });
        this.setLastProcessedBlock(-1);
        this.setChainHeight(-1);
    }
    collect(fn) {
        return function () {
            this.set(fn());
        };
    }
    setLastProcessedBlock(height) {
        this.lastBlockGauge.set(height);
    }
    setChainHeight(height) {
        this.chainHeight = height;
    }
    updateProgress(chainHeight, estimatedTotalBlocksCount, estimatedBlocksLeft, time) {
        this.setChainHeight(chainHeight);
        this.blockProgress.setTargetValue(estimatedTotalBlocksCount);
        this.blockProgress.setCurrentValue(estimatedTotalBlocksCount - estimatedBlocksLeft, time);
    }
    registerBatch(batchSize, batchItemSize, batchFetchStartTime, batchFetchEndTime, batchMappingStartTime, batchMappingEndTime) {
        this.ingestSpeed.push(batchSize, batchFetchStartTime, batchFetchEndTime);
        this.mappingSpeed.push(batchSize, batchMappingStartTime, batchMappingEndTime);
        this.mappingItemSpeed.push(batchItemSize, batchMappingStartTime, batchMappingEndTime);
    }
    registerArchiveRetry(url, errorsInRow) {
        this.archiveHttpErrorsCounter.inc({ url });
        this.archiveHttpErrorsInRowGauge.set({ url }, errorsInRow);
    }
    registerArchiveResponse(url) {
        this.archiveHttpErrorsInRowGauge.set({ url }, 0);
    }
    registerChainRpcRetry(url, errorsInRow) {
        this.chainRpcErrorsCounter.inc({ url });
        this.chainRpcErrorsInRowGauge.set({ url }, errorsInRow);
    }
    registerChainRpcResponse(url, method, beg, end) {
        this.chainRpcErrorsInRowGauge.set({ url }, 0);
        this.rpcSpeed.push(1, beg, end);
    }
    getChainHeight() {
        return this.chainHeight;
    }
    getSyncSpeed() {
        return this.blockProgress.speed();
    }
    getSyncEtaSeconds() {
        return this.blockProgress.eta();
    }
    getSyncRatio() {
        return this.blockProgress.ratio();
    }
    getIngestSpeed() {
        return this.ingestSpeed.speed();
    }
    getMappingSpeed() {
        return this.mappingSpeed.speed();
    }
    getMappingItemSpeed() {
        return this.mappingItemSpeed.speed();
    }
    serve(port) {
        return (0, util_internal_prometheus_server_1.createPrometheusServer)(this.registry, port);
    }
}
exports.Metrics = Metrics;
//# sourceMappingURL=metrics.js.map