"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateProcessor = void 0;
const logger_1 = require("@subsquid/logger");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const typesBundle_1 = require("@subsquid/substrate-metadata/lib/old/typesBundle");
const typesBundle_polkadotjs_1 = require("@subsquid/substrate-metadata/lib/old/typesBundle-polkadotjs");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const generic_1 = require("../batch/generic");
const handlers_1 = require("../batch/handlers");
const misc_1 = require("../util/misc");
const runner_1 = require("./runner");
/**
 * Provides methods to configure and launch data processing.
 */
class SubstrateProcessor {
    /**
     * @param db - database is responsible for providing storage to data handlers
     * and persisting mapping progress and status.
     */
    constructor(db) {
        this.db = db;
        this.hooks = {
            pre: [],
            post: [],
            event: [],
            call: [],
            evmLog: [],
            ethereumTransaction: [],
            contractsContractEmitted: [],
            gearMessageEnqueued: [],
            gearUserMessageSent: [],
        };
        this.blockRange = { from: 0 };
        this.running = false;
    }
    /**
     * Sets blockchain data source.
     *
     * @example
     * processor.setDataSource({
     *     chain: 'wss://rpc.polkadot.io',
     *     archive: 'https://polkadot.indexer.gc.subsquid.io/v4/graphql'
     * })
     */
    setDataSource(src) {
        this.assertNotRunning();
        this.src = src;
        return this;
    }
    /**
     * Sets types bundle.
     *
     * Types bundle is only required for blocks which have
     * metadata version below 14 and only if we don't have built-in
     * support for the chain in question.
     *
     * Subsquid project has its own types bundle format,
     * however, most of polkadotjs types bundles will work as well.
     *
     * Types bundle can be specified in 2 different ways:
     *
     * 1. as a name of a JSON file
     * 2. as an {@link OldTypesBundle} or {@link OldSpecsBundle} or {@link PolkadotjsTypesBundle} object
     *
     * @example
     * // A path to a JSON file resolved relative to `cwd`.
     * processor.setTypesBundle('typesBundle.json')
     *
     * // OldTypesBundle object
     * processor.setTypesBundle({
     *     types: {
     *         Foo: 'u8'
     *     }
     * })
     */
    setTypesBundle(bundle) {
        this.assertNotRunning();
        if (typeof bundle == 'string') {
            this.typesBundle = (0, substrate_metadata_1.getOldTypesBundle)(bundle) || (0, substrate_metadata_1.readOldTypesBundle)(bundle);
        }
        else {
            this.typesBundle = (0, typesBundle_polkadotjs_1.eliminatePolkadotjsTypesBundle)(bundle);
        }
        return this;
    }
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     *
     * @example
     * // process only block 100
     * processor.setBlockRange({
     *     from: 100,
     *     to: 100
     * })
     */
    setBlockRange(range) {
        this.assertNotRunning();
        this.blockRange = range;
        return this;
    }
    /**
     *  Used to set the maximum number of blocks which could be fetched
     *  from the data source in a single request.
     *
     *  Now this setting has no effect.
     *
     *  The amount of returned data is determined by the datasource.
     *
     * @deprecated
     */
    setBatchSize(size) {
        this.getLogger().warn('.setBatchSize() is deprecated and has no effect');
        return this;
    }
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port) {
        this.assertNotRunning();
        this.prometheusPort = port;
        return this;
    }
    addPreHook(fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = fnOrOptions;
        }
        this.hooks.pre.push({ handler, ...options });
        return this;
    }
    addPostHook(fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = fnOrOptions;
        }
        this.hooks.post.push({ handler, ...options });
        return this;
    }
    addEventHandler(eventName, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions === 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = fnOrOptions;
        }
        this.hooks.event.push({
            event: eventName,
            handler,
            ...options
        });
        return this;
    }
    addCallHandler(callName, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = { ...fnOrOptions };
        }
        this.hooks.call.push({
            call: callName,
            handler,
            ...options
        });
        return this;
    }
    addEvmLogHandler(contractAddress, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = { ...fnOrOptions };
        }
        let contractAddresses = Array.isArray(contractAddress) ? contractAddress : [contractAddress];
        this.hooks.evmLog.push(...contractAddresses.map((contractAddress) => ({
            handler,
            contractAddress: contractAddress.toLowerCase(),
            ...options
        })));
        return this;
    }
    addEthereumTransactionHandler(contractAddress, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = { ...fnOrOptions };
        }
        let contractAddresses = Array.isArray(contractAddress) ? contractAddress : [contractAddress];
        this.hooks.ethereumTransaction.push(...contractAddresses.map((contractAddress) => ({
            handler,
            contractAddress: contractAddress.toLowerCase(),
            ...options
        })));
        return this;
    }
    addContractsContractEmittedHandler(contractAddress, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = { ...fnOrOptions };
        }
        this.hooks.contractsContractEmitted.push({
            handler,
            contractAddress: contractAddress.toLowerCase(),
            ...options
        });
        return this;
    }
    addGearMessageEnqueuedHandler(programId, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = { ...fnOrOptions };
        }
        this.hooks.gearMessageEnqueued.push({
            handler,
            programId,
            ...options
        });
        return this;
    }
    addGearUserMessageSentHandler(programId, fnOrOptions, fn) {
        this.assertNotRunning();
        let handler;
        let options = {};
        if (typeof fnOrOptions == 'function') {
            handler = fnOrOptions;
        }
        else {
            handler = (0, util_internal_1.assertNotNull)(fn);
            options = { ...fnOrOptions };
        }
        this.hooks.gearUserMessageSent.push({
            handler,
            programId,
            ...options
        });
        return this;
    }
    assertNotRunning() {
        if (this.running) {
            throw new Error('Settings modifications are not allowed after start of processing');
        }
    }
    createBatches(blockRange) {
        let batches = [];
        function getRange(hook) {
            return hook.range || { from: 0 };
        }
        this.hooks.pre.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.pre = { handlers: [hook.handler], data: hook.data };
            batches.push({ range, request });
        });
        this.hooks.post.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.post = { handlers: [hook.handler], data: hook.data };
            batches.push({ range, request });
        });
        this.hooks.event.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.events = {
                [hook.event]: { data: hook.data, handlers: [hook.handler] }
            };
            batches.push({ range, request });
        });
        this.hooks.call.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.calls = {
                [hook.call]: {
                    data: hook.data,
                    handlers: [{
                            handler: hook.handler,
                            triggerForFailedCalls: hook.triggerForFailedCalls
                        }]
                }
            };
            batches.push({ range, request });
        });
        this.hooks.evmLog.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.evmLogs = {
                [hook.contractAddress]: [{
                        filter: hook.filter,
                        handler: hook.handler
                    }]
            };
            batches.push({ range, request });
        });
        this.hooks.ethereumTransaction.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.ethereumTransactions = {
                [hook.contractAddress]: {
                    [hook.sighash || '*']: {
                        data: hook.data,
                        handlers: [{
                                handler: hook.handler,
                                triggerForFailedCalls: hook.triggerForFailedCalls
                            }]
                    }
                }
            };
            batches.push({ range, request });
        });
        this.hooks.contractsContractEmitted.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.contractsContractEmitted = {
                [hook.contractAddress]: { data: hook.data, handlers: [hook.handler] }
            };
            batches.push({ range, request });
        });
        this.hooks.gearMessageEnqueued.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.gearMessageEnqueued = {
                [hook.programId]: { data: hook.data, handlers: [hook.handler] }
            };
            batches.push({ range, request });
        });
        this.hooks.gearUserMessageSent.forEach(hook => {
            let range = getRange(hook);
            let request = new handlers_1.DataHandlers();
            request.gearUserMessageSent = {
                [hook.programId]: { data: hook.data, handlers: [hook.handler] }
            };
            batches.push({ range, request });
        });
        batches = (0, generic_1.applyRangeBound)(batches, blockRange);
        return (0, generic_1.mergeBatches)(batches, (a, b) => a.merge(b));
    }
    getLogger() {
        return (0, logger_1.createLogger)('sqd:processor');
    }
    getOptions() {
        return {
            blockRange: this.blockRange,
            prometheusPort: this.prometheusPort,
        };
    }
    getDatabase() {
        return this.db;
    }
    getTypes(specName, specVersion) {
        let bundle;
        if (this.typesBundle != null) {
            bundle = this.typesBundle;
        }
        else {
            bundle = (0, substrate_metadata_1.getOldTypesBundle)(specName);
        }
        bundle = (0, util_internal_1.assertNotNull)(bundle, `Types bundle is required for ${specName}@${specVersion}. Provide it via .setTypesBundle()`);
        return (0, typesBundle_1.getTypesFromBundle)(bundle, specVersion, specName);
    }
    getArchiveEndpoint() {
        let url = this.src?.archive;
        if (url == null) {
            throw new Error('use .setDataSource() to specify archive url');
        }
        return url;
    }
    getChainEndpoint() {
        let url = this.src?.chain;
        if (url == null) {
            throw new Error(`use .setDataSource() to specify chain RPC endpoint`);
        }
        return url;
    }
    /**
     * Starts data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     */
    run() {
        if (this.running)
            return;
        this.running = true;
        (0, util_internal_1.runProgram)(async () => {
            return new HandlerRunner(this).run();
        }, err => {
            this.getLogger().fatal(err);
        });
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", logger_1.Logger)
], SubstrateProcessor.prototype, "getLogger", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], SubstrateProcessor.prototype, "getOptions", null);
exports.SubstrateProcessor = SubstrateProcessor;
class HandlerRunner extends runner_1.Runner {
    async processBatch(handlers, chain, blocks) {
        for (let block of blocks) {
            (0, assert_1.default)(this.lastBlock < block.header.height);
            let height = block.header.height;
            await this.config.getDatabase().transact(height, height, store => {
                return this.processBlock(handlers, chain, store, block);
            }).catch((0, misc_1.withErrorContext)({
                blockHeight: block.header.height,
                blockHash: block.header.hash
            }));
            this.lastBlock = block.header.height;
        }
    }
    async processBlock(handlers, chain, store, block) {
        let blockLog = this.config.getLogger().child('mapping', {
            blockHeight: block.header.height,
            blockHash: block.header.hash
        });
        let ctx = {
            _chain: chain,
            log: blockLog.child({ hook: 'pre' }),
            store,
            block: block.header
        };
        for (let pre of handlers.pre.handlers) {
            ctx.log.debug('begin');
            await pre({ ...ctx, items: block.items });
            ctx.log.debug('end');
        }
        for (let item of block.items) {
            switch (item.kind) {
                case 'event':
                    for (let handler of this.getEventHandlers(handlers, item.event)) {
                        let log = blockLog.child({
                            hook: 'event',
                            eventName: item.event.name,
                            eventId: item.event.id
                        });
                        log.debug('begin');
                        await handler({ ...ctx, log, event: item.event });
                        log.debug('end');
                    }
                    for (let handler of this.getEvmLogHandlers(handlers.evmLogs, item.event)) {
                        let event = item.event;
                        let log = blockLog.child({
                            hook: 'evm-log',
                            contractAddress: event.args.address || event.args.log.address,
                            eventId: event.id
                        });
                        log.debug('begin');
                        await handler({
                            ...ctx,
                            log,
                            event
                        });
                        log.debug('end');
                    }
                    for (let handler of this.getContractEmittedHandlers(handlers, item.event)) {
                        let event = item.event;
                        let log = blockLog.child({
                            hook: 'contract-emitted',
                            contractAddress: event.args.contract,
                            eventId: event.id
                        });
                        log.debug('begin');
                        await handler({
                            ...ctx,
                            log,
                            event
                        });
                        log.debug('end');
                    }
                    for (let handler of this.getGearMessageEnqueuedHandlers(handlers, item.event)) {
                        let event = item.event;
                        let log = blockLog.child({
                            hook: 'gear-message-enqueued',
                            programId: event.args.destination,
                            eventId: event.id
                        });
                        log.debug('begin');
                        await handler({
                            ...ctx,
                            log,
                            event
                        });
                        log.debug('end');
                    }
                    for (let handler of this.getGearUserMessageSentHandlers(handlers, item.event)) {
                        let event = item.event;
                        let log = blockLog.child({
                            hook: 'gear-message-sent',
                            programId: event.args.message.source,
                            eventId: event.id
                        });
                        log.debug('begin');
                        await handler({
                            ...ctx,
                            log,
                            event
                        });
                        log.debug('end');
                    }
                    break;
                case 'call':
                    for (let handler of this.getCallHandlers(handlers, item.call)) {
                        if (item.call.success || handler.triggerForFailedCalls) {
                            let log = blockLog.child({
                                hook: 'call',
                                callName: item.call.name,
                                callId: item.call.id
                            });
                            let { kind, ...data } = item;
                            log.debug('begin');
                            await handler.handler({ ...ctx, log, ...data });
                            log.debug('end');
                        }
                    }
                    for (let handler of this.getEthereumTransactionHandlers(handlers, item.call)) {
                        if (item.call.success || handler.triggerForFailedCalls) {
                            let log = blockLog.child({
                                hook: 'ethereum-transaction',
                                callName: item.call.name,
                                callId: item.call.id
                            });
                            let { kind, ...data } = item;
                            log.debug('begin');
                            await handler.handler({ ...ctx, log, ...data });
                            log.debug('end');
                        }
                    }
                    break;
                default:
                    throw (0, util_internal_1.unexpectedCase)();
            }
        }
        ctx.log = blockLog.child({ hook: 'post' });
        for (let post of handlers.post.handlers) {
            ctx.log.debug('begin');
            await post({ ...ctx, items: block.items });
            ctx.log.debug('end');
        }
    }
    *getEventHandlers(handlers, event) {
        for (let hs of extract(handlers.events, event.name)) {
            yield* hs.handlers;
        }
    }
    *getCallHandlers(handlers, call) {
        for (let hs of extract(handlers.calls, call.name)) {
            yield* hs.handlers;
        }
    }
    *getEthereumTransactionHandlers(handlers, call) {
        if (call.name != 'Ethereum.transact')
            return;
        let tx = call.args.transaction.value.action ? call.args.transaction.value : call.args.transaction;
        let contractAddress = tx.action.value;
        if (contractAddress == null)
            return;
        let sighash = tx.input.slice(0, 10);
        for (let sighashMap of extract(handlers.ethereumTransactions, contractAddress)) {
            for (let hs of extract(sighashMap, sighash)) {
                yield* hs.handlers;
            }
        }
    }
    *getEvmLogHandlers(evmLogs, event) {
        if (event.name != 'EVM.Log')
            return;
        let log = event;
        let contractAddress = (0, util_internal_1.assertNotNull)(log.args.address || log.args.log.address);
        let contractHandlers = evmLogs[contractAddress];
        if (contractHandlers == null)
            return;
        for (let h of contractHandlers) {
            if (this.evmHandlerMatches(h, log)) {
                yield h.handler;
            }
        }
    }
    evmHandlerMatches(handler, event) {
        if (handler.filter == null)
            return true;
        let log = event.args.log || event.args;
        for (let i = 0; i < handler.filter.length; i++) {
            let set = handler.filter[i];
            if (set == null)
                continue;
            if (Array.isArray(set)) {
                if (!set.includes(log.topics[i])) {
                    return false;
                }
            }
            else if (set !== log.topics[i]) {
                return false;
            }
        }
        return true;
    }
    *getContractEmittedHandlers(handlers, event) {
        if (event.name != 'Contracts.ContractEmitted')
            return;
        let e = event;
        let hs = handlers.contractsContractEmitted[e.args.contract];
        if (hs == null)
            return;
        for (let h of hs.handlers) {
            yield h;
        }
    }
    *getGearMessageEnqueuedHandlers(handlers, event) {
        if (event.name != 'Gear.MessageEnqueued')
            return;
        let e = event;
        let hs = handlers.gearMessageEnqueued[e.args.destination];
        if (hs == null)
            return;
        for (let h of hs.handlers) {
            yield h;
        }
    }
    *getGearUserMessageSentHandlers(handlers, event) {
        if (event.name != 'Gear.UserMessageSent')
            return;
        let e = event;
        let hs = handlers.gearUserMessageSent[e.args.message.source];
        if (hs == null)
            return;
        for (let h of hs.handlers) {
            yield h;
        }
    }
}
function* extract(map, key) {
    let item = map['*'];
    if (item)
        yield item;
    item = map[key];
    if (item)
        yield item;
}
//# sourceMappingURL=handlerProcessor.js.map