"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstrateBatchProcessor = void 0;
const logger_1 = require("@subsquid/logger");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const typesBundle_1 = require("@subsquid/substrate-metadata/lib/old/typesBundle");
const typesBundle_polkadotjs_1 = require("@subsquid/substrate-metadata/lib/old/typesBundle-polkadotjs");
const util_internal_1 = require("@subsquid/util-internal");
const generic_1 = require("../batch/generic");
const request_1 = require("../batch/request");
const runner_1 = require("./runner");
/**
 * Provides methods to configure and launch data processing.
 *
 * Unlike {@link SubstrateProcessor}, `SubstrateBatchProcessor` can have
 * only one data handler, which accepts a list of blocks.
 *
 * This gives mapping developers an opportunity to reduce the number of round-trips
 * both to database and chain nodes,
 * thus providing much better performance.
 */
class SubstrateBatchProcessor {
    constructor() {
        this.batches = [];
        this.options = {};
        this.running = false;
    }
    add(request, range) {
        this.batches.push({
            range: range || { from: 0 },
            request
        });
    }
    addEvent(name, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        req.events.push({ name, data: options?.data });
        this.add(req, options?.range);
        return this;
    }
    addCall(name, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        req.calls.push({ name, data: options?.data });
        this.add(req, options?.range);
        return this;
    }
    addEvmLog(contractAddress, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        let contractAddresses = Array.isArray(contractAddress) ? contractAddress : [contractAddress];
        req.evmLogs.push(...contractAddresses.map((contractAddress) => ({
            contract: contractAddress.toLowerCase(),
            filter: options?.filter,
            data: options?.data
        })));
        this.add(req, options?.range);
        return this;
    }
    addEthereumTransaction(contractAddress, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        let contractAddresses = Array.isArray(contractAddress) ? contractAddress : [contractAddress];
        req.ethereumTransactions.push(...contractAddresses.map((contractAddress) => ({
            contract: contractAddress.toLowerCase(),
            sighash: options?.sighash,
            data: options?.data
        })));
        this.add(req, options?.range);
        return this;
    }
    addContractsContractEmitted(contractAddress, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        req.contractsEvents.push({
            contract: contractAddress.toLowerCase(),
            data: options?.data
        });
        this.add(req, options?.range);
        return this;
    }
    addGearMessageEnqueued(programId, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        req.gearMessagesEnqueued.push({
            program: programId,
            data: options?.data
        });
        this.add(req, options?.range);
        return this;
    }
    addGearUserMessageSent(programId, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        req.gearUserMessagesSent.push({
            program: programId,
            data: options?.data
        });
        this.add(req, options?.range);
        return this;
    }
    addAcalaEvmExecuted(contractAddress, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        let contractAddresses = Array.isArray(contractAddress) ? contractAddress : [contractAddress];
        req.acalaEvmExecuted.push(...contractAddresses.map((contractAddress) => ({
            contract: contractAddress.toLowerCase(),
            logs: options?.logs,
            data: options?.data
        })));
        this.add(req, options?.range);
        return this;
    }
    addAcalaEvmExecutedFailed(contractAddress, options) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        let contractAddresses = Array.isArray(contractAddress) ? contractAddress : [contractAddress];
        req.acalaEvmExecutedFailed.push(...contractAddresses.map((contractAddress) => ({
            contract: contractAddress.toLowerCase(),
            logs: options?.logs,
            data: options?.data
        })));
        this.add(req, options?.range);
        return this;
    }
    /**
     * By default, the processor will fetch only blocks
     * which contain requested items. This method
     * modifies such behaviour to fetch all chain blocks.
     *
     * Optionally a range of blocks can be specified
     * for which the setting should be effective.
     */
    includeAllBlocks(range) {
        this.assertNotRunning();
        let req = new request_1.PlainBatchRequest();
        req.includeAllBlocks = true;
        this.add(req);
        return this;
    }
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port) {
        this.assertNotRunning();
        this.options.prometheusPort = port;
        return this;
    }
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     */
    setBlockRange(range) {
        this.assertNotRunning();
        this.options.blockRange = range;
        return this;
    }
    /**
     *  Used to set the maximum number of blocks which could be fetched
     *  from the data source in a single request.
     *
     *  Now this setting has no effect.
     *
     *  The amount of returned data is determined by the datasource.
     *
     * @deprecated
     */
    setBatchSize(size) {
        this.getLogger().warn('.setBatchSize() is deprecated and has no effect');
        return this;
    }
    /**
     * Sets blockchain data source.
     *
     * @example
     * processor.setDataSource({
     *     chain: 'wss://rpc.polkadot.io',
     *     archive: 'https://polkadot.archive.subsquid.io/graphql'
     * })
     */
    setDataSource(src) {
        this.assertNotRunning();
        this.src = src;
        return this;
    }
    /**
     * Sets types bundle.
     *
     * Types bundle is only required for blocks which have
     * metadata version below 14 and only if we don't have built-in
     * support for the chain in question.
     *
     * Subsquid project has its own types bundle format,
     * however, most of polkadotjs types bundles will work as well.
     *
     * Types bundle can be specified in 2 different ways:
     *
     * 1. as a name of a JSON file
     * 2. as an {@link OldTypesBundle} or {@link OldSpecsBundle} or {@link PolkadotjsTypesBundle} object
     *
     * @example
     * // A path to a JSON file resolved relative to `cwd`.
     * processor.setTypesBundle('typesBundle.json')
     *
     * // OldTypesBundle object
     * processor.setTypesBundle({
     *     types: {
     *         Foo: 'u8'
     *     }
     * })
     */
    setTypesBundle(bundle) {
        this.assertNotRunning();
        if (typeof bundle == 'string') {
            this.typesBundle = (0, substrate_metadata_1.getOldTypesBundle)(bundle) || (0, substrate_metadata_1.readOldTypesBundle)(bundle);
        }
        else {
            this.typesBundle = (0, typesBundle_polkadotjs_1.eliminatePolkadotjsTypesBundle)(bundle);
        }
        return this;
    }
    assertNotRunning() {
        if (this.running) {
            throw new Error('Settings modifications are not allowed after start of processing');
        }
    }
    getTypes(specName, specVersion) {
        let bundle = this.typesBundle || (0, substrate_metadata_1.getOldTypesBundle)(specName);
        if (bundle == null)
            throw new Error(`Types bundle is required for ${specName}@${specVersion}. Provide it via .setTypesBundle() or .setPolkadotjsTypesBundle()`);
        return (0, typesBundle_1.getTypesFromBundle)(bundle, specVersion, specName);
    }
    getArchiveEndpoint() {
        let url = this.src?.archive;
        if (url == null) {
            throw new Error('use .setDataSource() to specify archive url');
        }
        return url;
    }
    getChainEndpoint() {
        let url = this.src?.chain;
        if (url == null) {
            throw new Error(`use .setDataSource() to specify chain RPC endpoint`);
        }
        return url;
    }
    getLogger() {
        return (0, logger_1.createLogger)('sqd:processor');
    }
    /**
     * Run data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     *
     * @param db - database is responsible for providing storage to data handlers
     * and persisting mapping progress and status.
     *
     * @param handler - The data handler, see {@link BatchContext} for an API available to the handler.
     */
    run(db, handler) {
        let logger = this.getLogger();
        this.running = true;
        (0, util_internal_1.runProgram)(async () => {
            let batches = (0, generic_1.mergeBatches)(this.batches, (a, b) => a.merge(b));
            let config = {
                getDatabase: () => db,
                getArchiveEndpoint: () => this.getArchiveEndpoint(),
                getChainEndpoint: () => this.getChainEndpoint(),
                getTypes: this.getTypes.bind(this),
                getLogger: () => logger,
                getOptions: () => this.options,
                createBatches(blockRange) {
                    return (0, generic_1.applyRangeBound)(batches, blockRange);
                }
            };
            let runner = new runner_1.Runner(config);
            runner.processBatch = async function (request, chain, blocks, isHead) {
                if (blocks.length == 0)
                    return;
                let from = blocks[0].header.height;
                let to = (0, util_internal_1.last)(blocks).header.height;
                return db.transact(from, to, store => {
                    return handler({
                        _chain: chain,
                        log: logger.child('mapping'),
                        store,
                        blocks: blocks,
                        isHead
                    });
                });
            };
            return runner.run();
        }, err => logger.fatal(err));
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", logger_1.Logger)
], SubstrateBatchProcessor.prototype, "getLogger", null);
exports.SubstrateBatchProcessor = SubstrateBatchProcessor;
//# sourceMappingURL=batchProcessor.js.map