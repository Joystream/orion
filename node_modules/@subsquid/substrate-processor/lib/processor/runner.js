"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = void 0;
const resilient_1 = require("@subsquid/rpc-client/lib/resilient");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_gql_request_1 = require("@subsquid/util-internal-gql-request");
const generic_1 = require("../batch/generic");
const chain_1 = require("../chain");
const ingest_1 = require("../ingest");
const metrics_1 = require("../metrics");
const misc_1 = require("../util/misc");
class Runner {
    constructor(config) {
        this.config = config;
        this.metrics = new metrics_1.Metrics();
        this._lastBlock = -1;
    }
    chainClient() {
        let url = this.config.getChainEndpoint();
        let log = this.config.getLogger().child('chain-rpc', { url });
        let metrics = this.metrics;
        let counter = 0;
        class ChainClient extends resilient_1.ResilientRpcClient {
            constructor() {
                super({
                    url,
                    onRetry(err, errorsInRow, backoff) {
                        metrics.registerChainRpcRetry(url, errorsInRow);
                        log.warn({
                            backoff,
                            reason: err.message
                        }, 'connection error');
                    }
                });
            }
            async call(method, params) {
                let id = counter;
                counter = (counter + 1) % 10000;
                log.debug({
                    req: id,
                    method,
                    params
                }, 'request');
                let beg = process.hrtime.bigint();
                let result = await super.call(method, params).catch((0, misc_1.withErrorContext)({
                    rpcUrl: url,
                    rpcRequestId: id,
                    rpcMethod: method
                }));
                let end = process.hrtime.bigint();
                let duration = end - beg;
                metrics.registerChainRpcResponse(url, method, beg, end);
                log.debug({
                    req: id,
                    responseTime: Math.round(Number(duration) / 1000000)
                }, 'response');
                return result;
            }
        }
        return new ChainClient();
    }
    archiveRequest() {
        const archiveUrl = this.config.getArchiveEndpoint();
        let log = this.config.getLogger().child('archive-request', { archiveUrl });
        let counter = 0;
        return async (archiveQuery) => {
            let archiveRequestId = counter;
            counter = (counter + 1) % 1000;
            log.debug({
                archiveRequestId,
                archiveQuery
            }, 'request');
            let response = await (0, util_internal_gql_request_1.graphqlRequest)({
                headers: {
                    'x-squid-id': this.getId(),
                },
                url: archiveUrl,
                query: archiveQuery,
                timeout: 60000,
                retry: {
                    log: (err, errorsInRow, backoff) => {
                        this.metrics.registerArchiveRetry(archiveUrl, errorsInRow);
                        log.warn({
                            archiveRequestId,
                            archiveQuery,
                            backoff,
                            reason: err.message
                        }, 'retry');
                    }
                }
            }).catch((0, misc_1.withErrorContext)({ archiveUrl, archiveRequestId, archiveQuery }));
            this.metrics.registerArchiveResponse(archiveUrl);
            log.debug({
                archiveUrl,
                archiveRequestId,
                archiveResponse: log.isTrace() ? response : undefined
            }, 'response');
            return response;
        };
    }
    chainManager() {
        return new chain_1.ChainManager({
            archiveRequest: this.archiveRequest(),
            getChainClient: () => this.chainClient(),
            getTypes: meta => this.config.getTypes(meta.specName, meta.specVersion)
        });
    }
    getWholeBlockRange() {
        return this.config.getOptions().blockRange || { from: 0 };
    }
    wholeRange() {
        return this.config.createBatches(this.getWholeBlockRange());
    }
    get lastBlock() {
        return this._lastBlock;
    }
    set lastBlock(height) {
        this._lastBlock = height;
        this.metrics.setLastProcessedBlock(height);
    }
    async run() {
        let log = this.config.getLogger();
        let heightAtStart = await this.config.getDatabase().connect();
        if (heightAtStart >= 0) {
            log.info(`last processed block was ${heightAtStart}`);
        }
        let blockRange = this.getWholeBlockRange();
        if (blockRange.to != null && blockRange.to < heightAtStart + 1) {
            log.info(`processing range is [${blockRange.from}, ${blockRange.to}]`);
            log.info('nothing to do');
            return;
        }
        else {
            blockRange = {
                from: Math.max(heightAtStart + 1, blockRange.from),
                to: blockRange.to
            };
        }
        log.info(`processing blocks from ${blockRange.from}${blockRange.to == null ? '' : ' to ' + blockRange.to}`);
        let ingest = new ingest_1.Ingest({
            archiveRequest: this.archiveRequest(),
            batches: this.config.createBatches(blockRange),
        });
        this.metrics.updateProgress(await ingest.fetchArchiveHeight(), (0, generic_1.getBlocksCount)(this.wholeRange(), 0, ingest.getLatestKnownArchiveHeight()), (0, generic_1.getBlocksCount)(this.wholeRange(), heightAtStart + 1, ingest.getLatestKnownArchiveHeight()));
        let prometheusServer = await this.metrics.serve(this.getPrometheusPort());
        log.info(`prometheus metrics are served at port ${prometheusServer.port}`);
        return this.process(ingest);
    }
    async process(ingest) {
        for await (let batch of ingest.getBlocks()) {
            let packs = await this.splitBySpec(batch);
            let mappingStartTime = process.hrtime.bigint();
            for (let i = 0; i < packs.length; i++) {
                let pack = packs[i];
                let isHead = batch.isHead && i + 1 == packs.length;
                await this.processBatch(batch.request, pack.chain, pack.blocks, isHead);
            }
            this.lastBlock = batch.range.to;
            await this.config.getDatabase().advance(this.lastBlock, batch.isHead);
            let mappingEndTime = process.hrtime.bigint();
            this.metrics.updateProgress(ingest.getLatestKnownArchiveHeight(), (0, generic_1.getBlocksCount)(this.wholeRange(), 0, ingest.getLatestKnownArchiveHeight()), (0, generic_1.getBlocksCount)(this.wholeRange(), this.lastBlock + 1, ingest.getLatestKnownArchiveHeight()), mappingEndTime);
            this.metrics.registerBatch(batch.blocks.length, getItemsCount(batch.blocks), batch.fetchStartTime, batch.fetchEndTime, mappingStartTime, mappingEndTime);
            this.config.getLogger().info(`${this.lastBlock} / ${this.metrics.getChainHeight()}, ` +
                `rate: ${Math.round(this.metrics.getSyncSpeed())} blocks/sec, ` +
                `mapping: ${Math.round(this.metrics.getMappingSpeed())} blocks/sec, ` +
                `${Math.round(this.metrics.getMappingItemSpeed())} items/sec, ` +
                `ingest: ${Math.round(this.metrics.getIngestSpeed())} blocks/sec, ` +
                `eta: ${(0, misc_1.timeInterval)(this.metrics.getSyncEtaSeconds())}`);
        }
    }
    async splitBySpec(batch) {
        let manager = this.chainManager();
        let result = [];
        let pack;
        for (let b of batch.blocks) {
            if (pack == null) {
                pack = {
                    chain: await manager.getChainForBlock(b.header),
                    blocks: [b]
                };
            }
            else if (pack.blocks.length > 1 && pack.blocks[0].header.specId === b.header.specId) {
                pack.blocks.push(b);
            }
            else {
                let chain = await manager.getChainForBlock(b.header);
                if (pack.chain === chain) {
                    pack.blocks.push(b);
                }
                else {
                    result.push(pack);
                    pack = {
                        chain,
                        blocks: [b]
                    };
                }
            }
        }
        if (pack) {
            result.push(pack);
        }
        return result;
    }
    async processBatch(request, chain, blocks, isHead) {
    }
    getPrometheusPort() {
        let port = this.config.getOptions().prometheusPort;
        return port == null
            ? process.env.PROCESSOR_PROMETHEUS_PORT || process.env.PROMETHEUS_PORT || 0
            : port;
    }
    getId() {
        return process.env.SQUID_ID || `gen-${randomString(10)}`;
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", resilient_1.ResilientRpcClient)
], Runner.prototype, "chainClient", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Function)
], Runner.prototype, "archiveRequest", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", chain_1.ChainManager)
], Runner.prototype, "chainManager", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Runner.prototype, "wholeRange", null);
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Runner.prototype, "getId", null);
exports.Runner = Runner;
function getItemsCount(blocks) {
    let count = 0;
    for (let i = 0; i < blocks.length; i++) {
        count += blocks[i].items.length;
    }
    return count;
}
function randomString(len) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < len; i++) {
        result += chars[Math.floor(Math.random() * chars.length)];
    }
    return result;
}
//# sourceMappingURL=runner.js.map