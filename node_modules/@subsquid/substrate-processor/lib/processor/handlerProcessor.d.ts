import { OldSpecsBundle, OldTypesBundle, QualifiedName } from '@subsquid/substrate-metadata';
import { PolkadotjsTypesBundle } from '@subsquid/substrate-metadata/lib/old/typesBundle-polkadotjs';
import type { BlockHandler, BlockHandlerDataRequest, BlockRangeOption, CallHandler, CallHandlerOptions, ContractsContractEmittedHandler, EthereumTransactionHandlerOptions, EventHandler, EvmLogHandler, EvmLogOptions, GearMessageEnqueuedHandler, GearUserMessageSentHandler } from '../interfaces/dataHandlers';
import type { CallDataRequest, DataSelection, EventDataRequest, NoDataSelection } from '../interfaces/dataSelection';
import type { Database } from '../interfaces/db';
import type { Hooks } from '../interfaces/hooks';
import type { Range } from '../util/range';
export interface DataSource {
    /**
     * Subsquid substrate archive endpoint URL
     */
    archive: string;
    /**
     * Chain node RPC websocket URL
     */
    chain?: string;
}
/**
 * Provides methods to configure and launch data processing.
 */
export declare class SubstrateProcessor<Store> {
    private db;
    protected hooks: Hooks;
    private blockRange;
    private prometheusPort?;
    private src?;
    private typesBundle?;
    private running;
    /**
     * @param db - database is responsible for providing storage to data handlers
     * and persisting mapping progress and status.
     */
    constructor(db: Database<Store>);
    /**
     * Sets blockchain data source.
     *
     * @example
     * processor.setDataSource({
     *     chain: 'wss://rpc.polkadot.io',
     *     archive: 'https://polkadot.indexer.gc.subsquid.io/v4/graphql'
     * })
     */
    setDataSource(src: DataSource): this;
    /**
     * Sets types bundle.
     *
     * Types bundle is only required for blocks which have
     * metadata version below 14 and only if we don't have built-in
     * support for the chain in question.
     *
     * Subsquid project has its own types bundle format,
     * however, most of polkadotjs types bundles will work as well.
     *
     * Types bundle can be specified in 2 different ways:
     *
     * 1. as a name of a JSON file
     * 2. as an {@link OldTypesBundle} or {@link OldSpecsBundle} or {@link PolkadotjsTypesBundle} object
     *
     * @example
     * // A path to a JSON file resolved relative to `cwd`.
     * processor.setTypesBundle('typesBundle.json')
     *
     * // OldTypesBundle object
     * processor.setTypesBundle({
     *     types: {
     *         Foo: 'u8'
     *     }
     * })
     */
    setTypesBundle(bundle: string | OldTypesBundle | OldSpecsBundle | PolkadotjsTypesBundle): this;
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     *
     * @example
     * // process only block 100
     * processor.setBlockRange({
     *     from: 100,
     *     to: 100
     * })
     */
    setBlockRange(range: Range): this;
    /**
     *  Used to set the maximum number of blocks which could be fetched
     *  from the data source in a single request.
     *
     *  Now this setting has no effect.
     *
     *  The amount of returned data is determined by the datasource.
     *
     * @deprecated
     */
    setBatchSize(size: number): this;
    /**
     * Sets the port for a built-in prometheus metrics server.
     *
     * By default, the value of `PROMETHEUS_PORT` environment
     * variable is used. When it is not set,
     * the processor will pick up an ephemeral port.
     */
    setPrometheusPort(port: number | string): this;
    /**
     * Registers a block level data handler which will be executed before
     * any further processing.
     *
     * See {@link BlockHandlerContext} for an API available to the handler.
     *
     * Like event and call handlers block level handler can request a specific
     * set of data to be fetched by the processor, but unlike them,
     * it is triggered for all fetched blocks.
     *
     * When data selection option is not specified,
     * block handler will be triggered for all chain blocks, those
     * causing the processor to fetch all of them.
     * This behaviour can be modified via {@link BlockHandlerDataRequest.includeAllBlocks | .data.includeAllBlocks} option.
     *
     * Relative execution order for multiple pre-block hooks is currently not defined.
     *
     * @example
     * // print heights of all chain blocks
     * processor.addPreHook(async ctx => {
     *     console.log(ctx.block.height)
     * })
     *
     * // print heights of all blocks starting from block 100000
     * processor.addPreHook({range: {from: 100000}}, async ctx => {
     *     console.log(ctx.block.height)
     * })
     *
     * // print all `Balances.Transfer` events
     * processor.addPreHook({
     *     data: {
     *         items: {
     *             events: {
     *                 'Balances.Transfer': {args: true}
     *             }
     *         }
     *     }
     * } as const, async ctx => {
     *     ctx.items.forEach(item => {
     *         if (item.name === 'Balances.Transfer') {
     *             console.log(item.event.args)
     *         }
     *     })
     * })
     *
     * // print names of all events
     * processor.addPreHook({
     *     data: {
     *        items: {
     *             events: {
     *                 '*': {}
     *             }
     *         }
     *     }
     * } as const, async ctx => {
     *     ctx.items.forEach(item => {
     *         if (item.kind == 'event) {
     *             console.log(item.event.name)
     *         }
     *     })
     * })
     */
    addPreHook(fn: BlockHandler<Store>): this;
    addPreHook(options: BlockRangeOption & NoDataSelection, fn: BlockHandler<Store>): this;
    addPreHook<R extends BlockHandlerDataRequest>(options: BlockRangeOption & DataSelection<R>, fn: BlockHandler<Store, R>): this;
    /**
     * Registers a block level data handler which will be executed
     * at the end of processing.
     *
     * See {@link BlockHandlerContext} for an API available to the handler.
     *
     * Like event and call handlers, block level handler can request a specific
     * set of data to be fetched by the processor, but unlike them,
     * it is triggered for all fetched blocks.
     *
     * When data selection option is not specified,
     * block handler will be triggered for all chain blocks, those
     * causing the processor to fetch all of them.
     * This behaviour can be modified via {@link BlockHandlerDataRequest.includeAllBlocks | .data.includeAllBlocks} option.
     *
     * @example
     * // print heights of all chain blocks
     * processor.addPostHook(async ctx => {
     *     console.log(ctx.block.height)
     * })
     *
     * // print heights of all blocks starting from block 100000
     * processor.addPostHook({range: {from: 100000}}, async ctx => {
     *     console.log(ctx.block.height)
     * })
     *
     * // print all `Balances.Transfer` events
     * processor.addPostHook({
     *     data: {
     *         items: {
     *             events: {
     *                 'Balances.Transfer': {args: true}
     *             }
     *         }
     *     }
     * } as const, async ctx => {
     *     ctx.items.forEach(item => {
     *         if (item.name === 'Balances.Transfer') {
     *             console.log(item.event.args)
     *         }
     *     })
     * })
     *
     * // print names of all events
     * processor.addPostHook({
     *     data: {
     *        items: {
     *             events: {
     *                 '*': {}
     *             }
     *         }
     *     }
     * } as const, async ctx => {
     *     ctx.items.forEach(item => {
     *         if (item.kind == 'event) {
     *             console.log(item.event.name)
     *         }
     *     })
     * })
     */
    addPostHook(fn: BlockHandler<Store>): this;
    addPostHook(options: BlockRangeOption, fn: BlockHandler<Store>): this;
    addPostHook<R extends BlockHandlerDataRequest>(options: BlockRangeOption & DataSelection<R>, fn: BlockHandler<Store, R>): this;
    /**
     * Registers an event data handler.
     *
     * See {@link EventHandlerContext} for an API available to the handler.
     *
     * All calls are processed sequentially according to their position in unified
     * log of events and calls. All events deposited within a call are placed
     * before the call. All child calls are placed before the parent call.
     * List of block events is a subsequence of unified log.
     *
     * Relative execution order is currently not defined for multiple event handlers
     * registered for the same event.
     *
     * @example
     * processor.addEventHandler('Balances.Transfer', async ctx => {
     *     assert(ctx.event.name == 'Balances.Transfer')
     * })
     *
     * // limit the range of blocks for which event handler will be effective
     * processor.addEventHandler('Balances.Transfer', {
     *     range: {from: 100000}
     * }, async ctx => {
     *     assert(ctx.event.name == 'Balances.Transfer')
     * })
     *
     * // request only subset of event data for faster ingestion times
     * processor.addEventHandler('Balances.Transfer', {
     *     data: {
     *         event: {args: true}
     *     }
     * } as const, async ctx => {})
     */
    addEventHandler(eventName: QualifiedName, fn: EventHandler<Store>): this;
    addEventHandler(eventName: QualifiedName, options: BlockRangeOption & NoDataSelection, fn: EventHandler<Store>): this;
    addEventHandler<R extends EventDataRequest>(eventName: QualifiedName, options: BlockRangeOption & DataSelection<R>, fn: EventHandler<Store, R>): this;
    /**
     * Registers a call data handler.
     *
     * See {@link CallHandlerContext} for an API available to the handler.
     *
     * Note, that by default, only successful calls will be handled.
     * This can be overwritten via `.triggerForFailedCalls` option.
     *
     * All calls are processed sequentially according to their position in unified
     * log of events and calls. All events deposited within a call are placed
     * before the call. All child calls are placed before the parent call.
     * List of block events is a subsequence of unified log.
     *
     * Relative execution order is currently not defined for multiple call handlers
     * registered for the same call.
     *
     * @example
     * processor.addCallHandler('Balances.transfer', async ctx => {
     *     assert(ctx.event.name == 'Balances.transfer')
     * })
     *
     * // limit the range of blocks for which event handler will be effective
     * processor.addCallHandler('Balances.transfer', {
     *     range: {from: 100000}
     * }, async ctx => {
     *     assert(ctx.event.name == 'Balances.transfer')
     * })
     *
     * // request only subset of call data for faster ingestion times
     * processor.addCallHandler('Balances.transfer', {
     *     data: {
     *         call: {args: true},
     *         extrinsic: {signature: true}
     *     }
     * } as const, async ctx => {})
     */
    addCallHandler(callName: QualifiedName, fn: CallHandler<Store>): this;
    addCallHandler(callName: QualifiedName, options: CallHandlerOptions & NoDataSelection, fn: CallHandler<Store>): this;
    addCallHandler<R extends CallDataRequest>(callName: QualifiedName, options: CallHandlerOptions & DataSelection<R>, fn: CallHandler<Store, R>): this;
    /**
     * Registers `EVM.Log` event handler.
     *
     * This method is similar to {@link .addEventHandler},
     * but selects events by evm log contract address and topics.
     *
     * @example
     * // process ERC721 transfers from Moonsama contract
     * processor.addEvmLogHandler('0xb654611f84a8dc429ba3cb4fda9fad236c505a1a', {
     *     topics: ['0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef']
     * }, async ctx => {})
     *
     * // subscribe to multiple contracts at once
     * processor.addEvmLogHandler([
     *     '0xb654611f84a8dc429ba3cb4fda9fad236c505a1a',
     *     '0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98'
     * ], {
     *     topics: ['0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef']
     * }, async ctx => {})
     */
    addEvmLogHandler(contractAddress: string | string[], fn: EvmLogHandler<Store>): this;
    addEvmLogHandler(contractAddress: string | string[], options: EvmLogOptions & NoDataSelection, fn: EvmLogHandler<Store>): this;
    addEvmLogHandler<R extends EventDataRequest>(contractAddress: string | string[], options: EvmLogOptions & DataSelection<R>, fn: EvmLogHandler<Store, R>): this;
    /**
     * Registers `Ethereum.transact` call handler.
     *
     * This method is similar to {@link .addCallHandler},
     * but selects calls by contract address and sighash.
     * Only "EVM call" transactions are selected.
     *
     * Note, that there is a difference between success of substrate call
     * and successful execution of its EVM transaction.
     * {@link EthereumTransactionHandlerOptions.triggerForFailedCalls}
     * option refers to success of substrate call.
     *
     * @example
     * // process EVM calls to contract `0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98`
     * process.addEthereumTransactionHandler('0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98', async ctx => {})
     *
     * // process all EVM calls with signature `transfer(address,uint256)`
     * process.addEthereumTransactionHandler('*', {sighash: '0xa9059cbb'}, async ctx => {})
     *
     * // subscribe to multiple contracts at once
     * processor.addEthereumTransaction([
     *     '0x6a2d262D56735DbA19Dd70682B39F6bE9a931D98',
     *     '0x3795C36e7D12A8c252A20C5a7B455f7c57b60283'
     * ], {
     *     sighash: '0xa9059cbb'
     * }, async ctx => {})
     */
    addEthereumTransactionHandler(contractAddress: string | string[], fn: CallHandler<Store>): this;
    addEthereumTransactionHandler(contractAddress: string | string[], options: EthereumTransactionHandlerOptions & NoDataSelection, fn: CallHandler<Store>): this;
    addEthereumTransactionHandler<R extends CallDataRequest>(contractAddress: string | string[], options: EthereumTransactionHandlerOptions & DataSelection<R>, fn: CallHandler<Store, R>): this;
    /**
     * Registers `Contracts.ContractEmitted` event handler.
     *
     * This method is similar to {@link .addEventHandler},
     * but provides specialised {@link ContractsContractEmittedEvent | event type} and selects
     * events by contract address.
     */
    addContractsContractEmittedHandler(contractAddress: string, fn: ContractsContractEmittedHandler<Store>): this;
    addContractsContractEmittedHandler(contractAddress: string, options: BlockRangeOption & NoDataSelection, fn: ContractsContractEmittedHandler<Store>): this;
    addContractsContractEmittedHandler<R extends EventDataRequest>(contractAddress: string, options: BlockRangeOption & DataSelection<R>, fn: ContractsContractEmittedHandler<Store, R>): this;
    /**
     * Registers `Gear.MessageEnqueued` event handler.
     *
     * This method is similar to {@link .addEventHandler},
     * but provides specialised {@link GearMessageEnqueuedEvent | event type} and selects
     * events by program id.
     */
    addGearMessageEnqueuedHandler(programId: string, fn: GearMessageEnqueuedHandler<Store>): this;
    addGearMessageEnqueuedHandler(programId: string, options: BlockRangeOption & NoDataSelection, fn: GearMessageEnqueuedHandler<Store>): this;
    addGearMessageEnqueuedHandler<R extends EventDataRequest>(programId: string, options: BlockRangeOption & DataSelection<R>, fn: GearMessageEnqueuedHandler<Store, R>): this;
    /**
     * Registers `Gear.UserMessageSent` event handler.
     *
     * This method is similar to {@link .addEventHandler},
     * but provides specialised {@link GearUserMessageSentEvent | event type} and selects
     * events by program id.
     */
    addGearUserMessageSentHandler(programId: string, fn: GearUserMessageSentHandler<Store>): this;
    addGearUserMessageSentHandler(programId: string, options: BlockRangeOption & NoDataSelection, fn: GearUserMessageSentHandler<Store>): this;
    addGearUserMessageSentHandler<R extends EventDataRequest>(programId: string, options: BlockRangeOption & DataSelection<R>, fn: GearUserMessageSentHandler<Store, R>): this;
    protected assertNotRunning(): void;
    private createBatches;
    private getLogger;
    private getOptions;
    private getDatabase;
    private getTypes;
    private getArchiveEndpoint;
    private getChainEndpoint;
    /**
     * Starts data processing.
     *
     * This method assumes full control over the current OS process as
     * it terminates the entire program in case of error or
     * at the end of data processing.
     */
    run(): void;
}
//# sourceMappingURL=handlerProcessor.d.ts.map