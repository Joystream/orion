import type { Batch } from './batch/generic';
import { BatchRequest } from './batch/request';
import { SubstrateBlock, SubstrateCall, SubstrateEvent, SubstrateExtrinsic } from './interfaces/substrate';
export declare type Item = {
    kind: 'call';
    name: string;
    call: SubstrateCall;
    extrinsic: SubstrateExtrinsic;
} | {
    kind: 'event';
    name: string;
    event: SubstrateEvent;
};
export interface BlockData {
    header: SubstrateBlock;
    items: Item[];
}
export interface DataBatch<R> {
    /**
     * This is roughly the range of scanned blocks
     */
    range: {
        from: number;
        to: number;
    };
    request: R;
    blocks: BlockData[];
    fetchStartTime: bigint;
    fetchEndTime: bigint;
    isHead: boolean;
}
export interface IngestOptions<R> {
    archiveRequest<T>(query: string): Promise<T>;
    archivePollIntervalMS?: number;
    batches: Batch<R>[];
}
export declare class Ingest<R extends BatchRequest> {
    private options;
    private archiveHeight;
    private readonly batches;
    private readonly maxQueueSize;
    private queue;
    private fetchLoopIsStopped;
    constructor(options: IngestOptions<R>);
    getBlocks(): AsyncGenerator<DataBatch<R>>;
    private fetchLoop;
    private buildBatchQuery;
    private printBlockHeaderGql;
    private fetchBlockHeader;
    private waitForHeight;
    fetchArchiveHeight(): Promise<number>;
    private setArchiveHeight;
    getLatestKnownArchiveHeight(): number;
}
//# sourceMappingURL=ingest.d.ts.map