"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chain = exports.ChainManager = void 0;
const scale_codec_1 = require("@subsquid/scale-codec");
const substrate_metadata_1 = require("@subsquid/substrate-metadata");
const eac = __importStar(require("@subsquid/substrate-metadata/lib/events-and-calls"));
const storage_1 = require("@subsquid/substrate-metadata/lib/storage");
const util_internal_1 = require("@subsquid/util-internal");
const assert_1 = __importDefault(require("assert"));
const sto = __importStar(require("./util/storage"));
class ChainManager {
    constructor(options) {
        this.options = options;
        this.versions = new Map();
    }
    async getChainForBlock(block) {
        let v = this.versions.get(block.specId);
        if (v != null && v.height < block.height)
            return v.chain;
        let height = Math.max(0, block.height - 1);
        let specId = await this.getSpecId(height);
        v = this.versions.get(specId);
        if (v == null) {
            let meta = await this.getSpecMetadata(specId);
            v = this.versions.get(specId); // perhaps it was fetched
            if (v == null) {
                let chain = this.createChain(meta);
                v = { chain, height: meta.blockHeight };
                this.versions.set(specId, v);
            }
        }
        return v.chain;
    }
    createChain(meta) {
        let metadata = (0, substrate_metadata_1.decodeMetadata)(meta.hex);
        let types;
        if ((0, substrate_metadata_1.isPreV14)(metadata)) {
            types = this.options.getTypes(meta);
        }
        let description = (0, substrate_metadata_1.getChainDescriptionFromMetadata)(metadata, types);
        return new Chain(description, () => this.options.getChainClient());
    }
    async getSpecId(height) {
        let res = await this.options.archiveRequest(`
            query {
                batch(fromBlock: ${height} toBlock: ${height} includeAllBlocks: true limit: 1) {
                    header {
                        specId
                    }
                }
            }
        `);
        if (res.batch.length == 0)
            throw new Error(`Block ${height} not found in archive`);
        (0, assert_1.default)(res.batch.length === 1);
        return res.batch[0].header.specId;
    }
    getSpecMetadata(specId) {
        return this.options.archiveRequest(`
            query {
                metadataById(id: "${specId}") {
                    id
                    specName
                    specVersion
                    blockHeight
                    hex
                }
            }
        `).then(res => {
            if (res.metadataById == null) {
                throw new Error(`Metadata for spec ${specId} not found in archive`);
            }
            else {
                return res.metadataById;
            }
        });
    }
}
exports.ChainManager = ChainManager;
class Chain {
    constructor(description, getClient) {
        this.description = description;
        this.getClient = getClient;
        this.storageHashCache = new Map();
        this.constantValueCache = new Map();
        this.jsonCodec = new scale_codec_1.JsonCodec(description.types);
        this.scaleCodec = new scale_codec_1.Codec(description.types);
        this.events = new eac.Registry(description.types, description.event);
        this.calls = new eac.Registry(description.types, description.call);
    }
    get client() {
        return this.getClient();
    }
    getEventHash(eventName) {
        return this.events.getHash(eventName);
    }
    getCallHash(callName) {
        return this.calls.getHash(callName);
    }
    decodeEvent(event) {
        let def = this.events.get(event.name);
        return this.decode(def, event.args);
    }
    decodeCall(call) {
        let def = this.calls.get(call.name);
        return this.decode(def, call.args);
    }
    decode(def, args) {
        if (def.fields.length == 0)
            return undefined;
        if (def.fields[0].name == null)
            return this.decodeTuple(def.fields, args);
        (0, assert_1.default)(args != null && typeof args == 'object', 'invalid args');
        let result = {};
        for (let i = 0; i < def.fields.length; i++) {
            let f = def.fields[i];
            let name = (0, util_internal_1.assertNotNull)(f.name);
            result[name] = this.jsonCodec.decode(f.type, args[name]);
        }
        return result;
    }
    decodeTuple(fields, args) {
        if (fields.length == 1) {
            return this.jsonCodec.decode(fields[0].type, args);
        }
        else {
            (0, assert_1.default)(Array.isArray(args) && fields.length == args.length, 'invalid args');
            let result = new Array(fields.length);
            for (let i = 0; i < fields.length; i++) {
                result[i] = this.jsonCodec.decode(fields[i].type, args[i]);
            }
            return result;
        }
    }
    async getStorage(blockHash, prefix, name, ...keys) {
        let item = this.getStorageItem(prefix, name);
        (0, assert_1.default)(item.keys.length === keys.length);
        let req = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2) + this.getStorageItemKeysHash(item, keys);
        let res = await this.client.call('state_getStorageAt', [req, blockHash]);
        return this.decodeStorageValue(item, res);
    }
    async queryStorage(blockHash, prefix, name, keyList) {
        let item = this.getStorageItem(prefix, name);
        let storageHash = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2);
        let query;
        if (keyList == null) {
            query = await this.client.call('state_getKeys', [storageHash, blockHash]);
        }
        else {
            query = keyList.map(keys => {
                return storageHash + this.getStorageItemKeysHash(item, keys);
            });
        }
        return this.fetchValues(blockHash, item, query);
    }
    async queryStorage2(blockHash, prefix, name, keys) {
        let item = this.getStorageItem(prefix, name);
        let storageHash = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2);
        let query;
        if (keys == null) {
            query = await this.client.call('state_getKeys', [storageHash, blockHash]);
        }
        else {
            query = keys.map(arg => {
                return storageHash + this.getStorageItemKeysHash(item, item.keys.length > 1 ? arg : [arg]);
            });
        }
        return this.fetchValues(blockHash, item, query);
    }
    async fetchValues(blockHash, item, rawKeys) {
        if (rawKeys.length == 0)
            return [];
        let res = await this.client.call('state_queryStorageAt', [rawKeys, blockHash]);
        (0, assert_1.default)(res.length == 1);
        // Response from chain node can't contain key duplicates,
        // but our query list can, hence the following
        // value matching procedure
        let changes = new Map(res[0].changes);
        return rawKeys.map(k => {
            let v = changes.get(k);
            return this.decodeStorageValue(item, v);
        });
    }
    async getKeys(blockHash, prefix, name, ...args) {
        let item = this.getStorageItem(prefix, name);
        let storageHash = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2) + this.getStorageItemKeysHash(item, args);
        let res = await this.client.call('state_getKeys', [storageHash, blockHash]);
        return res.map(k => this.decodeStorageKey(item, k));
    }
    async getRawKeys(blockHash, prefix, name, ...args) {
        let item = this.getStorageItem(prefix, name);
        let storageHash = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2) + this.getStorageItemKeysHash(item, args);
        return await this.client.call('state_getKeys', [storageHash, blockHash]);
    }
    async *getKeysPaged(pageSize, blockHash, prefix, name, ...args) {
        (0, assert_1.default)(pageSize > 0);
        let item = this.getStorageItem(prefix, name);
        let storageHash = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2) + this.getStorageItemKeysHash(item, args);
        let lastKey = null;
        while (true) {
            let res = await this.client.call('state_getKeysPaged', [storageHash, pageSize, lastKey, blockHash]);
            if (res.length == 0)
                return;
            yield res.map(k => this.decodeStorageKey(item, k));
            if (res.length == pageSize) {
                lastKey = (0, util_internal_1.last)(res);
            }
            else {
                return;
            }
        }
    }
    async getPairs(blockHash, prefix, name, ...args) {
        let item = this.getStorageItem(prefix, name);
        let storageHash = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2) + this.getStorageItemKeysHash(item, args);
        let query = await this.client.call('state_getKeys', [storageHash, blockHash]);
        if (query.length == 0)
            return [];
        let res = await this.client.call('state_queryStorageAt', [query, blockHash]);
        (0, assert_1.default)(res.length == 1);
        return res[0].changes.map(v => this.decodeStoragePair(item, v));
    }
    async *getPairsPaged(pageSize, blockHash, prefix, name, ...args) {
        (0, assert_1.default)(pageSize > 0);
        let item = this.getStorageItem(prefix, name);
        let storageHash = sto.getNameHash(prefix) + sto.getNameHash(name).slice(2) + this.getStorageItemKeysHash(item, args);
        let lastKey = null;
        while (true) {
            let query = await this.client.call('state_getKeysPaged', [storageHash, pageSize, lastKey, blockHash]);
            if (query.length == 0)
                return;
            let res = await this.client.call('state_queryStorageAt', [query, blockHash]);
            (0, assert_1.default)(res.length == 1);
            yield res[0].changes.map(v => this.decodeStoragePair(item, v));
            if (query.length == pageSize) {
                lastKey = (0, util_internal_1.last)(query);
            }
            else {
                return;
            }
        }
    }
    decodeStoragePair(item, pair) {
        let decodedKey = this.decodeStorageKey(item, pair[0]);
        let decodedValue = this.decodeStorageValue(item, pair[1]);
        return [decodedKey, decodedValue];
    }
    decodeStorageValue(item, value) {
        if (value == null) {
            switch (item.modifier) {
                case 'Optional':
                    return undefined;
                case 'Default':
                    value = item.fallback;
                    break;
                case 'Required':
                    throw new Error(`Required storage item not found`);
                default:
                    throw (0, util_internal_1.unexpectedCase)(item.modifier);
            }
        }
        return this.scaleCodec.decodeBinary(item.value, value);
    }
    decodeStorageKey(item, key) {
        let res = [];
        let src = new scale_codec_1.Src(key);
        src.skip(32);
        for (let i = 0; i < item.keys.length; i++) {
            switch (item.hashers[i]) {
                case 'Identity':
                    break;
                case 'Blake2_128Concat':
                    src.skip(16);
                    break;
                case 'Twox64Concat':
                    src.skip(8);
                    break;
                case 'Blake2_128':
                case 'Twox128':
                case 'Blake2_256':
                case 'Twox256':
                    throw new Error(`Original value of storage item key can't be restored from ${item.hashers[i]} encoding`);
                default:
                    throw (0, util_internal_1.unexpectedCase)(item.hashers[i]);
            }
            res.push(this.scaleCodec.decode(item.keys[i], src));
        }
        src.assertEOF();
        return res.length > 1 ? res : res[0];
    }
    getStorageItemKeysHash(item, keys) {
        (0, assert_1.default)(keys.length <= item.hashers.length);
        let hash = '';
        for (let i = 0; i < keys.length; i++) {
            hash += sto.getKeyHash(item.hashers[i], this.scaleCodec.encodeToBinary(item.keys[i], keys[i])).slice(2);
        }
        return hash;
    }
    getStorageItem(prefix, name) {
        let items = this.description.storage[prefix];
        if (items == null)
            throw new Error(`There are no storage items under prefix ${prefix}`);
        let def = items[name];
        if (def == null)
            throw new Error(`Unknown storage item: ${prefix}.${name}`);
        return def;
    }
    getStorageItemTypeHash(prefix, name) {
        let item = this.description.storage[prefix]?.[name];
        if (item == null)
            return undefined;
        let hash = this.storageHashCache.get(item);
        if (hash == null) {
            hash = (0, storage_1.getStorageItemTypeHash)(this.description.types, item);
            this.storageHashCache.set(item, hash);
        }
        return hash;
    }
    getConstant(pallet, name) {
        let palletConstants = this.description.constants[pallet];
        if (palletConstants == null)
            throw new Error(`There are no constants in ${pallet} pallet`);
        let def = palletConstants[name];
        if (def == null)
            throw new Error(`Unknown constant: ${pallet}.${name}`);
        let value = this.constantValueCache.get(def);
        if (value === undefined) {
            value = this.scaleCodec.decodeBinary(def.type, def.value);
            this.constantValueCache.set(def, value);
        }
        return value;
    }
    getConstantTypeHash(pallet, name) {
        let def = this.description.constants[pallet]?.[name];
        if (def == null)
            return undefined;
        return (0, substrate_metadata_1.getTypeHash)(this.description.types, def.type);
    }
}
exports.Chain = Chain;
//# sourceMappingURL=chain.js.map