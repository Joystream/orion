"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ingest = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_code_printer_1 = require("@subsquid/util-internal-code-printer");
const assert_1 = __importDefault(require("assert"));
const gql_1 = require("./util/gql");
const misc_1 = require("./util/misc");
const range_1 = require("./util/range");
class Ingest {
    constructor(options) {
        this.options = options;
        this.archiveHeight = -1;
        this.maxQueueSize = 3;
        this.queue = [];
        this.fetchLoopIsStopped = true;
        this.batches = options.batches.slice();
    }
    async *getBlocks() {
        while (this.batches.length) {
            if (this.fetchLoopIsStopped) {
                this.fetchLoop().catch();
            }
            yield await (0, util_internal_1.assertNotNull)(this.queue[0]);
            this.queue.shift();
        }
    }
    async fetchLoop() {
        (0, assert_1.default)(this.fetchLoopIsStopped);
        this.fetchLoopIsStopped = false;
        while (this.batches.length && this.queue.length < this.maxQueueSize) {
            let batch = this.batches[0];
            let ctx = {
                batchRange: batch.range
            };
            let promise = this.waitForHeight(batch.range.from)
                .then(async (archiveHeight) => {
                ctx.archiveHeight = archiveHeight;
                ctx.archiveQuery = this.buildBatchQuery(batch, archiveHeight);
                let fetchStartTime = process.hrtime.bigint();
                let response = await this.options.archiveRequest(ctx.archiveQuery);
                let fetchEndTime = process.hrtime.bigint();
                (0, assert_1.default)(response.status.head >= archiveHeight);
                this.setArchiveHeight(response);
                let blocks = response.batch.data.map(mapGatewayBlock).sort((a, b) => a.header.height - b.header.height);
                if (blocks.length) {
                    (0, assert_1.default)(batch.range.from <= blocks[0].header.height);
                    (0, assert_1.default)((0, range_1.rangeEnd)(batch.range) >= (0, util_internal_1.last)(blocks).header.height);
                    (0, assert_1.default)(archiveHeight >= (0, util_internal_1.last)(blocks).header.height);
                }
                ctx.batchBlocksFetched = blocks.length;
                let from = batch.range.from;
                let to = response.batch.nextBlock - 1;
                if (to < (0, range_1.rangeEnd)(batch.range)) {
                    this.batches[0] = {
                        range: { from: to + 1, to: batch.range.to },
                        request: batch.request
                    };
                }
                else {
                    (0, assert_1.default)(to === (0, range_1.rangeEnd)(batch.range));
                    this.batches.shift();
                }
                // When we are on the head, always include the head block,
                // even if it doesn't contain requested data.
                let isHead = to == response.status.head;
                if (isHead && !blocks.find(b => b.header.height === response.status.head)) {
                    blocks.push(mapGatewayBlock(await this.fetchBlockHeader(to)));
                }
                return {
                    blocks,
                    range: { from, to },
                    request: batch.request,
                    fetchStartTime,
                    fetchEndTime,
                    isHead
                };
            }).catch((0, misc_1.withErrorContext)(ctx));
            this.queue.push(promise);
            let result = await promise.catch(util_internal_1.ensureError);
            if (result instanceof Error) {
                return;
            }
        }
        this.fetchLoopIsStopped = true;
    }
    buildBatchQuery(batch, archiveHeight) {
        let from = batch.range.from;
        let to = Math.min(archiveHeight, (0, range_1.rangeEnd)(batch.range));
        (0, assert_1.default)(from <= to);
        let req = batch.request;
        let args = {
            fromBlock: from,
            toBlock: to,
            includeAllBlocks: req.getIncludeAllBlocks()
        };
        args.events = req.getEvents().map(({ name, data }) => {
            return {
                name,
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.calls = req.getCalls().map(({ name, data }) => {
            return {
                name,
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.evmLogs = req.getEvmLogs().map(({ contract, filter, data }) => {
            return {
                contract,
                filter: filter?.map(ensureArray),
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.ethereumTransactions = req.getEthereumTransactions().map(({ contract, sighash, data }) => {
            return {
                contract,
                sighash,
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.contractsEvents = req.getContractsEvents().map(({ contract, data }) => {
            return {
                contract,
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.gearMessagesEnqueued = req.getGearMessagesEnqueued().map(({ program, data }) => {
            return {
                program,
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.gearUserMessagesSent = req.getGearUserMessagesSent().map(({ program, data }) => {
            return {
                program,
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.acalaEvmExecuted = req.getAcalaEvmExecuted().map(({ contract, logs, data }) => {
            return {
                contract,
                logs: logs?.map(log => ({
                    ...log,
                    filter: log.filter?.map(ensureArray)
                })),
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        args.acalaEvmExecutedFailed = req.getAcalaEvmExecutedFailed().map(({ contract, logs, data }) => {
            return {
                contract,
                logs: logs?.map(log => ({
                    ...log,
                    filter: log.filter?.map(ensureArray)
                })),
                data: toGatewayFields(data, CONTEXT_NESTING_SHAPE)
            };
        });
        let q = new util_internal_code_printer_1.Output();
        q.block(`query`, () => {
            q.block(`status`, () => {
                q.line('head');
            });
            q.block(`batch(${(0, gql_1.printGqlArguments)(args)})`, () => {
                this.printBlockHeaderGql(q);
                q.line('events');
                q.line('calls');
                q.line('extrinsics');
            });
        });
        return q.toString();
    }
    printBlockHeaderGql(q) {
        q.block('header', () => {
            q.line('id');
            q.line('height');
            q.line('hash');
            q.line('parentHash');
            q.line('timestamp');
            q.line('specId');
            q.line('stateRoot');
            q.line('extrinsicsRoot');
            q.line('validator');
        });
    }
    async fetchBlockHeader(height) {
        let q = new util_internal_code_printer_1.Output();
        let args = {
            fromBlock: height,
            toBlock: height,
            includeAllBlocks: true
        };
        q.block(`query`, () => {
            q.block(`batch(${(0, gql_1.printGqlArguments)(args)})`, () => {
                this.printBlockHeaderGql(q);
            });
        });
        let response = await this.options.archiveRequest(q.toString());
        (0, assert_1.default)(response.batch.data.length == 1);
        return response.batch.data[0];
    }
    async waitForHeight(minimumHeight) {
        while (this.archiveHeight < minimumHeight) {
            await this.fetchArchiveHeight();
            if (this.archiveHeight >= minimumHeight) {
                return this.archiveHeight;
            }
            else {
                await (0, util_internal_1.wait)(this.options.archivePollIntervalMS || 5000);
            }
        }
        return this.archiveHeight;
    }
    async fetchArchiveHeight() {
        let res = await this.options.archiveRequest('query { status { head } }');
        this.setArchiveHeight(res);
        return this.archiveHeight;
    }
    setArchiveHeight(res) {
        let height = res.status.head;
        if (height == 0) {
            height = -1;
        }
        this.archiveHeight = Math.max(this.archiveHeight, height);
    }
    getLatestKnownArchiveHeight() {
        return this.archiveHeight;
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Object)
], Ingest.prototype, "getBlocks", null);
exports.Ingest = Ingest;
const CONTEXT_NESTING_SHAPE = (() => {
    let call = {
        parent: {}
    };
    let extrinsic = {
        call
    };
    return {
        event: {
            call,
            extrinsic
        },
        call,
        extrinsic
    };
})();
function toGatewayFields(req, shape) {
    if (!req)
        return undefined;
    if (req === true)
        return shape ? { _all: true } : true;
    let fields = {};
    for (let key in req) {
        let val = toGatewayFields(req[key], shape?.[key]);
        if (val != null) {
            fields[key] = val;
        }
    }
    return fields;
}
function mapGatewayBlock(block) {
    try {
        return tryMapGatewayBlock(block);
    }
    catch (e) {
        throw (0, misc_1.addErrorContext)(e, {
            blockHeight: block.header.height,
            blockHash: block.header.hash
        });
    }
}
function tryMapGatewayBlock(block) {
    block.calls = block.calls || [];
    block.events = block.events || [];
    block.extrinsics = block.extrinsics || [];
    let events = createObjects(block.events, go => {
        let { callId, extrinsicId, ...event } = go;
        return event;
    });
    let calls = createObjects(block.calls, go => {
        let { parentId, extrinsicId, ...call } = go;
        return call;
    });
    let extrinsics = createObjects(block.extrinsics || [], go => {
        let { callId, fee, tip, ...rest } = go;
        let extrinsic = rest;
        if (fee != null) {
            extrinsic.fee = BigInt(fee);
        }
        if (tip != null) {
            extrinsic.tip = BigInt(tip);
        }
        return extrinsic;
    });
    let items = [];
    for (let go of block.events) {
        let event = (0, util_internal_1.assertNotNull)(events.get(go.id));
        if (go.extrinsicId) {
            event.extrinsic = (0, util_internal_1.assertNotNull)(extrinsics.get(go.extrinsicId));
        }
        if (go.callId) {
            event.call = (0, util_internal_1.assertNotNull)(calls.get(go.callId));
        }
        items.push({
            kind: 'event',
            name: event.name,
            event
        });
    }
    for (let go of block.calls) {
        let call = (0, util_internal_1.assertNotNull)(calls.get(go.id));
        if (go.parentId) {
            call.parent = (0, util_internal_1.assertNotNull)(calls.get(go.parentId));
        }
        let item = {
            kind: 'call',
            name: call.name,
            call
        };
        if (go.extrinsicId) {
            item.extrinsic = (0, util_internal_1.assertNotNull)(extrinsics.get(go.extrinsicId));
        }
        items.push(item);
    }
    for (let go of block.extrinsics) {
        if (go.callId) {
            let extrinsic = (0, util_internal_1.assertNotNull)(extrinsics.get(go.id));
            extrinsic.call = (0, util_internal_1.assertNotNull)(calls.get(go.id));
        }
    }
    items.sort((a, b) => getPos(a) - getPos(b));
    let { timestamp, validator, ...hdr } = block.header;
    return {
        header: { ...hdr, timestamp: new Date(timestamp).valueOf(), validator: validator ?? undefined },
        items
    };
}
function createObjects(src, f) {
    let m = new Map();
    for (let i = 0; i < src.length; i++) {
        let obj = f(src[i]);
        m.set(obj.id, obj);
    }
    return m;
}
function getPos(item) {
    switch (item.kind) {
        case 'call':
            return item.call.pos;
        case 'event':
            return item.event.pos;
        default:
            throw (0, util_internal_1.unexpectedCase)();
    }
}
function ensureArray(val) {
    if (Array.isArray(val))
        return val;
    if (val == null)
        return [];
    return [val];
}
//# sourceMappingURL=ingest.js.map