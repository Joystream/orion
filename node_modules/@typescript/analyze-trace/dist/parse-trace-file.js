"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const fs = require("fs");
const Parser = require("jsonparse");
const packageNameRegex = /\/node_modules\/((?:[^@][^/]+)|(?:@[^/]+\/[^/]+))/g;
function parse(tracePath, minDuration) {
    return new Promise(resolve => {
        const p = new Parser();
        let minTime = Infinity;
        let maxTime = 0;
        const unclosedStack = []; // Sorted in increasing order of start time (even when below timestamp resolution)
        const spans = []; // Sorted in increasing order of end time, then increasing order of start time (even when below timestamp resolution)
        const nodeModulePaths = new Map();
        p.onValue = function (value) {
            var _a;
            if (this.stack.length !== 1)
                return;
            if (this.mode !== Parser.C.ARRAY)
                throw new Error(`Unexpected mode ${this.mode}`);
            this.value = [];
            // Metadata objects are uninteresting
            if (value.ph === "M")
                return;
            // TODO (https://github.com/microsoft/typescript-analyze-trace/issues/1)
            if (value.ph === "i" || value.ph === "I")
                return;
            const event = value;
            if (event.ph === "B") {
                unclosedStack.push(event);
                return;
            }
            let span;
            if (event.ph === "E") {
                const beginEvent = unclosedStack.pop();
                span = { event: beginEvent, start: +beginEvent.ts, end: +event.ts, children: [] };
            }
            else if (event.ph === "X") {
                const start = +event.ts;
                const duration = +event.dur;
                span = { event, start, end: start + duration, children: [] };
            }
            else {
                throw new Error(`Unknown event phase ${event.ph}`);
            }
            minTime = Math.min(minTime, span.start);
            maxTime = Math.max(maxTime, span.end);
            // Note that we need to do this before events are being dropped based on `minDuration`
            if (span.event.name === "findSourceFile") {
                const path = (_a = span.event.args) === null || _a === void 0 ? void 0 : _a.fileName;
                if (path) {
                    while (true) {
                        const m = packageNameRegex.exec(path);
                        if (!m)
                            break;
                        const packageName = m[1];
                        const packagePath = m.input.substring(0, m.index + m[0].length);
                        if (nodeModulePaths.has(packageName)) {
                            const paths = nodeModulePaths.get(packageName);
                            if (paths.indexOf(packagePath) < 0) { // Usually contains exactly one element
                                paths.push(packagePath);
                            }
                        }
                        else {
                            nodeModulePaths.set(packageName, [packagePath]);
                        }
                    }
                }
            }
            if ((span.end - span.start) >= minDuration) {
                spans.push(span);
            }
        };
        const readStream = fs.createReadStream(tracePath);
        readStream.on("data", chunk => p.write(chunk));
        readStream.on("end", () => {
            resolve({
                minTime,
                maxTime,
                spans,
                unclosedStack,
                nodeModulePaths,
            });
        });
    });
}
exports.parse = parse;
//# sourceMappingURL=parse-trace-file.js.map