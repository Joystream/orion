"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = void 0;
const code_CarriageReturn = "\r".charCodeAt(0);
const code_NewLine = "\n".charCodeAt(0);
const code_Space = " ".charCodeAt(0);
const code_Tab = "\t".charCodeAt(0);
const code_Slash = "/".charCodeAt(0);
const code_Backslash = "\\".charCodeAt(0);
const code_Star = "*".charCodeAt(0);
const code_Hash = "#".charCodeAt(0);
const code_Bang = "!".charCodeAt(0);
const code_SingleQuote = "'".charCodeAt(0);
const code_DoubleQuote = "\"".charCodeAt(0);
const code_OpenBrace = "{".charCodeAt(0);
const code_CloseBrace = "}".charCodeAt(0);
const code_OpenBracket = "[".charCodeAt(0);
const code_CloseBracket = "]".charCodeAt(0);
const code_Backtick = "`".charCodeAt(0);
const code_Dollar = "$".charCodeAt(0);
function create() {
    let state = 1 /* Default */;
    let braceDepth = 0;
    let templateStringBraceDepthStack = [];
    let isBOF = true;
    function step(ch, nextCh) {
        let nextStateId = 0 /* Uninitialized */;
        ;
        let wrapLine = false;
        switch (ch) {
            case code_CarriageReturn:
                if (nextCh === code_NewLine) {
                    if (state === 8 /* ShebangComment */ ||
                        state === 3 /* SingleLineComment */ ||
                        // Cases below are for error recovery
                        state === 9 /* SingleQuoteString */ ||
                        state === 12 /* DoubleQuoteString */ ||
                        state === 19 /* Regex */ ||
                        state === 23 /* CharClass */) {
                        state = 1 /* Default */;
                    }
                    break;
                }
            // Fall through
            case code_NewLine:
                wrapLine = true;
                if (state === 8 /* ShebangComment */ ||
                    state === 3 /* SingleLineComment */) {
                    state = 1 /* Default */;
                }
                else if (state === 9 /* SingleQuoteString */ || // Error recovery
                    state === 12 /* DoubleQuoteString */) { // Error recovery
                    state = 1 /* Default */;
                }
                break;
            case code_Slash:
                if (state === 1 /* Default */) {
                    if (nextCh === code_Slash) {
                        state = 2 /* StartSingleLineComment */;
                    }
                    else if (nextCh === code_Star) {
                        // It seems like there might technically be a corner case where this is the beginning of an invalid regex
                        state = 4 /* StartMultiLineComment */;
                    }
                    else {
                        // TODO (https://github.com/microsoft/typescript-analyze-trace/issues/14): this is too aggressive - it will catch division
                        state = 19 /* Regex */;
                    }
                }
                else if (state === 2 /* StartSingleLineComment */) {
                    state = 3 /* SingleLineComment */;
                }
                else if (state === 6 /* EndMultiLineComment */) {
                    nextStateId = 1 /* Default */;
                }
                else if (state === 19 /* Regex */) {
                    nextStateId = 1 /* Default */;
                }
                else if (state === 21 /* RegexEscapeSlash */) {
                    nextStateId = 19 /* Regex */;
                }
                break;
            case code_Star:
                if (state === 4 /* StartMultiLineComment */) {
                    state = 5 /* MultiLineComment */;
                }
                else if (state === 5 /* MultiLineComment */) {
                    if (nextCh === code_Slash) {
                        state = 6 /* EndMultiLineComment */;
                    }
                }
                break;
            case code_Hash:
                if (isBOF && state === 1 /* Default */ && nextCh === code_Bang) {
                    state = 7 /* StartShebangComment */;
                }
                break;
            case code_Bang:
                if (state === 7 /* StartShebangComment */) {
                    state = 8 /* ShebangComment */;
                }
                break;
            case code_SingleQuote:
                if (state === 1 /* Default */) {
                    state = 9 /* SingleQuoteString */;
                }
                else if (state === 11 /* SingleQuoteStringEscapeQuote */) {
                    nextStateId = 9 /* SingleQuoteString */;
                }
                else if (state === 9 /* SingleQuoteString */) {
                    nextStateId = 1 /* Default */;
                }
                break;
            case code_DoubleQuote:
                if (state === 1 /* Default */) {
                    state = 12 /* DoubleQuoteString */;
                }
                else if (state === 14 /* DoubleQuoteStringEscapeQuote */) {
                    nextStateId = 12 /* DoubleQuoteString */;
                }
                else if (state === 12 /* DoubleQuoteString */) {
                    nextStateId = 1 /* Default */;
                }
                break;
            case code_Backtick:
                if (state === 1 /* Default */) {
                    state = 15 /* TemplateString */;
                }
                else if (state === 17 /* TemplateStringEscapeQuote */) {
                    nextStateId = 15 /* TemplateString */;
                }
                else if (state === 15 /* TemplateString */) {
                    nextStateId = 1 /* Default */;
                }
                break;
            case code_Backslash:
                if (state === 9 /* SingleQuoteString */) {
                    if (nextCh === code_SingleQuote) {
                        state = 11 /* SingleQuoteStringEscapeQuote */;
                    }
                    else if (nextCh === code_Backslash) {
                        state = 10 /* SingleQuoteStringEscapeBackslash */;
                    }
                }
                else if (state === 12 /* DoubleQuoteString */) {
                    if (nextCh === code_DoubleQuote) {
                        state = 14 /* DoubleQuoteStringEscapeQuote */;
                    }
                    else if (nextCh === code_Backslash) {
                        state = 13 /* DoubleQuoteStringEscapeBackslash */;
                    }
                }
                else if (state === 15 /* TemplateString */) {
                    if (nextCh === code_Backtick) {
                        state = 17 /* TemplateStringEscapeQuote */;
                    }
                    else if (nextCh === code_Backslash) {
                        state = 16 /* TemplateStringEscapeBackslash */;
                    }
                }
                else if (state === 19 /* Regex */) {
                    if (nextCh === code_OpenBracket) {
                        state = 22 /* RegexEscapeOpenBracket */;
                    }
                    else if (nextCh === code_Slash) {
                        state = 21 /* RegexEscapeSlash */;
                    }
                    else if (nextCh === code_Backslash) {
                        state = 20 /* RegexEscapeBackslash */;
                    }
                }
                else if (state === 23 /* CharClass */) {
                    if (nextCh === code_CloseBracket) {
                        state = 25 /* CharClassEscapeCloseBracket */;
                    }
                    else if (nextCh === code_Backslash) {
                        state = 24 /* CharClassEscapeBackslash */;
                    }
                }
                else if (state === 10 /* SingleQuoteStringEscapeBackslash */) {
                    nextStateId = 9 /* SingleQuoteString */;
                }
                else if (state === 13 /* DoubleQuoteStringEscapeBackslash */) {
                    nextStateId = 12 /* DoubleQuoteString */;
                }
                else if (state === 16 /* TemplateStringEscapeBackslash */) {
                    nextStateId = 15 /* TemplateString */;
                }
                else if (state === 20 /* RegexEscapeBackslash */) {
                    nextStateId = 19 /* Regex */;
                }
                else if (state === 24 /* CharClassEscapeBackslash */) {
                    nextStateId = 23 /* CharClass */;
                }
                break;
            case code_Dollar:
                if (state === 15 /* TemplateString */ && nextCh === code_OpenBrace) {
                    state = 18 /* StartExpressionHole */;
                }
                break;
            case code_OpenBrace:
                if (state === 1 /* Default */) {
                    braceDepth++;
                }
                else if (state === 18 /* StartExpressionHole */) {
                    templateStringBraceDepthStack.push(braceDepth);
                    nextStateId = 1 /* Default */;
                }
                break;
            case code_CloseBrace:
                if (templateStringBraceDepthStack.length && braceDepth === templateStringBraceDepthStack[templateStringBraceDepthStack.length - 1]) {
                    templateStringBraceDepthStack.pop();
                    state = 15 /* TemplateString */;
                }
                else if (state === 1 /* Default */ && braceDepth > 0) { // Error recovery
                    braceDepth--;
                }
                break;
            case code_OpenBracket:
                if (state === 22 /* RegexEscapeOpenBracket */) {
                    nextStateId = 19 /* Regex */;
                }
                else if (state === 19 /* Regex */) {
                    state = 23 /* CharClass */;
                }
                break;
            case code_CloseBracket:
                if (state === 25 /* CharClassEscapeCloseBracket */) {
                    nextStateId = 23 /* CharClass */;
                }
                else if (state === 23 /* CharClass */) {
                    nextStateId = 19 /* Regex */;
                }
                break;
        }
        let charKind;
        switch (state) {
            case 2 /* StartSingleLineComment */:
            case 3 /* SingleLineComment */:
            case 4 /* StartMultiLineComment */:
            case 5 /* MultiLineComment */:
            case 6 /* EndMultiLineComment */:
            case 7 /* StartShebangComment */:
            case 8 /* ShebangComment */:
                charKind = "comment";
                break;
            case 9 /* SingleQuoteString */:
            case 10 /* SingleQuoteStringEscapeBackslash */:
            case 11 /* SingleQuoteStringEscapeQuote */:
            case 12 /* DoubleQuoteString */:
            case 13 /* DoubleQuoteStringEscapeBackslash */:
            case 14 /* DoubleQuoteStringEscapeQuote */:
            case 15 /* TemplateString */:
            case 16 /* TemplateStringEscapeBackslash */:
            case 17 /* TemplateStringEscapeQuote */:
            case 18 /* StartExpressionHole */:
                charKind = "string";
                break;
            case 19 /* Regex */:
            case 20 /* RegexEscapeBackslash */:
            case 21 /* RegexEscapeSlash */:
            case 22 /* RegexEscapeOpenBracket */:
            case 23 /* CharClass */:
            case 24 /* CharClassEscapeBackslash */:
            case 25 /* CharClassEscapeCloseBracket */:
                charKind = "regex";
                break;
            default:
                const isWhitespace = ch === code_Space ||
                    ch === code_Tab ||
                    ch === code_NewLine ||
                    ch === code_CarriageReturn ||
                    /^\s$/.test(String.fromCharCode(ch));
                charKind = isWhitespace ? "whitespace" : "code";
                break;
        }
        if (nextStateId !== 0 /* Uninitialized */) {
            state = nextStateId;
        }
        isBOF = false;
        return { charKind, wrapLine };
    }
    return { step };
}
exports.create = create;
//# sourceMappingURL=trivia-state-machine.js.map