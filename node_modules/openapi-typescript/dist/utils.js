import c from "ansi-colors";
import { isAbsolute } from "node:path";
import supportsColor from "supports-color";
import { fetch as unidiciFetch } from "undici";
if (!supportsColor.stdout || supportsColor.stdout.hasBasic === false)
    c.enabled = false;
export { c };
const COMMENT_RE = /\*\//g;
export const LB_RE = /\r?\n/g;
export const DOUBLE_QUOTE_RE = /"/g;
const ESC_0_RE = /~0/g;
const ESC_1_RE = /~1/g;
const TILDE_RE = /~/g;
const FS_RE = /\//g;
export const TS_INDEX_RE = /\[("(\\"|[^"])+"|'(\\'|[^'])+')]/g;
const TS_UNION_INTERSECTION_RE = /[&|]/;
const JS_OBJ_KEY = /^(\d+|[A-Za-z_$][A-Za-z0-9_$]*)$/;
export function walk(obj, cb, path = []) {
    if (!obj || typeof obj !== "object")
        return;
    if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++)
            walk(obj[i], cb, path.concat(i));
        return;
    }
    cb(obj, path);
    for (const k of Object.keys(obj))
        walk(obj[k], cb, path.concat(k));
}
export function getSchemaObjectComment(v, indentLv) {
    if (!v || typeof v !== "object")
        return;
    const output = [];
    if (v.title)
        output.push(`${v.title} `);
    if (v.summary)
        output.push(`${v.summary} `);
    if (v.format)
        output.push(`Format: ${v.format} `);
    if (v.deprecated)
        output.push(`@deprecated `);
    const supportedJsDocTags = ["description", "default", "example"];
    for (const field of supportedJsDocTags) {
        const allowEmptyString = field === "default" || field === "example";
        if (v[field] === undefined) {
            continue;
        }
        if (v[field] === "" && !allowEmptyString) {
            continue;
        }
        const serialized = typeof v[field] === "object" ? JSON.stringify(v[field], null, 2) : v[field];
        output.push(`@${field} ${serialized} `);
    }
    if ("const" in v)
        output.push(`@constant `);
    if (v.enum) {
        let type = "unknown";
        if (Array.isArray(v.type))
            type = v.type.join("|");
        else if (typeof v.type === "string")
            type = v.type;
        output.push(`@enum {${type}${v.nullable ? `|null` : ""}}`);
    }
    return output.length ? comment(output.join("\n"), indentLv) : undefined;
}
export function comment(text, indentLv) {
    const commentText = text.trim().replace(COMMENT_RE, "*\\/");
    if (!commentText.includes("\n"))
        return `/** ${commentText} */`;
    const ln = indent(" * ", indentLv ?? 0);
    return ["/**", `${ln}${commentText.replace(LB_RE, `\n${ln}`)}`, indent(" */", indentLv ?? 0)].join("\n");
}
export function parseRef(ref) {
    if (typeof ref !== "string")
        return { filename: ".", path: [] };
    if (!ref.includes("#"))
        return { filename: ref, path: [] };
    const [filename, path] = ref.split("#");
    return {
        filename: filename || ".",
        path: path
            .split("/")
            .filter((p) => !!p && p !== "properties")
            .map(decodeRef),
    };
}
export function parseTSIndex(type) {
    const parts = [];
    const bracketI = type.indexOf("[");
    if (bracketI === -1)
        return [type];
    parts.push(type.substring(0, bracketI));
    const matches = type.match(TS_INDEX_RE);
    if (matches) {
        for (const m of matches)
            parts.push(m.substring('["'.length, m.length - '"]'.length));
    }
    return parts;
}
export function makeTSIndex(parts) {
    return `${parts[0]}[${parts.slice(1).map(escStr).join("][")}]`;
}
export function decodeRef(ref) {
    return ref.replace(ESC_0_RE, "~").replace(ESC_1_RE, "/").replace(DOUBLE_QUOTE_RE, '\\"');
}
export function encodeRef(ref) {
    return ref.replace(TILDE_RE, "~0").replace(FS_RE, "~1");
}
export function tsArrayOf(type) {
    return `(${type})[]`;
}
export function tsIntersectionOf(...types) {
    if (types.length === 1)
        return String(types[0]);
    return types.map((t) => (TS_UNION_INTERSECTION_RE.test(t) ? `(${t})` : t)).join(" & ");
}
export function tsNonNullable(type) {
    return `NonNullable<${type}>`;
}
export function tsOneOf(...types) {
    if (types.length === 1)
        return types[0];
    return `OneOf<[${types.join(", ")}]>`;
}
export function tsPick(root, keys) {
    return `Pick<${root}, ${tsUnionOf(...keys.map(escStr))}>`;
}
export function tsOmit(root, keys) {
    return `Omit<${root}, ${tsUnionOf(...keys.map(escStr))}>`;
}
export function tsWithRequired(root, keys) {
    return `WithRequired<${root}, ${tsUnionOf(...keys.map(escStr))}>`;
}
export function tsOptionalProperty(key) {
    return `${key}?`;
}
export function tsReadonly(type) {
    return `readonly ${type}`;
}
export function tsTupleOf(...types) {
    return `[${types.join(", ")}]`;
}
export function tsUnionOf(...types) {
    if (types.length === 1)
        return String(types[0]);
    return types.map((t) => (TS_UNION_INTERSECTION_RE.test(String(t)) ? `(${t})` : t)).join(" | ");
}
export function escStr(input) {
    if (typeof input !== "string")
        return input;
    return `"${input.trim().replace(DOUBLE_QUOTE_RE, '\\"')}"`;
}
export function escObjKey(input) {
    return JS_OBJ_KEY.test(input) ? input : escStr(input);
}
export function indent(input, level) {
    return "  ".repeat(level).concat(input);
}
export function getEntries(obj, alphabetize) {
    const entries = Object.entries(obj);
    if (alphabetize)
        entries.sort(([a], [b]) => a.localeCompare(b, "en", { numeric: true }));
    return entries;
}
export function error(msg) {
    console.error(c.red(` âœ˜  ${msg}`));
}
export function isRemoteURL(url) {
    return url.startsWith("https://") || url.startsWith("//") || url.startsWith("http://");
}
export function isFilepath(url) {
    return url.startsWith("file://") || isAbsolute(url);
}
export function getDefaultFetch() {
    const globalFetch = globalThis.fetch;
    if (typeof globalFetch === "undefined") {
        return unidiciFetch;
    }
    return globalFetch;
}
//# sourceMappingURL=utils.js.map