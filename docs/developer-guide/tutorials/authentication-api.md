# Terms

- **_Client App_** - the application which uses Orion as a backend, responsible for authenticating the user via the Auth API,
- **_Auth API_** - Orion's authentication REST API, separate from the Orion GraphQL API
- **_GraphQL API_** - Orion's GraphQL API, exposing all the GraphQL queries and mutations, accessible only by authenticated users, 
- **_User_** - any user of the _Client App_ / Orion, regarldess of whether they have a registered Gateway account or not,
- **_Anonymous user_** - a user who either doesn't have a Gateway account or is not logged in to a Gateway account and therefore uses [anonymous authentication](#anonymous-authentication).
- **_Root user_** - a special kind of a user, typically a gateway operator, with extra privileges to execute certain _GraphQL API_ queries and mutations. It is initially created during database migration step based on the environment variables provided by the gateway administrator.
- **_Gateway account owner_** - _User_ that has registered and owns a Gateway account.
- **_Authenticated request_** - a request which inlcudes a valid session cookie (as described [here](#sessions-and-authenticated-requests)) and can therefore be associated with an existing, active session (stored in Orion's database).
- **_Authentication request_** - a request to perform the authentication and start a new session (either `POST /login` or `POST /anonymous-auth`).
- **_Gateway account_** - an account that exists in Orion's database and can be logged in to, not to be confused with _Blockchain account_. Many _Blockchain accounts_ can be associated with a single _Gateway account_.
- **_Blockchain account_** - an account that exists on the Joystream blockchain and can be identified with an address, such as `j4W7rVcUCxi2crhhjRq46fNDRbVHTjJrz6bKxZwehEMQxZeSf` for example. A _Blockchain account_ can be associated with a _Gateway account_ and a valid signature from a _Blockchain account_ can be used to authenticate as _Gateway account owner_.

# Auth API overview

Orion's auth API is a REST API, separate from the GraphQL API (the main Orion API), which is being secured by it.

This approach can also be called [_out-of-band_ authenticaiton](https://cloudcity.io/blog/2021/08/22/GraphQL-Authentication-Why-out-of-band-authentication-is-better-than-in-band/), to distinguish it from _in-band_ authentiation, which would be an authentication implemented as part of the same GraphQL api that is being secured by it. 

The Auth API implementation can be found in the [`src/auth-server`](../../../src/auth-server) directory.

The implementation is based on the [OpenAPI schema](https://swagger.io/specification/) which can be found **[here](../../../src/auth-server/openapi.yml)**.

The autogenerated Markdown documentation of the API can be found **[here](../../../src/auth-server/docs/README.md)**. It is generated from the OpenAPI schema via `npm run generate:docs:auth-api` command.

## Input schema

The input schema which defines the entities related to user authentication can be found in [/schema/auth.graphql](../../../schema/auth.graphql) file.


### `User` entity

`User` entity is the most basic representation of a Client App / Orion user, it can be either an _anonymous user_ (have no related _`Account`_) or a _gateway account owner_.

Each `User` has a securely random `id` (32-byte string) assigned on creation, which can be stored on user's device (for example, in Browser's local storage) or shared across multiple devices in order to authenticate the user using [anonymous authentication](#anonymous-auth) and preserve some information about their activity on the platform.

A `User` can be associated with activities such as viewing a video, or searching for specific content, which can be later used to provide a personalized experience to the user once they create an account.

Some example functionality that can be enabled for an _anonymous_ `User`s (not all of those features are currently implemented):
- Video view history
- Continue watching...
- Search history
- Basic recommendations

We may choose not to provide all of those features to _anonymous_ Users, but it should be possible to at least collect the user activity data, which can later be preserved once the user creates an account (and becomes a _gateway account owner_), because of the `User` <=> `Account` association.

**Importat:** `id` of a `User` that has been associated with an `Account` can no longer be used to authenticate as _anonymous user_ (ie. cannot be used for [anonymous authentication](#anonymous-auth))!

### `Session` entity

`Session` represents a period of activity of a `User` that interacts with the Client App or Orion API directly, during which the user can perform [authenticated requests](#sessions-and-authenticated-requests) (either as _anonymous user_ or _gateway account owner_) and [access the GraphQL API](#accessing-graphql-api).

For more information about sessions see _[Sessions and authenticated requests](#sessions-and-authenticated-requests)_.

### `Account` entity

An `Account` represents a _Gateway account_ which can be accessed by the _Gateway account owner_ by providing a signed log-in message. The log-in message must be signed by one of the _Blockchain accounts_ associated with the _Gateway account_.

### `ConnectedAccount` entity

A `ConnectedAccount` represents a _Blockchain account_ that is associated with a _Gateway account_ and can be used to authenticate as the _Gateway account owner_ through a signed message posted to the [`POST /login`](../../../src/auth-server/docs/Apis/DefaultApi.md#login) endpoint. New _Blockchain accounts_ can be connected to a _Gateway account_ via [`POST /connect-account`](#connect-external-accounts) endpoint. _Blockchain accounts_ can also be disconnected from a _Gateway account_ via [`POST /disconnect-account`](#disconnect-joystream-accounts) endpoint.

### `EncryptionArtifacts` entity

`EncryptionArtifacts` represents a set of encryption artifacts (`cipherIv` and `encryptedSeed`) which can be used by the _Client app_ to decrypt the `seed` of a _Blockchain account_ based on the user's login credentials. For details, see: [Authentication API interactions](#authentication-api-interactions) (specifically [_Create user account_](#create-user-account) and [_Login using e-mail and password_](#log-in-to-user-account-using-e-mail-and-password) flows).

### `SessionEncryptionArtifacts` entity

`SessionEncryptionArtifacts` represents a set of encryption artifacts (`cipherIv` and `cipherKey`) associated with a given session, allowing the _Client app_ to more securely store user's seed throughout the session. For details, see _[Store encrypted seed for the duration of the session](#store-encrypted-seed-for-the-duration-of-the-session)_ flow.

### `Token` entity

`Token` represents a unique, securely random string generated by the Auth API for a given `Account` which can allow executing a specific action on behalf of the user without the need for authentication, Currently the only use-case for tokens is e-mail confirmation.

A token has an expiry date which depends on the Orion configuration (see: [Configuration variables](#configuration-variables)).

## Configuration variables

Those configuration variables can be set as part of the environment, for more details about config variables see [Config variables](./config-variables.md). 

- `OPERATOR_SECRET` - a secret string used as an identifier of the _Root user_, which is created during the database migration step. **Important:** Anyone who knows this secret can authenticate as the _Root user_ (Gateway operator) and access the restriced queries and mutations!
- `SESSION_EXPIRY_AFTER_INACTIVITY_MINUTES` - after how many minutes does the session expire in case they are no [authenticated requests](#sessions-and-authenticated-requests) associated with the session being performed.
- `SESSION_MAX_DURATION_HOURS` - after how many hours does the session expire regardless of whether there were any recent [authenticated requests](#sessions-and-authenticated-requests) associated with the session performed.
- `SENDGRID_API_KEY` - API key for the Sendgrid API, used for sending e-mails to the _Gateway account owners_ by Orion (currently only for the purpose of e-mail confirmation)
- `SENDGRID_FROM_EMAIL` - e-mail address that will be used as the sender of e-mails sent to the _Gateway account owners_ by Orion.
- `APP_NAME` - the name of the Gateway. It will be used in the e-mails sent to the _Gateway account owners_. It also has to be specified as part of the payload of some signed messages that need to be provided to the authentication api to make certain actions. For example, the [log-in message](../../../src/auth-server/docs/Models/LoginRequestData.md) which has to be provided in order to authenticate as _Gateway account owner_.
- `EMAIL_CONFIRMATION_ROUTE` - the route in the Client app that will be used to confirm the e-mail address of a _Gateway account owner_.
- `EMAIL_CONFIRMATION_TOKEN_EXPIRY_TIME_HOURS` - self-explainatory
- `EMAIL_CONFIRMATION_TOKEN_RATE_LIMIT` - how many requests for a new e-mail confirmation token can be made within `EMAIL_CONFIRMATION_TOKEN_EXPIRY_TIME_HOURS` for a given e-mail address
- `ACCOUNT_OWNERSHIP_PROOF_EXPIRY_TIME_SECONDS` - how many seconds have to pass since the timestamp included in a signed message that proves the ownership of a _Blockchain account_ (ie. [`ActionExecutionRequestData`](../../../src/auth-server/docs/Models/ActionExecutionRequestData.md)) in order for that message to be considered expired.
- `MAX_CONNECTED_ACCOUNTS_PER_USER` - how many _Blockchain accounts_ can be associated with a single _Gateway account_.
- `COOKIE_SECRET` - secret used to sign cookies, to make sure they come from Orion and have not been tampered with.

## Sessions and authenticated requests

HttpOnly, `same-site: strict` session cookie is used as an authentication mechanism (both by the Auth API and the GraphQL API).
**This implies that the Client App, the GraphQL API and the Auth API must be hosted on the same domain!**

The cookie is called `session_id` and stores the unique, randomly generated `id` of a `Session` entity in the database. It is set upon successful `/login` or `/anonymous-auth` request.

Upon receiving an authenticated request (ie. a request that contains a valid `session_id` cookie), the server reads session information associated with the session identified by the given `session_id`, either directly from the database (which is shared between GraphQL API server and the Auth API server) or from a memory session cache.

Each session, besides being associated with a specific user (either an _anonymous user_ or _Gateway account owner_), includes the following information:
- `Session.ip` - ip address of the agent that performed the authentication request,
- `Session.browser` - browser that was used to perform the authentication request, as derived from the `user-agent` header,
- `Session.os` - operating system that was used to perform the authentication request, as derived from the `user-agent` header,
- `Session.device` - device that was used to perform the authentication request, as derived from the `user-agent` header,
- `Session.expiry` - the date at which the session should expire or did expire.

This information is then compared with the authenticated request data.
It is required that:
- `Session.ip` matches the IP of the agent that made the authenticated request,
- `Session.browser`, `Session.os` and `Session.device` match the values derived from the `user-agent` header included in the authenticated request,
- `Session.expiry` is `< Date.now()`.

This basically means that `ip`, `brower`, `os` and `device` should not change during the course of a given session. In case any of those change, a re-authentication is required.

This solution makes it possible to track the activitiy of a given `User` more accurately and adds additional layer of security, as even a stolen session cookie would be useless unless the attacker can make requests from the user's ip.

### Session expiry

A session can expire:
- If it is associated with an account and the account owner performs a `POST /logout` request,
- If it is associated with anonymous user and the user creates a Gateway account,
- After `SESSION_EXPIRY_AFTER_INACTIVITY_MINUTES` minutes of inactivity, counted from the last authenticated request,
- After `SESSION_MAX_DURATION_HOURS` hours, starting from the time when the session was created.

## Accessing the GraphQL API

All requests to the GraphQL api should be [authenticated requests](#sessions-and-authenticated-requests), regardless of whether they are queries or mutations.

Of course different requests may still require different privileges, ie. some mutations like `setSupportedCategories` will be only accessible for _root user_ etc., while other mutations may only be accessible for _Gateway account owners_.

## Authentication API interactions

### Anonymous auth:

**This is the first step required in order to interact with the GraphQL API.**

```
POST /api/v1/anonymous-auth
```

- Save `userId` from response to local storage and use it for subsequent guest auth requests once the session expires.

### Auth as operator in order to access secured Orion queries and mutations:

```
POST /api/v1/anonymous-auth
{ "userId": "operator-secret" }
```

(where `operator-secret` must be the value of `OPERATOR_SECRET` environment variable)

### Create user account:

1. Authenticate as anonymous user first (see [Anonymous auth](#anonymous-auth))

2. Create encryption artifacts using user's credentials (e-mail, password). For reference code see: [`src/auth-server/tests/artifacts.ts`](../../../src/auth-server/tests/artifacts.ts#L39) (the `seed` and `cipherIv` should be randomly generated)

3. Make request to create a new account:
    ```
    POST /api/v1/account
    {
      "signature": "signatureOverPayload",
      "payload": {
        "joystreamAccountId": "ss58Address",
        "gatewayName": "Gleev",
        "timestamp": 1682624588376,
        "action": "createAccount",
        "email": "user@example.com"
      }
    }
    ```
    Where:
    - `signature` is a signature over `JSON.stringify(pyaload)`
    - `joystreamAccountId` must be unique (this is the address of the keypair generated from `seed`)
    - `gatewayName` must match the `APP_NAME` environment variable
    - `timestamp` must be current timestamp in miliseconds
    - `action` must be `createAccount`
    - `email` must be unique

4. Store encryption artifacts:
    ```
    POST /api/v1/artifacts
    {
      "id": "hex-encoded-id",
      "encryptedSeed": "hex-encoded-encrypted-seed",
      "cipherIv": "hex-encoded-iv"
    }
    ```

### Log-in to user account using e-mail and password

1. User provides email and password
2. Compute `id` of the _artifacts_ using the provided e-mail and password as described in [_Create user account_](#create-user-account) (point _2._)
3. Get the _artifacts_:
    ```
    GET /api/v1/artifacts?id={id}
    ```
    In response you get the stored `cipherIv` and `encryptedSeed`.
4. You can now decrypt user's seed using those artifacts, for reference code see: [`src/auth-server/tests/artifacts.ts`](../../../src/auth-server/tests/artifacts.ts#L88)
5. Make login request:
    ```
    POST /api/v1/login
    {
      "signature": "signatureOverPayload",
      "payload": {
        "joystreamAccountId": "ss58Address",
        "gatewayName": "Gleev",
        "timestamp": 1682624588376,
        "action": "login"
      }
    }
    ```
    Where:
    - `signature` is a signature over `JSON.stringify(pyaload)`
    - `joystreamAccountId` is the address of the account from the decrypted seed 
    - `gatewayName` must match the `APP_NAME` environment variable
    - `timestamp` must be current timestamp in miliseconds
    - `action` must be `login`

    In response you'll get `accountId` which you should store locally (for example, in local storage)

### Store encrypted seed for the duration of the session

After the user is logged in, you can encrypt their wallet seed to store it more safely (for example: in local storage) for the duration of the session.

In order to do this:
1. Generate random `cipherIv` (16 bytes) and `cipherKey` (32 bytes)
2. Encrypt the seed using generated artifacts with AES-256-CBC algorithm
3. Save _session artifacts_ on the server:
    ```
    POST /api/v1/session-artifacts
    {
      "cipherKey": "generatedRandomKey",
      "cipherIv": "generatedRandomIv"
    }
    ```
4. You can retrieve the stored _session artifacts_ later in order to decrypt the locally stored, encrypted seed:
    ```
    GET /api/v1/session-artifacts
    ```

### Connect _external_ accounts

You can connect other Joystream accounts (for example, from an extension) to an existing Orion account in order to be able to use them when signing in.

```
POST /api/v1/connect-account
{
  "signature": "signatureOverPayload",
  "payload": {
    "joystreamAccountId": "ss58Address",
    "gatewayName": "Gleev",
    "timestamp": 1682624588376,
    "action": "connect",
    "gatewayAccountId": "accountId"
  }
}
```
Where:
- `signature` is a signature over `JSON.stringify(pyaload)`
- `joystreamAccountId` is the address of the account to be connected
- `gatewayName` must match the `APP_NAME` environment variable
- `timestamp` must be current timestamp in miliseconds
- `action` must be `connect`
- `gatewayAccountId` must be `accountId` as provided during `POST /login`

### Disconnect Joystream accounts

To disconnect Joystream account from an Orion account you must be logged in (have na active session).
Once logged in, you can simply call:

```
POST /api/v1/disconnect-account
{
  "joystreamAccountId": "ss58Address",
}
```
Where:
- `joystreamAccountId` is the address of the account to be disconnected

### Logout

```
POST /api/v1/logout
```

# Development

## Architecture

The central part of the Orion Auth Server is the OpenAPI schema (`src/auth-server/openapi.yml`). It defines the API endpoints, their parameters and responses.

The server itself is implemented using Express.js with [`express-openapi-validator`](https://www.npmjs.com/package/express-openapi-validator) middleware. The middleware is responsible for validating the requests (and optionally responses) against the OpenAPI schema and provides some other useful features like:
- mapping requests to [operation handler functions](https://github.com/cdimascio/express-openapi-validator/wiki/Documentation#%EF%B8%8F-operationhandlers-optional) based on the `x-eov-operation-handler` property specified in the OpenAPI schema, so that individual routes don't have to be defined manually,
- applying [security handlers](https://github.com/cdimascio/express-openapi-validator/wiki/Documentation#security-handlers) based on the `security` property specified in the OpenAPI schema.

## Commands

- `npm run generate:types:auth-api` - generates TypeScript types based on the OpenAPI schema. Those types are saved in `src/auth-server/generated/api-types.ts`.
- `npm run generate:docs:auth-api` - generates the markdown documentation based on the OpenAPI schema. The documentation is saved in `src/auth-server/docs`.
- `npm run tests:auth-api` - runs the auth API unit tests. WARNING: it runs `docker-compose down -v` before running the tests in order to ensure clean state!

## Making changes to the API

The process of introducing changes to the API usually involves:
1. Making changes to the OpenAPI schema (`src/auth-server/openapi.yml`).
2. Updating the autogenerated types and documentation by running `npm run generate:types:auth-api` and `npm run generate:docs:auth-api`.
3. Making changes to the code to reflect the changes in the API. This usually involves adding or modifying the handlers in `src/auth-server/handlers`. The handlers are automatically connected to the API endpoints based on the `x-eov-operation-handler` property specified in the OpenAPI schema (ie. the filename of the handler must match the value of this property).
4. Adding/adjusting the unit tests in `src/auth-server/tests`.
5. Running the unit tests (`npm run tests:auth-api`) and manually testing the API (see the section below)

## Testing

### Unit tests

The unit tests are located in `src/auth-server/tests`. They are written using [Mocha.js](https://mochajs.org/) framework and [supertest](https://www.npmjs.com/package/supertest).

Generally for each API endpoint there should be at least one test case for each of the response codes defined in the OpenAPI schema.

Some common, reusable utilities and fixtures, like functions for doing anonymous auth, creating new accounts, signing in, verifying endpoint rate limits, encrypting and decrypting data etc. are located in `src/auth-server/tests/common.ts`.

### Testing the API locally

You can use the OpenAPI playground (generated by `swagger-ui-express` package) to test the API locally.

To do that you need to set the `OPENAPI_PLAYGROUND` environment variable to `true` before starting the server. For example:
```bash
# If not already done, install dependencies, run codegen and build the code:
# make prepare

export OPENAPI_PLAYGROUND=true

docker-compose up -d orion_auth-api
# Or `make up` / `make up-squid` to run all the Orion services
```

By default the Auth API is served at `http://localhost:4074/api/v1` and the playground is available at `http://localhost:4074/playground`.

### Staging environment

When deploying to the staging environment, you can sidestep the `same-site: strict` and CORS restrictions in order to be able to test the API with the Client app (like Atlas) deployed under a different domain.

To do that you need to make sure to set those 2 environment variables:
```bash
export NODE_ENV=development
export DEV_DISABLE_SAME_SITE=true
```

**Warning:** Never use those settings in production! This configuration is much less secure and should only be used for testing purposes.

In order to be able to pass the cookie to Orion's Auth API when making requests from Atlas deployed under different domain, you should specify `credentials: 'include'` option in ApolloClient's `HttpLink` (see: https://www.apollographql.com/docs/react/networking/authentication/).

Similarly, to include the cookie when making requests to the GraphQL API, you should provide `credentials: 'include'` to `fetch`: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#sending_a_request_with_credentials_included